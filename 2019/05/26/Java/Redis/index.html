<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="Redis 是一款典型的内存数据库">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis">
<meta property="og:url" content="http://yoursite.com/2019/05/26/Java/Redis/index.html">
<meta property="og:site_name" content="Pikachu&#39;s Blog">
<meta property="og:description" content="Redis 是一款典型的内存数据库">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/images/Redis/image-20210418183342979.png">
<meta property="og:image" content="http://yoursite.com/images/Redis/image-20210418184239104.png">
<meta property="og:image" content="http://yoursite.com/images/Redis/image-20210418184103343.png">
<meta property="og:image" content="http://yoursite.com/images/Redis/image-20210419080132793.png">
<meta property="og:image" content="http://yoursite.com/images/Redis/image-20210419080902336.png">
<meta property="og:image" content="http://yoursite.com/images/Redis/image-20210419080933127.png">
<meta property="og:image" content="http://yoursite.com/images/Redis/image-20210420223744148.png">
<meta property="og:image" content="http://yoursite.com/images/Redis/image-20210421110246270.png">
<meta property="og:image" content="http://yoursite.com/images/Redis/image-20210421103749221.png">
<meta property="og:image" content="http://yoursite.com/images/Redis/image-20210421103908185.png">
<meta property="og:image" content="http://yoursite.com/images/Redis/image-20210421104001570.png">
<meta property="og:image" content="http://yoursite.com/images/Redis/image-20210421104040770.png">
<meta property="og:image" content="http://yoursite.com/images/Redis/image-20210421104209874.png">
<meta property="og:image" content="http://yoursite.com/images/Redis/image-20210421122559174.png">
<meta property="og:image" content="http://yoursite.com/images/Redis/image-20210421120043623.png">
<meta property="og:image" content="http://yoursite.com/images/Redis/image-20210421122912946.png">
<meta property="og:image" content="http://yoursite.com/images/Redis/image-20210421121335359.png">
<meta property="article:published_time" content="2019-05-26T07:07:19.000Z">
<meta property="article:modified_time" content="2021-06-07T09:21:20.675Z">
<meta property="article:author" content="pikachu">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/images/Redis/image-20210418183342979.png">

<link rel="canonical" href="http://yoursite.com/2019/05/26/Java/Redis/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Redis | Pikachu's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Pikachu's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/26/Java/Redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="pikachu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pikachu's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-26 15:07:19" itemprop="dateCreated datePublished" datetime="2019-05-26T15:07:19+08:00">2019-05-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-07 17:21:20" itemprop="dateModified" datetime="2021-06-07T17:21:20+08:00">2021-06-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Redis 是一款典型的内存数据库</p>
<a id="more"></a>

<h2 id="Redis-简介"><a href="#Redis-简介" class="headerlink" title="Redis 简介"></a>Redis 简介</h2><p>Redis（<strong>Re</strong>mote <strong>Di</strong>rectory <strong>S</strong>erver）：远程字典服务，由 C 语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库，属于非关系型数据库（NoSQL），可以作为<strong>数据库</strong>、<strong>缓存</strong>和<strong>消息中间件</strong>。</p>
<blockquote>
<p>NoSQL：Not Only SQL</p>
</blockquote>
<p>关系型数据库 和 非关系型数据库的区别:</p>
<ul>
<li>关系型数据库:<ul>
<li>数据之间有联系</li>
<li>数据存储在硬盘的文件上</li>
</ul>
</li>
<li>非关系型数据库<ul>
<li>数据之间没有关系</li>
<li>数据存储在内存中</li>
</ul>
</li>
</ul>
<blockquote>
<p>关系型数据库和非关系型数据库是一种互补的状态</p>
<p>一般将数据存储在关系型数据库中, 在非关系型数据库中备份存储关系型数据库中的数据</p>
</blockquote>
<h2 id="Redis-安装"><a href="#Redis-安装" class="headerlink" title="Redis 安装"></a>Redis 安装</h2><blockquote>
<p>Redis 官方推荐在 Linux 上使用，而且官方只提供了 Linux 的安装包。</p>
<p>Windows 版本的 Redis 一直是微软维护的，但是也好久没有更新了。</p>
</blockquote>
<p><strong>Redis 在 Linux 上的安装步骤：</strong></p>
<ol>
<li><p>官网下载 <code>.tar.gz</code> 压缩包</p>
</li>
<li><p>把解压缩后的文件夹放到 <code>/usr/local</code> 目录下</p>
</li>
<li><p>cd 到解压后的文件夹，执行 <code>make</code> 命令编译 Redis</p>
<blockquote>
<p>因为 Redis 是 C 语言编写的，所以编译需要 gcc，</p>
<p>安装 gcc：<code>yum install gcc-c++</code></p>
<blockquote>
<p>踩坑记录：</p>
<p>我下载的 Redis 是 6.2.1 版本的，而 yum 自动安装的 gcc 是 4.8.5 版本，此时 <code>make</code> 会报错，需要升级 gcc</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 依次执行下列命令升级 gcc 到 9.x.x 版本</span></span><br><span class="line">yum -y install centos-release-scl</span><br><span class="line"> </span><br><span class="line">yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils</span><br><span class="line"> </span><br><span class="line">scl <span class="built_in">enable</span> devtoolset-9 bash</span><br><span class="line"> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"source /opt/rh/devtoolset-9/enable"</span> &gt;&gt; /etc/profile</span><br><span class="line"> </span><br><span class="line">gcc -v	<span class="comment"># 查看 gcc 版本</span></span><br></pre></td></tr></table></figure>

<p>升级完 gcc 版本如果 <code>make</code> 还是报错，则执行下面命令清理一下就好了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make distclean</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
</li>
<li><p>编译完成后，执行下面命令安装 Redis</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置PREFIX可以让Redis相关的文件都存放在 usr/local/redis 相关目录下，方便以后操作</span></span><br><span class="line">make PREFIX=/usr/<span class="built_in">local</span>/redis install</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装完成，<code>redis-server</code> 和 <code>redis-cli</code> 都会放在 <code>/user/local/redis/bin</code> 目录下。</p>
<p><img src="/images/Redis/image-20210418183342979.png" alt="image-20210418183342979"></p>
</li>
<li><p>Redis 的配置文件 <code>redis.conf</code> 会放在 <code>/user/local/redis</code> 目录下。启动 Redis 服务前，需要修改配置文件： <code>daemonize yes</code>，意思是让 Redis 服务以守护线程的方式启动（也就是后台运行）</p>
</li>
<li><p>启动 Redis 服务：<code>./redis-server ../redis.conf</code></p>
<p><img src="/images/Redis/image-20210418184239104.png" alt="image-20210418184239104"></p>
<blockquote>
<p>查看 Redis 服务进程：<code>ps -ef | grep redis</code></p>
</blockquote>
</li>
<li><p>启动 Redis 客户端，操作 Redis：<code>./redis-cli</code></p>
<p><img src="/images/Redis/image-20210418184103343.png" alt="image-20210418184103343"></p>
</li>
</ol>
<h2 id="Redis-基本知识"><a href="#Redis-基本知识" class="headerlink" title="Redis 基本知识"></a>Redis 基本知识</h2><p>Redis 默认有 16 个数据库，可以在 <code>redis.conf</code> 配置文件中看到</p>
<p><img src="/images/Redis/image-20210419080132793.png" alt="image-20210419080132793"></p>
<p>切换数据库：<code>SELECT &lt;dbid&gt;</code></p>
<p><img src="/images/Redis/image-20210419080902336.png" alt="image-20210419080902336"></p>
<p>查看当前数据库大小：<code>DBSIZE</code></p>
<p><img src="/images/Redis/image-20210419080933127.png" alt="image-20210419080933127"></p>
<p>清除当前数据库数据：<code>FLUSHDB</code></p>
<p>清除所有数据库数据：<code>FLUSHALL</code></p>
<blockquote>
<p>Redis 是单线程的</p>
<p>因为多线程并不一定所有情况下都比单线程快，多线程时 CPU 上下文切换比较耗时。</p>
<p>Redis 的所有数据都是存在内存中的，与 CPU 交互使用单线程是效率最高的。</p>
<p>Redis 的瓶颈并不是 CPU，而是内存和网络带宽。</p>
</blockquote>
<h2 id="Redis-五大数据类型"><a href="#Redis-五大数据类型" class="headerlink" title="Redis 五大数据类型"></a>Redis 五大数据类型</h2><p>Redis 中 key 都是字符串, value 则有 5 种不同的数据类型</p>
<p>value 的数据类型:</p>
<ol>
<li>字符串类型 String</li>
<li>哈希类型 hash  (map格式)</li>
<li>列表类型 list  (linkedlist格式)</li>
<li>集合类型 set</li>
<li>有序集合类型 sortedset</li>
</ol>
<p><strong>通用操作</strong>:</p>
<ul>
<li><code>keys *</code>  查询所有键</li>
<li><code>exists key</code> 判断 key 是否存在</li>
<li><code>type key</code>  获取 <code>key</code> 对应的 <code>value</code> 的类型</li>
<li><code>expire key seconds</code>：设置 key 的过期时间</li>
<li><code>ttl key</code>：查看 key 的剩余过期时间</li>
<li><code>del key</code>  删除指定的 key value</li>
</ul>
<h3 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> name zhangsan			<span class="comment"># 设置值</span></span><br><span class="line">get name					<span class="comment"># 获取值</span></span><br><span class="line">del name					<span class="comment"># 删除</span></span><br><span class="line"></span><br><span class="line">append name good			<span class="comment"># 追加字符串，如果key不存在，相当于set，</span></span><br><span class="line">strlen name					<span class="comment"># 获取字符串的长度</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">incr views					<span class="comment"># 自增1，浏览量 +1</span></span><br><span class="line">decr views					<span class="comment"># 自减1，浏览量 -1</span></span><br><span class="line"></span><br><span class="line">incrby views 10				<span class="comment"># 自定义自增步长</span></span><br><span class="line">decrby views 10				<span class="comment"># 自定义自减步长</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">getrange tel 2 5			<span class="comment"># 截取字符串 [2,5]</span></span><br><span class="line">setrange tel 2 xx			<span class="comment"># 替换字符串，从第2个开始替换（包括第二个） </span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">setex cookie 100 azzzz		<span class="comment"># 设置值，同时设置失效时间（100秒后失效）</span></span><br><span class="line">setnx cookie axxxxx			<span class="comment"># 当 cookie 不存在时才能设置值</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">mset k1 v1 k2 v2 k3 v3		<span class="comment"># 同时设置多个值</span></span><br><span class="line">mget k1 k2 k3				<span class="comment"># 同时获取多个值</span></span><br><span class="line"></span><br><span class="line">msetnx k1 v1 k4 v4			<span class="comment"># 当多个值都不存在的时候才能设置成功，具有原子性</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="built_in">set</span> user:1:name zhangsan	<span class="comment"># key 可以设置为 user:&#123;id&#125;:&#123;field&#125; 的形式，保存对象常用</span></span><br><span class="line">get user:1:name				<span class="comment"># 获取值</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">getset name wangwu			<span class="comment"># 先获取值再设置值</span></span><br></pre></td></tr></table></figure>



<h3 id="List-类型"><a href="#List-类型" class="headerlink" title="List 类型"></a>List 类型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># key为列表名,  列表中的元素都为String</span></span><br><span class="line"><span class="comment"># 写列表中的元素时不用加引号，Redis会把输入的内容自动转为String</span></span><br><span class="line">lpush key element				<span class="comment"># 从列表的左边添加元素（可以一次添加多个）</span></span><br><span class="line">rpush key element				<span class="comment"># 从列表的右边添加元素（可以一次添加多个）</span></span><br><span class="line"></span><br><span class="line">lrange key start end			<span class="comment"># 获取列表指定范围内的元素 [start, end]</span></span><br><span class="line"></span><br><span class="line">lpop key						<span class="comment"># 删除列表最左边的元素并返回</span></span><br><span class="line">rpop key						<span class="comment"># 删除列表最右边的元素并返回</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">lindex key index				<span class="comment"># 通过 index 下标获取值</span></span><br><span class="line">llen key						<span class="comment"># 获取列表的长度</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">lrem key count element			<span class="comment"># 从列表中移除 count 数量的指定 element（从左边移除）</span></span><br><span class="line"></span><br><span class="line">ltrim key start end				<span class="comment"># 截取指定区间的元素 [start, end]，列表就只剩截取后的元素</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">rpoplpush <span class="built_in">source</span> dest			<span class="comment"># 将列表中的最后一个元素移动到新列表第一个位置，如果新列表不存在则会创建</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">lset key 0 aa					<span class="comment"># 将列表中第 0 个元素替换为 aa，如果列表或下标不存在都会报错</span></span><br><span class="line">linsert key before element aa 	<span class="comment"># 将aa插入到指定element的前面</span></span><br><span class="line">linsert key after element bb 	<span class="comment"># 将bb插入到指定element的后面</span></span><br></pre></td></tr></table></figure>



<h3 id="Set-类型"><a href="#Set-类型" class="headerlink" title="Set 类型"></a>Set 类型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># key为集合名, 集合中的元素都为String</span></span><br><span class="line">sadd key element			<span class="comment"># 向集合中添加元素（可以一次添加多个）</span></span><br><span class="line"></span><br><span class="line">smembers key  				<span class="comment"># 获取集合中所有元素</span></span><br><span class="line">sismember key element		<span class="comment"># 判断指定的element是否在集合中</span></span><br><span class="line"></span><br><span class="line">srem key element  			<span class="comment"># 删除集合中指定元素</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">scard key					<span class="comment"># 获取集合中元素的个数</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">srandmember key				<span class="comment"># 随机获取集合中的一个元素</span></span><br><span class="line">srandmember key count		<span class="comment"># 随机获取集合中的 count 个元素</span></span><br><span class="line"></span><br><span class="line">spop key					<span class="comment"># 随机删除集合中的一个元素</span></span><br><span class="line">spop key count				<span class="comment"># 随机删除集合中的 count 个元素</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">smove <span class="built_in">source</span> dest element	<span class="comment"># 将指定元素移动到另一个集合中，如果目标集合不存在则会创建</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">sdiff key1 key2				<span class="comment"># 差集，获取key1中不同于key2的元素			</span></span><br><span class="line">sinter key1 key2			<span class="comment"># 交集，可应用于 共同关注</span></span><br><span class="line">sunion key1 key2			<span class="comment"># 并集</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>应用：像交集，可以应用于 微博的共同关注</p>
</blockquote>
<h3 id="Hash-类型"><a href="#Hash-类型" class="headerlink" title="Hash 类型"></a>Hash 类型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">hset key field value		<span class="comment"># 向 map 中添加键值对（可以一次添加多个）</span></span><br><span class="line">hget key field  			<span class="comment"># 获取指定 field 对应的值（一次只能获取一个）</span></span><br><span class="line">hdel key field				<span class="comment"># 删除指定 field 的值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hmset key field1 value1 field2 value2	<span class="comment"># 向map中添加多个键值对，和 hset 用法一样</span></span><br><span class="line">hmget key field1 field2					<span class="comment"># 一次获取多个 field 的值</span></span><br><span class="line"></span><br><span class="line">hgetall key  				<span class="comment"># 获取 key 对应的所有的 field 和 value</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">hlen key					<span class="comment"># 获取 key 中键值对的数量</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">hexists key field			<span class="comment"># 判断指定 field 是否存在</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">hkeys key					<span class="comment"># 获取key中所有 field</span></span><br><span class="line">hvals key					<span class="comment"># 获取key中所有 value</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="comment"># map 中没有 decrby，使用负数就是减少</span></span><br><span class="line">hincrby key field 3			<span class="comment"># 指定 field 的值加 3</span></span><br><span class="line">hincrby key field -2		<span class="comment"># 指定 field 的值减 2</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">hsetnx key field value		<span class="comment"># 如果 field 不存在，则新增键值对；如果存在，则会报错</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>相较于 String 中使用 <code>user:1:name</code> 来存储对象信息来说，Hash 更适合存储对象信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hset user:1 name zhangsan</span><br><span class="line">hset user:1 age 24</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Zset（有序集合）-类型"><a href="#Zset（有序集合）-类型" class="headerlink" title="Zset（有序集合） 类型"></a>Zset（有序集合） 类型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># key为集合名, 通过 score 来排序</span></span><br><span class="line">zadd key score member  			<span class="comment"># 向有序集合中添加元素，同时添加score，用于排序</span></span><br><span class="line">zrange key start end  			<span class="comment"># 获取指定范围内的元素[start, end]，升序排列，start，end为排序后元素下标</span></span><br><span class="line">zrem key member					<span class="comment"># 移除指定元素</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">zcard key						<span class="comment"># 获取有序集合中元素数量</span></span><br><span class="line">zcount key min max				<span class="comment"># 获取指定区间的元素数量，min和max为score</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">zrangebyscore key min max				<span class="comment"># 通过 score 排序（升序），获取区间中的所有值，min和max为score</span></span><br><span class="line">zrangebyscore key min max withscores	<span class="comment"># 通过 score 排序（升序），获取区间中的所有值和对应score，min和max为score</span></span><br><span class="line"></span><br><span class="line">zrevrangebyscore key max min			<span class="comment"># 通过 score 排序（降序），获取区间中的所有值，min和max为score</span></span><br><span class="line">zrevrangebyscore key max min withscores <span class="comment"># 通过 score 排序（降序），获取区间中的所有值和对应score，min和max为score</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>应用：可以用于实现排行榜</p>
</blockquote>
<h2 id="Redis-三种特殊的数据类型"><a href="#Redis-三种特殊的数据类型" class="headerlink" title="Redis 三种特殊的数据类型"></a>Redis 三种特殊的数据类型</h2><h3 id="Geospatial-地理位置"><a href="#Geospatial-地理位置" class="headerlink" title="Geospatial 地理位置"></a>Geospatial 地理位置</h3><blockquote>
<p>微信附近的人，地图中两点之间的距离，都可以使用 Geospatial 来实现</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># longitude 经度，latitude 纬度</span></span><br><span class="line">geoadd key longitude latitude member		<span class="comment"># 添加地理位置</span></span><br><span class="line"><span class="comment"># 例: </span></span><br><span class="line"><span class="comment"># geoadd city 104.46 31.25 mianyang</span></span><br><span class="line"><span class="comment"># geoadd city 116.36 35.42 jiaxiang</span></span><br><span class="line"></span><br><span class="line">geodist key member1 member2 km				<span class="comment"># 获取两点之间的直线距离，默认单位是 m，可以手动切换为 km</span></span><br><span class="line"><span class="comment"># 127.0.0.1:6379&gt; GEODIST city mianyang jiaxiang</span></span><br><span class="line"><span class="comment"># "1198081.4135"</span></span><br><span class="line"><span class="comment"># 127.0.0.1:6379&gt; GEODIST city mianyang jiaxiang km</span></span><br><span class="line"><span class="comment"># "1198.0814"</span></span><br><span class="line"></span><br><span class="line">geopos key member							<span class="comment"># 获取指定member的经纬度信息（可以一次获取多个）</span></span><br><span class="line"><span class="comment"># 127.0.0.1:6379&gt; GEOPOS city jiaxiang mianyang</span></span><br><span class="line"><span class="comment"># 1) 1) "116.36000186204910278"</span></span><br><span class="line"><span class="comment">#    2) "35.41999957443380964"</span></span><br><span class="line"><span class="comment"># 2) 1) "104.46000069379806519"</span></span><br><span class="line"><span class="comment">#    2) "31.25000052442617715"</span></span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">georadius key longitude latitude radius km	<span class="comment"># 从key中获取指定经纬度位置方圆radius km内的 member</span></span><br><span class="line"><span class="comment"># 例：在city中寻找 108.95 34.29（西安市）方圆1000km的城市</span></span><br><span class="line"><span class="comment"># 127.0.0.1:6379&gt; GEORADIUS city 108.95 34.29  1000 km</span></span><br><span class="line"><span class="comment"># 1) "mianyang"</span></span><br><span class="line"><span class="comment"># 2) "jiaxiang"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># withdist：显示距离信息, withcoord：显示坐标信息, count：查询的数量</span></span><br><span class="line">georadius key longitude latitude radius km withdist withcoord count 2</span><br><span class="line"></span><br><span class="line">georadiusbymember key member radius km 		<span class="comment"># 获取指定member方圆radius km内的member</span></span><br><span class="line"><span class="comment"># 127.0.0.1:6379&gt; GEORADIUSBYMEMBER city jiaxiang 2000 km</span></span><br><span class="line"><span class="comment"># 1) "mianyang"</span></span><br><span class="line"><span class="comment"># 2) "jiaxiang"</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>geospatial 并没有直接提供删除 member 的命令，我们可以使用其底层实现来操作。</p>
<p>geospatial 底层使用的是 Zset</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange city 0 -1		<span class="comment"># 查询city中所有member</span></span><br><span class="line">1) <span class="string">"mianyang"</span></span><br><span class="line">2) <span class="string">"jiaxiang"</span></span><br><span class="line">127.0.0.1:6379&gt; zrem city jiaxiang		<span class="comment"># 移除指定member</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange city 0 -1</span><br><span class="line">1) <span class="string">"mianyang"</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h3><blockquote>
<p>统计网站访问人数（同一个人多次访问只记一次），可以使用 hyperloglog 实现</p>
</blockquote>
<p>Hyperloglog 是基数统计算法</p>
<p>基数：简单来说就是一个集合中有多少个不同的元素</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pfadd key element				<span class="comment"># 向key中添加元素（可以一次添加多个）</span></span><br><span class="line"></span><br><span class="line">pfcount key						<span class="comment"># 统计key中元素的基数</span></span><br><span class="line"></span><br><span class="line">pfmerge dest source1 source2	<span class="comment"># 合并两个组到dest中</span></span><br></pre></td></tr></table></figure>



<p>只是计数的情况下，使用 Hyperloglog 是非常有优势的，因为它占用内存最大只有 12k。</p>
<p>在大量的数据下，Hyperloglog 的错误率约为 0.81% ，统计网站访问人数时，这个可以忽略。</p>
<p>但是如果不允许出错的情况下，就不能使用 Hyperloglog 了。</p>
<h3 id="Bitmap-位图"><a href="#Bitmap-位图" class="headerlink" title="Bitmap 位图"></a>Bitmap 位图</h3><blockquote>
<p>记录用户是否登录，活动是否打卡等只有两种状态（0, 1）的信息，就可以使用位图。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setbit key offset value			<span class="comment"># 将key中offset位置的值设为value（0/1）</span></span><br><span class="line"></span><br><span class="line">getbit key offset				<span class="comment"># 获取key中offset位置的值</span></span><br><span class="line"></span><br><span class="line">bitcount key					<span class="comment"># 统计key中value为1的数量</span></span><br></pre></td></tr></table></figure>





<h2 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h2><p>Redis 的事务与 MySQL 事务的区别：</p>
<ul>
<li>Redis 的事务不保证原子性</li>
<li>Redis 的事务没有隔离级别的概念</li>
</ul>
<p>如何使用 Redis 的事务：</p>
<ol>
<li>开启事务：<code>multi</code></li>
<li>命令入队</li>
<li>执行事务：<code>exec</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Redis执行一次事务</span></span><br><span class="line">127.0.0.1:6379&gt; multi			<span class="comment"># 开启事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED							<span class="comment"># QUEUED 表示这条命令已经入队</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span>		<span class="comment"># 执行事务，依次列出每条命令的执行结果</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) <span class="string">"v2"</span></span><br><span class="line">4) OK</span><br></pre></td></tr></table></figure>



<blockquote>
<p>取消事务：<code>discard</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi			<span class="comment"># 开启事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k4 v4</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; get k4</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; DISCARD		<span class="comment"># 取消事务，已经入队的命令都不会执行</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get k4			</span><br><span class="line">(nil)							<span class="comment"># 无法获取k4的值，说明上面入队的命令没有执行</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>Redis 事务中有命令出现问题，其他命令的执行分两种情况：</p>
<ol>
<li><p>有命令错误（编译时异常）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2				<span class="comment"># 命令写错，入队时就提示错误信息</span></span><br><span class="line">(error) ERR wrong number of arguments <span class="keyword">for</span> <span class="string">'set'</span> <span class="built_in">command</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; get k1				<span class="comment"># 后续的命令任然能够正常入队</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span>				<span class="comment"># 但是事务无法执行，事务中的所有命令也都不会执行</span></span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>命令没错，但执行时出错（运行时异常）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; incr k1			<span class="comment"># k1的值为String，无法使用incr，所以这条命令运行时会报错</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span>			<span class="comment"># 执行事务，只有第三条命令报错，但没有影响其他命令的执行</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) (error) ERR value is not an <span class="built_in">integer</span> or out of range</span><br><span class="line">4) <span class="string">"v2"</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<p><strong>Redis 中实现乐观锁：</strong></p>
<blockquote>
<p>悲观锁和乐观锁：</p>
<ul>
<li><p>悲观锁：很悲观，认为任何时候都会出问题，所以把所有操作都加锁</p>
</li>
<li><p>乐观锁：很乐观，认为什么时候都不会出问题，所以不会上锁。</p>
<p>会获取一个 Version，在更新数据的时候比较 Version。</p>
</li>
</ul>
</blockquote>
<p>在 Redis 中使用 <code>Watch</code> 可以实现乐观锁</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> mymoney 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> yourmoney 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch mymoney		<span class="comment"># 开启监控（可以一次监控多个）</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; decrby mymoney 20</span><br><span class="line">QUEUED												<span class="comment"># 在开启监控之后，事务执行之前，mymoney的值被另一个用户修改成200</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; incrby yourmoney 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span>			<span class="comment"># 执行事务时会对比监控的值，如果值没变化，事务执行成功。如果值变化了，事务就会执行失败</span></span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; unwatch				<span class="comment"># 事务执行失败后，需要先解除监控</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch mymoney		<span class="comment"># 重新监控</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; decrby mymoney 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; incrby yourmoney 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 180</span><br><span class="line">2) (<span class="built_in">integer</span>) 120</span><br></pre></td></tr></table></figure>





<h2 id="Java-操作-Redis"><a href="#Java-操作-Redis" class="headerlink" title="Java 操作 Redis"></a>Java 操作 Redis</h2><blockquote>
<p>Java 使用 <code>Jedis</code> 来操作 Redis</p>
</blockquote>
<p>导入 Jedis 的 jar 包：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>Jedis 的基本使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickGetStart</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建连接</span></span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 执行命令</span></span><br><span class="line">    jedis.set(<span class="string">"username"</span>, <span class="string">"zhangsan"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 关闭连接</span></span><br><span class="line">    jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Jedis 中执行命令的方法名称就是 Redis 的命令名称</p>
</blockquote>
<p><strong>Jedis 连接池</strong></p>
<blockquote>
<p>Jedis 自带连接池 <code>JedisPool</code></p>
</blockquote>
<p>创建连接池并从连接池中获取连接:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建连接池(调用空参构造)</span></span><br><span class="line">    JedisPool jedisPool = <span class="keyword">new</span> JedisPool(<span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    Jedis jedis = JedisPool.getResource();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 jedis</span></span><br><span class="line">    jedis.set(<span class="string">"hello"</span>, <span class="string">"你好"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 归还连接</span></span><br><span class="line">    jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以创建 JedisPoolConfig 对象对 JedisPool 进行配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建配置对象, 配置连接池</span></span><br><span class="line">    JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">    config.setMaxTotal(<span class="number">50</span>);  <span class="comment">// 配置最大连接数</span></span><br><span class="line">    <span class="comment">// 还有很多配置......</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建连接池对象(有参构造)</span></span><br><span class="line">    JedisPool jedisPool = <span class="keyword">new</span> JedisPool(config, <span class="string">"localhost"</span>, <span class="number">6379</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取连接, 使用连接, 归还连接 均同上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="Spring-Boot-集成-Redis"><a href="#Spring-Boot-集成-Redis" class="headerlink" title="Spring Boot 集成 Redis"></a>Spring Boot 集成 Redis</h2><h2 id="Redis-的持久化"><a href="#Redis-的持久化" class="headerlink" title="Redis 的持久化"></a>Redis 的持久化</h2><blockquote>
<p>Redis 有两种持久化模式：RDB 和 AOF</p>
</blockquote>
<h3 id="RDB-Redis-DataBase-–-默认"><a href="#RDB-Redis-DataBase-–-默认" class="headerlink" title="RDB(Redis DataBase) – 默认"></a>RDB(Redis DataBase) – 默认</h3><p>在一定间隔时间内，检测 key 的变化情况，然后持久化数据。默认具体规则如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Unless specified otherwise, by default Redis will save the DB:</span></span><br><span class="line"><span class="comment">#   * After 3600 seconds (an hour) if at least 1 key changed</span></span><br><span class="line"><span class="comment">#   * After 300 seconds (5 minutes) if at least 100 keys changed</span></span><br><span class="line"><span class="comment">#   * After 60 seconds if at least 10000 keys changed</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># save 3600 1</span></span><br><span class="line"><span class="comment"># save 300 100</span></span><br><span class="line"><span class="comment"># save 60 10000</span></span><br><span class="line"></span><br><span class="line">save 30 500			<span class="comment"># 如果自己写了save，默认配置就失效了（但是一般情况都是使用默认规则）</span></span><br></pre></td></tr></table></figure>



<p><strong>RDB 优点：</strong></p>
<ul>
<li>RDB 会单独 fork 一个子进程进行持久化，会先把数据写到一个临时文件中，写好之后再用临时文件替换上次持久化的文件。整个过程中主进程不进行任何的 IO 操作，这样就保证了极高的性能。</li>
</ul>
<p><strong>RDB 缺点：</strong></p>
<ul>
<li><p>最后一次持久化后的数据可能在宕机的情况下丢失。</p>
</li>
<li><p>fork 一个子进程会占用一定的内存。</p>
</li>
</ul>
<p><strong>RDB 文件：</strong></p>
<ul>
<li>文件名：<code>dump.rdb</code></li>
<li>文件位置：<code>redis-server</code> 文件所在目录（又叫 Redis 的启动目录）</li>
<li>从 RDB 恢复数据：Redis 启动的时候会自动加载 <code>dump.rdb</code> 文件并恢复其中的数据</li>
</ul>
<p><strong>什么情况下会激活 RDB 持久化？</strong></p>
<ol>
<li>Redis 的操作满足了 save 中定义的规则</li>
<li>执行 <code>flushall</code> 命令</li>
<li>正常关闭 Redis 服务</li>
</ol>
<p><strong>什么情况适合使用 RDB？</strong></p>
<ul>
<li>数据量较大</li>
<li>对数据的完整性要求不高</li>
</ul>
<h3 id="AOF-Append-Only-File"><a href="#AOF-Append-Only-File" class="headerlink" title="AOF (Append Only File)"></a>AOF (Append Only File)</h3><p>日志记录方式，把 Redis 所有的<strong>写指令</strong>记录到文件中，重启服务器时重新运行所有的写指令，以达到恢复数据的目的</p>
<p><strong>开启 AOF：</strong></p>
<ol>
<li>在 <code>redis.conf</code> 中配置： <code>appendonly yes</code> （默认是 <code>no</code>）</li>
<li>重启 Redis 服务，AOF 才会生效。</li>
</ol>
<p><strong>AOF 有 3 种模式：</strong>(只能选择一种使用，默认使用 <code>appendfsync everysec</code>)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># appendfsync always			# 每次有写指令就持久化</span></span><br><span class="line">appendfsync everysec			<span class="comment"># 每秒持久化，最多丢失一秒的数据</span></span><br><span class="line"><span class="comment"># appendfsync no				# 系统高兴的时候持久化</span></span><br></pre></td></tr></table></figure>



<p><strong>AOF 文件：</strong></p>
<ul>
<li><p>文件名称：<code>appendonly.aof</code></p>
</li>
<li><p>文件内容出现问题，会导致 Redis 启动失败，可以使用 Redis 提供的工具修复文件 <code>redis-check-aof --fix</code>，修复是把有问题的内容删除。</p>
</li>
</ul>
<p><strong>AOF 优点：</strong></p>
<ul>
<li>默认每秒同步一次，数据的完整性更好，最多丢失 1 秒的数据</li>
</ul>
<p><strong>AOF 缺点：</strong></p>
<ul>
<li>频繁的 IO 操作，性能较低</li>
<li>数据量大时，AOF 产生的持久化文件较大，恢复数据比较耗时</li>
</ul>
<h2 id="Redis-发布订阅"><a href="#Redis-发布订阅" class="headerlink" title="Redis 发布订阅"></a>Redis 发布订阅</h2><p>我们使用的微博，微信公众号，群聊，其实都存在发布订阅模式。即发布者发布信息到队列中，订阅者可以从队列中获取信息。</p>
<p><img src="/images/Redis/image-20210420223744148.png" alt="image-20210420223744148"></p>
<p>Redis 中可以实现上述流程：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">subscribe channel			<span class="comment"># 订阅频道（channel）</span></span><br><span class="line"></span><br><span class="line">unsubscribe channel			<span class="comment"># 取消订阅频道</span></span><br><span class="line"></span><br><span class="line">publish channel <span class="string">"message"</span>	<span class="comment"># 向频道发布内容</span></span><br></pre></td></tr></table></figure>



<p>实例演示</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 订阅者</span></span><br><span class="line">127.0.0.1:6379&gt; SUBSCRIBE chaping				<span class="comment"># 1.订阅 chaping</span></span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">"subscribe"</span></span><br><span class="line">2) <span class="string">"chaping"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1									<span class="comment"># 2.订阅了之后就会在这里等待接收消息</span></span><br><span class="line"></span><br><span class="line">1) <span class="string">"message"</span>									<span class="comment"># 4.订阅者收到信息</span></span><br><span class="line">2) <span class="string">"chaping"</span></span><br><span class="line">3) <span class="string">"hello world"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发布者</span></span><br><span class="line">127.0.0.1:6379&gt; PUBLISH chaping <span class="string">"hello world"</span>	<span class="comment"># 3.发布者往 chaping 上面发布了一条消息</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure>



<p><strong>Redis 发布订阅原理：</strong></p>
<p>Redis 中会维护一个字典，字典中键是频道，值是一个链表，链表中存放了所有的订阅者（<code>subscribe</code> 命令就是将订阅者添加到相应频道的链表中）。</p>
<p>发布者发布消息的时候，Redis 会以频道为键，去字典中查询出对应链表，然后遍历链表，把消息发送给所有订阅者。</p>
<p><strong>使用场景：</strong>实时消息系统，实时聊天系统，关注/订阅系统等</p>
<blockquote>
<p>简单的发布订阅可以使用 Redis 实现，如果比较复杂，可以使用<strong>消息队列</strong>实现</p>
</blockquote>
<h2 id="Redis-主从复制"><a href="#Redis-主从复制" class="headerlink" title="Redis 主从复制"></a>Redis 主从复制</h2><p><strong>概念：</strong>将一台 Redis 服务器的数据复制到其他的 Redis 服务器。前者称为主节点（Master），后者称为从节点（Slave）。</p>
<p><img src="/images/Redis/image-20210421110246270.png" alt="image-20210421110246270"></p>
<blockquote>
<p>Redis 主从复制的特点：</p>
<ul>
<li><p>每个 Redis 服务器默认都是主节点</p>
</li>
<li><p>数据只能从主节点到从节点</p>
</li>
<li><p>一个主节点可以有多个从节点，但一个从节点只能有一个主节点</p>
</li>
</ul>
<p>Redis 主从复制的作用：</p>
<ul>
<li>数据备份：主从复制是除了持久化之外另一种数据备份的方式</li>
<li>故障恢复：当主节点发生故障时，可以由从节点提供服务，实现快速的故障恢复</li>
<li>负载均衡：主节点只提供写操作，从节点只提供读操作，实现读写分离。在写少读多的业务场景下，通过配置多个从节点分担服务器的压力，可以大大提高 Redis 的并发量</li>
<li>高可用：通过主从复制实现集群和哨兵模式，可以大大提高 Redis 的可用性</li>
</ul>
</blockquote>
<h3 id="搭建-Redis-集群"><a href="#搭建-Redis-集群" class="headerlink" title="搭建 Redis 集群"></a>搭建 Redis 集群</h3><blockquote>
<p>因为没有多台服务器，这里搭建单机多服务模式。</p>
</blockquote>
<p>步骤：</p>
<ol>
<li><p>复制多个配置文件，每个服务使用一个配置文件</p>
<p><img src="/images/Redis/image-20210421103749221.png" alt="image-20210421103749221"></p>
</li>
</ol>
<ol start="2">
<li><p>修改每个配置文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">port 6380							<span class="comment"># 修改端口号</span></span><br><span class="line"></span><br><span class="line">pidfile /var/run/redis_6380.pid		<span class="comment"># </span></span><br><span class="line"></span><br><span class="line">logfile <span class="string">"redis-6380.log"</span>			<span class="comment"># 修改日志文件名称</span></span><br><span class="line"></span><br><span class="line">dbfilename dump-6380.rdb			<span class="comment"># 修改 RDB 文件名称</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>使用不同的配置文件启动多个服务</p>
<p><img src="/images/Redis/image-20210421103908185.png" alt="image-20210421103908185"></p>
<p><img src="/images/Redis/image-20210421104001570.png" alt="image-20210421104001570"></p>
<p><img src="/images/Redis/image-20210421104040770.png" alt="image-20210421104040770"></p>
</li>
</ol>
<ol start="4">
<li><p>检查服务启动情况</p>
<p><img src="/images/Redis/image-20210421104209874.png" alt="image-20210421104209874"></p>
</li>
</ol>
<h3 id="普通主从复制"><a href="#普通主从复制" class="headerlink" title="普通主从复制"></a>普通主从复制</h3><blockquote>
<p>选定 6379 为主节点，6380 和 6381 为从节点</p>
</blockquote>
<p>两种方式配置主从关系</p>
<ol>
<li><p>通过命令（临时）：</p>
<p>因为每个 Redis 服务默认就是主节点，所以不用配置，只配置从节点就可以</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################# 6379服务默认的主从复制信息 #################</span></span><br><span class="line">127.0.0.1:6379&gt; info replication					<span class="comment"># 查看主从复制信息</span></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master											<span class="comment"># 显示当前服务器角色</span></span><br><span class="line">connected_slaves:0									<span class="comment"># 从机数量</span></span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:6b2779e2af148b3bfa9defc3b3bd7485dade7f21</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure>



</li>
</ol>
   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################# 6380指定主节点（6381操作一样） #################</span></span><br><span class="line">127.0.0.1:6380&gt; SLAVEOF 127.0.0.1 6379		<span class="comment"># 指定主节点</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6380&gt; info replication			<span class="comment"># 指定主节点后，6380就变成了从节点</span></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1						<span class="comment"># 显示主节点的相关信息</span></span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:8</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:0</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:8fb95e2aca5e3c4e69caf54026a4a1fdc03cf752</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure>



   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################# 6379现在的主从复制信息 #################</span></span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2												<span class="comment"># 从节点的详细信息</span></span><br><span class="line">slave0:ip=127.0.0.1,port=6380,state=online,offset=784,lag=0</span><br><span class="line">slave1:ip=127.0.0.1,port=6381,state=online,offset=784,lag=0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:8fb95e2aca5e3c4e69caf54026a4a1fdc03cf752</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:784</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:784</span><br></pre></td></tr></table></figure>





<ol start="2">
<li><p>通过配置文件（持久）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################# 在 Redis 配置文件设置 #################</span></span><br><span class="line">replicaof &lt;masterip&gt; &lt;masterport&gt;		<span class="comment"># 配置主机的 ip 和 port</span></span><br><span class="line"></span><br><span class="line">masterauth &lt;master-password&gt;			<span class="comment"># 如果主机有密码，则配置密码</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>命令配置和配置文件配置的对比：</p>
<ul>
<li>命令配置是临时生效的，如果 Redis 服务重启，那么主从关系就会丢失</li>
<li>配置文件配置是持久生效的，重启服务后，会根据配置文件中的信息自动建立主从关系</li>
</ul>
<blockquote>
<p>主从复制中：主机可以写，从机只能读，不能写</p>
<p>尝试在从机写时，会报错：</p>
<p><img src="/images/Redis/image-20210421122559174.png" alt="image-20210421122559174"></p>
</blockquote>
<blockquote>
<p>主从复制的复制原理：</p>
<p>Slave 成功指定主机之后，会发送一个 Sync 命令给 Master</p>
<p>Master 接收到 Sync 命令后，会把自己的所有数据通过文件发送给 Slave，完成一次全量同步</p>
</blockquote>
<blockquote>
<p>Master 中的内容一定会在 Slave 中</p>
</blockquote>
<p><strong>主从复制的另一种形式：</strong></p>
<p>除了上面的一个 Master 有多个 Slave 的形式，还可以有一种层层链路的形式：</p>
<p><code>Master --&gt; Slave1 --&gt; Slave2</code></p>
<blockquote>
<p>如果 Master 宕机，我们可以手动的修改配置，让一个 Slave 变成新的 Master，另外的 Slave 从属于新的 Master。</p>
<p>上面的两种主从复制的形式我们实际工作中都不会去使用，因为如果主机出现故障，需要手动修改配置实现故障恢复，费时费力，对业务不友好。</p>
<p>实际工作中会使用哨兵模式（主从复制高级版）</p>
</blockquote>
<h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>概念：设置一个哨兵，哨兵会持续监控 Redis 服务器，如果监控到 Master 出现故障，哨兵会自动将某一个 Slave 变为 Master，然后通知其他的 Slave 切换 Master。</p>
<p><img src="/images/Redis/image-20210421120043623.png" alt="image-20210421120043623"></p>
<p>单哨兵模式可能会出现问题（比如哨兵自己的进程崩了），所以实际业务中使用多哨兵模式，就是设置多个哨兵监控 Redis 服务，多个哨兵之间相互监控。</p>
<p><img src="/images/Redis/image-20210421122912946.png" alt="image-20210421122912946"></p>
<p><strong>如何实现哨兵模式：</strong></p>
<ol>
<li><p>配置哨兵的配置文件 <code>sentinel.conf</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是哨兵的配置文件中最核心的配置，还可以写很多其他的配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel monitor 自定义名称 host port 1</span></span><br><span class="line"><span class="comment"># 最后的数字 1 表示哨兵会在 Master 宕机的情况下自动选取一个新的 Master</span></span><br><span class="line">sentinel monitor myredis 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动哨兵：<code>redis-sentinel 哨兵配置文件</code></p>
<p><img src="/images/Redis/image-20210421121335359.png" alt="image-20210421121335359"></p>
</li>
</ol>
<blockquote>
<p>如果 Master 宕机后又恢复了，恢复后就会变成 Slave，归从在新的 Master 之下。</p>
</blockquote>
<p><strong>哨兵模式优缺点：</strong></p>
<p>优点：</p>
<ul>
<li><p>基于主从复制，具有主从复制的所有优点</p>
</li>
<li><p>可以自动转移故障，使系统可用性更高。</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>Redis 在线扩容不方便，如果集群容量达到上限，在线扩容非常麻烦</li>
<li>哨兵模式配置麻烦</li>
</ul>
<p>哨兵模式的所有配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example sentinel.conf</span></span><br><span class="line"><span class="comment"># 哨兵sentinel实例运行的端口 默认26379</span></span><br><span class="line">port 26379</span><br><span class="line"></span><br><span class="line"><span class="comment"># 哨兵sentinel的工作目录</span></span><br><span class="line">dir /tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 哨兵sentinel监控的redis主节点的 ip port</span></span><br><span class="line"><span class="comment"># master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符".-_"组成。</span></span><br><span class="line"><span class="comment"># quorum 配置多少个sentinel哨兵统一认为master主节点失联 那么这时客观上认为主节点失联了</span></span><br><span class="line"><span class="comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span></span><br><span class="line"><span class="comment"># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span></span><br><span class="line"><span class="comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class="line">sentinel auth-pass mymaster MySUPER--secret-0123passw0rd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span></span><br><span class="line"><span class="comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，</span></span><br><span class="line">这个数字越小，完成failover所需的时间就越长，</span><br><span class="line">但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。</span><br><span class="line">可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span><br><span class="line"><span class="comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面：</span></span><br><span class="line"><span class="comment">#1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span></span><br><span class="line"><span class="comment">#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span></span><br><span class="line"><span class="comment">#3.当想要取消一个正在进行的failover所需要的时间。</span></span><br><span class="line"><span class="comment">#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span></span><br><span class="line"><span class="comment"># 默认三分钟</span></span><br><span class="line"><span class="comment"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"></span><br><span class="line"><span class="comment"># SCRIPTS EXECUTION</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span></span><br><span class="line"><span class="comment">#对于脚本的运行结果有以下规则：</span></span><br><span class="line"><span class="comment">#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span></span><br><span class="line"><span class="comment">#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span></span><br><span class="line"><span class="comment">#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span></span><br><span class="line"><span class="comment">#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span></span><br><span class="line"><span class="comment">#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span></span><br><span class="line"><span class="comment">#通知脚本</span></span><br><span class="line"><span class="comment"># shell编程</span></span><br><span class="line"><span class="comment"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">sentinel notification-script mymaster /var/redis/notify.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端重新配置主节点参数脚本</span></span><br><span class="line"><span class="comment"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span></span><br><span class="line"><span class="comment"># 以下参数将会在调用脚本时传给脚本:</span></span><br><span class="line"><span class="comment"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span></span><br><span class="line"><span class="comment"># 目前&lt;state&gt;总是“failover”,</span></span><br><span class="line"><span class="comment"># &lt;role&gt;是“leader”或者“observer”中的一个。</span></span><br><span class="line"><span class="comment"># 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通</span></span><br><span class="line">信的</span><br><span class="line"><span class="comment"># 这个脚本应该是通用的，能被多次调用，不是针对性的。</span></span><br><span class="line"><span class="comment"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">sentinel client-reconfig-script mymaster /var/redis/reconfig.sh <span class="comment"># 一般都是由运维来配置！</span></span><br></pre></td></tr></table></figure>





<h2 id="Redis-缓存穿透和雪崩"><a href="#Redis-缓存穿透和雪崩" class="headerlink" title="Redis 缓存穿透和雪崩"></a>Redis 缓存穿透和雪崩</h2>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Redis/" rel="tag"># Redis</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/05/26/Java/2.JavaWeb/11.JSP/" rel="prev" title="JSP">
      <i class="fa fa-chevron-left"></i> JSP
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/05/26/Java/2.JavaWeb/12.EL%20&%20JSTL/" rel="next" title="EL & JSTL">
      EL & JSTL <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-简介"><span class="nav-number">1.</span> <span class="nav-text">Redis 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-安装"><span class="nav-number">2.</span> <span class="nav-text">Redis 安装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-基本知识"><span class="nav-number">3.</span> <span class="nav-text">Redis 基本知识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-五大数据类型"><span class="nav-number">4.</span> <span class="nav-text">Redis 五大数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#String-类型"><span class="nav-number">4.1.</span> <span class="nav-text">String 类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List-类型"><span class="nav-number">4.2.</span> <span class="nav-text">List 类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set-类型"><span class="nav-number">4.3.</span> <span class="nav-text">Set 类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hash-类型"><span class="nav-number">4.4.</span> <span class="nav-text">Hash 类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Zset（有序集合）-类型"><span class="nav-number">4.5.</span> <span class="nav-text">Zset（有序集合） 类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-三种特殊的数据类型"><span class="nav-number">5.</span> <span class="nav-text">Redis 三种特殊的数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Geospatial-地理位置"><span class="nav-number">5.1.</span> <span class="nav-text">Geospatial 地理位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hyperloglog"><span class="nav-number">5.2.</span> <span class="nav-text">Hyperloglog</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bitmap-位图"><span class="nav-number">5.3.</span> <span class="nav-text">Bitmap 位图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-事务"><span class="nav-number">6.</span> <span class="nav-text">Redis 事务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-操作-Redis"><span class="nav-number">7.</span> <span class="nav-text">Java 操作 Redis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-Boot-集成-Redis"><span class="nav-number">8.</span> <span class="nav-text">Spring Boot 集成 Redis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-的持久化"><span class="nav-number">9.</span> <span class="nav-text">Redis 的持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB-Redis-DataBase-–-默认"><span class="nav-number">9.1.</span> <span class="nav-text">RDB(Redis DataBase) – 默认</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF-Append-Only-File"><span class="nav-number">9.2.</span> <span class="nav-text">AOF (Append Only File)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-发布订阅"><span class="nav-number">10.</span> <span class="nav-text">Redis 发布订阅</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-主从复制"><span class="nav-number">11.</span> <span class="nav-text">Redis 主从复制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#搭建-Redis-集群"><span class="nav-number">11.1.</span> <span class="nav-text">搭建 Redis 集群</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#普通主从复制"><span class="nav-number">11.2.</span> <span class="nav-text">普通主从复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#哨兵模式"><span class="nav-number">11.3.</span> <span class="nav-text">哨兵模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-缓存穿透和雪崩"><span class="nav-number">12.</span> <span class="nav-text">Redis 缓存穿透和雪崩</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">pikachu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">85</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">104</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">pikachu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>
        








        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>














  

  

</body>
</html>
