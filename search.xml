<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Autowored注解和Resource注解的区别</title>
    <url>/2021/06/15/Java/Autowired%E6%B3%A8%E8%A7%A3%E5%92%8CResource%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>两个注解都可以自动注入bean，他们俩有啥不一样呢？</p>
<a id="more"></a>

<blockquote>
<p>TODO</p>
</blockquote>
<p>@Autowired</p>
<p>@Resource</p>
]]></content>
      <categories>
        <category>Java EE</category>
      </categories>
      <tags>
        <tag>Autowired</tag>
        <tag>Resource</tag>
      </tags>
  </entry>
  <entry>
    <title>Repository注解和Mapper注解的区别</title>
    <url>/2021/06/15/Java/Repository%E6%B3%A8%E8%A7%A3%E5%92%8CMapper%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>你知道这两个注解有什么不一样吗</p>
<a id="more"></a>



<p><strong>开发过程中遇到了一个问题：</strong></p>
<p>在 service 中注入 mapper 的时候，发生了爆红的情况：（此时 userMapper 接口上使用的是 <code>@Mapper</code> 注解）</p>
<p><img src="/images/@Repository%E5%92%8C@Mapper%E7%9A%84%E5%8C%BA%E5%88%AB/image-20210615100455667.png" alt="image-20210615100455667"></p>
<p>但是项目的运行没有任何问题。</p>
<p><strong>于是去 Google 了一下，找到了一个解决办法：</strong></p>
<blockquote>
<p>把 UserMapper 接口的 <code>@Mapper</code> 注解换成 <code>@Repository</code> （我使用 <code>@Mapper</code> 时就在 Spring Boot 的主启动类上面添加了 <code>@MapperScan</code> 注解）</p>
</blockquote>
<p><strong>解决了之后我就想：</strong><code>@Mapper</code> 注解和 <code>@Repository</code> 注解究竟有什么不一样呢，为什么会出现这种差别呢？</p>
<p>查阅相关资料发现两者不同点在于：</p>
<ul>
<li><code>@Repository</code>：Spring 的注解，表示这个接口是一个 Mapper，需要配合 <code>@MapperScan</code> 注解使用。</li>
<li><code>@Mapper</code>：Mybatis 的注解，相当于 <code>@Repository</code> + <code>@MapperScan</code></li>
</ul>
<p>那为什么使用 @Repository 就不会爆红呢？</p>
<blockquote>
<p>因为 <code>@Autowired</code> 同样是 Spring 的注解，使用同为 Spring 注解的 <code>@Repository</code> 时，就可以检测到 userMapper 接口。</p>
</blockquote>
<hr>
<p>在查资料的过程中，发现还有一个办法可以解决使用 <code>@Mapper</code> 注解时的爆红问题：</p>
<blockquote>
<p>把 <code>@Autowired</code> 注解换成 <code>@Resource</code> 注解</p>
<p>换了注解后，没有了爆红，项目也可以正常运行</p>
<p>因为 <code>@Autowired</code> 注解默认情况下需要注入的属性不为 null（属性 <code>required = true</code>），而 <code>@Resource</code> 注解注入的属性可以为 null</p>
<p>关于 <code>@Autowired</code> 和 <code>@Resource</code> 的区别，可以看我的这篇文章：<a href="/2021/06/15/Java/Autowired注解和Resource注解的区别">@Autowired和@Resource的区别</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java EE</category>
      </categories>
      <tags>
        <tag>Repository</tag>
        <tag>Mapper</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper</title>
    <url>/2021/05/11/Java/%E5%BE%AE%E6%9C%8D%E5%8A%A1/ZooKeeper/</url>
    <content><![CDATA[<p>ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。</p>
<a id="more"></a>



<h2 id="ZooKeeper基础概念"><a href="#ZooKeeper基础概念" class="headerlink" title="ZooKeeper基础概念"></a>ZooKeeper基础概念</h2><h2 id="ZooKeeper-环境搭建"><a href="#ZooKeeper-环境搭建" class="headerlink" title="ZooKeeper 环境搭建"></a>ZooKeeper 环境搭建</h2><blockquote>
<p>在 Linux 中搭建 ZooKeeper （伪集群）环境</p>
<p>参考资料：</p>
<ul>
<li><a href="https://www.cnblogs.com/qlqwjy/p/10491456.html" target="_blank" rel="noopener">Zookeeper环境搭建</a></li>
<li><a href="https://blog.csdn.net/qq_28410283/article/details/108863650" target="_blank" rel="noopener">在linux下搭建zookeeper集群</a></li>
<li><a href="https://blog.csdn.net/weixin_42417207/article/details/89280006?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.vipsorttest&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.vipsorttest" target="_blank" rel="noopener">阿里云上zookeeper伪集群部署</a></li>
</ul>
</blockquote>
<ol>
<li><p>在<a href="https://zookeeper.apache.org/releases.html" target="_blank" rel="noopener">官网下载</a> tar.gz 压缩包（<code>apache-zookeeper-3.7.0-bin.tar.gz</code>）</p>
</li>
<li><p>把压缩包放到 <code>/opt</code> 目录下，解压（<code>tar -xzvf apache-zookeeper-3.7.0-bin.tar.gz</code>）</p>
</li>
<li><p>重命名解压后的目录（<code>mv apache-zookeeper-3.7.0-bin.tar.gz zookeeper</code>）</p>
</li>
<li><p>在 <code>/opt</code> 中新建 <code>zookeeper-cluster</code> 目录（<code>mkdir zookeeper-cluster</code>）</p>
</li>
<li><p>把 <code>zookeeper</code> 放到 <code>zookeeper-cluster</code> 目录下，并复制两份（<code>zookeeper1</code>，<code>zookeeper2</code>，<code>zookeeper3</code>）</p>
</li>
<li><p>把 <code>zookeeper1/conf/zoo_sample.cfg</code> 重命名为 <code>zoo.cfg</code></p>
</li>
<li><p>修改 <code>zoo.cfg</code> </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The number of milliseconds of each tick</span></span><br><span class="line">tickTime=2000</span><br><span class="line"><span class="comment"># The number of ticks that the initial </span></span><br><span class="line"><span class="comment"># synchronization phase can take</span></span><br><span class="line">initLimit=10</span><br><span class="line"><span class="comment"># The number of ticks that can pass between </span></span><br><span class="line"><span class="comment"># sending a request and getting an acknowledgement</span></span><br><span class="line">syncLimit=5</span><br><span class="line"><span class="comment"># the directory where the snapshot is stored.</span></span><br><span class="line"><span class="comment"># do not use /tmp for storage, /tmp here is just </span></span><br><span class="line"><span class="comment"># example sakes.</span></span><br><span class="line">dataDir=/opt/zookeeper-cluster/zookeeper1/zkData		<span class="comment"># 需要修改为自己创建的 zkData 目录</span></span><br><span class="line"><span class="comment"># the port at which the clients will connect</span></span><br><span class="line">clientPort=2181											<span class="comment"># 修改为该 zk server 的端口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 集群相关配置，三个 server 中写一样</span></span><br><span class="line"><span class="comment"># 格式：server.id=ip:port1:port2</span></span><br><span class="line"><span class="comment"># id：myid文件中写的id信息</span></span><br><span class="line"><span class="comment"># ip：服务器的ip（如果是伪集群，则写127.0.0.1）</span></span><br><span class="line"><span class="comment"># port1：该服务器与集群中leader服务器交换信息的端口</span></span><br><span class="line"><span class="comment"># port2：服务器执行选举时需要用到的端口</span></span><br><span class="line">server.1=127.0.0.1:2887:3887</span><br><span class="line">server.2=127.0.0.1:2888:3888</span><br><span class="line">server.3=127.0.0.1:2889:3889</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>zookeeper1</code> 目录下新建 <code>zkData</code> 目录（<code>zoo.cfg</code> 中的 <code>dataDir</code>）</p>
</li>
<li><p>在 <code>zkData</code> 目录下新建 <code>myid</code> 文本文件，并在文件中写入该 server 的 id 信息（<code>zoo.cfg</code> 中集群配置的 <code>server.</code> 后面那个数字）</p>
</li>
<li><p>在 <code>zookeeper2</code>，<code>zookeeper3</code> 中执行 6,7,8,9 步骤，把相关信息指定为自己的（<code>dataDir</code>，<code>clientPort</code>，<code>myid</code>）</p>
</li>
<li><p>分别启动三个服务器 <code>zookeeper-cluster/zookeeper1/bin/zkServer.sh start</code></p>
</li>
<li><p>检查是否启动成功 <code>zookeeper-cluster/zookeeper1/bin/zkserver.sh status</code>（三个服务器，一主两从）</p>
<p><strong>zookeeper1 server</strong></p>
<p><img src="../../../images/ZooKeeper/image-20210511174137605.png" alt="image-20210511174137605"></p>
</li>
</ol>
<pre><code>**zookeeper2 server**

![image-20210511174250887](../../../images/ZooKeeper/image-20210511174250887.png)



**zookeeper3 server**

![image-20210511174338295](../../../images/ZooKeeper/image-20210511174338295.png)</code></pre><ol start="13">
<li><p>在 Linux 防火墙中开启相关端口：<code>2181</code>，<code>2182</code>，<code>2183</code> （如果在阿里云的服务器中搭建，还需要在安全组中配置这三个端口）</p>
<p>可以使用 <code>netstat -nltp</code> 命令查看是否监听了相关端口（<code>2181</code>，<code>3887</code> 等）</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java EE</category>
      </categories>
      <tags>
        <tag>ZooKeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL高级</title>
    <url>/2021/04/13/Java/MySQL%E9%AB%98%E7%BA%A7/</url>
    <content><![CDATA[<p>索引 、数据库优化、MySQL 锁机制</p>
<a id="more"></a>



<h2 id="MySQL-存储引擎"><a href="#MySQL-存储引擎" class="headerlink" title="MySQL 存储引擎"></a>MySQL 存储引擎</h2><p>MySQL 的存储引擎是可插拔的，有很多引擎可供使用，常见的有两个：</p>
<ul>
<li>MyISAM：MySQL 5.5之前的默认存储引擎</li>
<li>InnoDB：MySQL 5.5及之后默认存储引擎</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">MyISAM</th>
<th align="center">InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td align="center">外键</td>
<td align="center">不支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">事务</td>
<td align="center">不支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">行表锁</td>
<td align="center">表锁</td>
<td align="center">行锁</td>
</tr>
<tr>
<td align="center">缓存</td>
<td align="center">只缓存索引，不缓存真实数据</td>
<td align="center">既缓存索引，又缓存真实数据，内存要求较高</td>
</tr>
<tr>
<td align="center">表空间</td>
<td align="center">小</td>
<td align="center">大</td>
</tr>
<tr>
<td align="center">关注点</td>
<td align="center">性能</td>
<td align="center">事务</td>
</tr>
<tr>
<td align="center">默认安装</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
</tbody></table>
<p>SQL 性能下降的原因：</p>
<ul>
<li>查询语句写的烂</li>
<li>索引失效</li>
<li>join 语句太多</li>
<li>数据库的配置问题</li>
</ul>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p><strong>什么是索引？</strong></p>
<p>MySQL 官方定义：索引是帮助 MySQL 高效获取数据的数据结构</p>
<p>一句话：<strong>索引是排好序的快速查找数据结构</strong></p>
<p>MySQL 数据库中的索引的底层结构为 <strong>B+ 树</strong>，可以帮助我们可以快速的查找数据库中的数据</p>
<p>一般来说索引本身也很大，通常存储在硬盘上。</p>
<p><strong>索引的优劣势：</strong></p>
<ul>
<li>优势：<ol>
<li>提高查询效率，降低 IO 开销</li>
<li>降低排序成本，降低 CPU 开销</li>
</ol>
</li>
<li>劣势：降低更新表的效率</li>
</ul>
<p><strong>索引的种类</strong></p>
<ul>
<li>单值索引：一个索引只包含单个列，一个表可以有多个单值索引</li>
<li>唯一索引：索引列的值必须唯一，但允许有空值</li>
<li>复合索引：一个索引包含多个列</li>
</ul>
<p><strong>MySQL有哪些索引：</strong></p>
<ul>
<li><p>主键索引（PRIMARY KEY）</p>
<p>一张表中只能有一个主键索引</p>
</li>
<li><p>唯一索引（UNIQUE KEY）</p>
<p>一张表中可以有多个唯一索引</p>
</li>
<li><p>常规索引（KEY）</p>
</li>
<li><p>全文索引（FULLTEXT）</p>
</li>
</ul>
<p><strong>索引相关语句：</strong></p>
<p>创建：</p>
<ul>
<li>创建表时创建索引：<code>CREATE INDEX indexName ON tableName(columnName)</code></li>
<li>创建表后增加索引：<code>ALTER table_name ADD INDEX/KEY index_name ON (column_name_list)</code></li>
</ul>
<p>查看：</p>
<ul>
<li><code>SHOW INDEX FROM table_name</code></li>
</ul>
<p>删除：</p>
<ul>
<li><code>DROP INDEX index_name ON table_name</code></li>
</ul>
<blockquote>
<p>InnoDB 引擎的索引分为两类：</p>
<ol>
<li>聚集索引（clustered index）：叶子节点存储<strong>行记录</strong></li>
<li>普通索引（secondary index）：叶子节点存储<strong>主键值</strong></li>
</ol>
<p>因为聚集索引中直接就有行记录，所以通过聚集索引查询很快。</p>
<p>而普通索引无法直接定位行记录，所以通常情况下使用普通索引查询需要扫描两遍索引树，如图：</p>
<p><img src="/images/MySQL%E9%AB%98%E7%BA%A7/%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B-1618329557573.jpg" alt="普通索引查询过程"></p>
<p>粉红色的路径：</p>
<ol>
<li>先通过普通索引定位到主键值</li>
<li>再通过聚集索引定位到行记录</li>
</ol>
<p>上面这个过程就是回表查询。</p>
</blockquote>
<p><strong>什么情况下建立索引：</strong></p>
<ol>
<li>主键自动建立唯一索引</li>
<li>频繁作为查询条件的字段应该创建索引</li>
<li>查询中与其他表关联的字段，外键关系建立索引</li>
</ol>
<p><strong>哪些情况不需要建立索引？</strong></p>
<ol>
<li>数据量比较小（百万级别以下）</li>
<li>频繁更新的表</li>
<li>某些列包含许多重复的内容（比如国籍列，性别列），建立索引也没啥效果</li>
</ol>
<h2 id="SQL-性能分析"><a href="#SQL-性能分析" class="headerlink" title="SQL 性能分析"></a>SQL 性能分析</h2><p>使用 explain 关键字对 SQL 语句进行性能分析</p>
<blockquote>
<p>explain 在 MySQL 5.5 中只能分析 select 语句</p>
<p>在 MySQL 5.6 之后可以分析 update、delete 等语句</p>
<p>但是用的最多的还是对 select 语句的分析</p>
</blockquote>
<p>使用 explain：</p>
<p><img src="/images/MySQL%E9%AB%98%E7%BA%A7/image-20210413122223656.png" alt="image-20210413122223656"></p>
<h4 id="expalin-结果字段："><a href="#expalin-结果字段：" class="headerlink" title="expalin 结果字段："></a>expalin 结果字段：</h4><ol>
<li><strong>id</strong>：标识多个表的执行顺序，有三种情况：<ul>
<li><strong>id 相同</strong>：相同 id 的表为一组，按照从上到下顺序执行</li>
<li><strong>id 不同</strong>：按照 id 从大到小的顺序执行，id 越大优先级越高</li>
<li><strong>id 有相同有不同</strong>：id 越大优先级越高，相同 id 按顺序执行</li>
</ul>
</li>
</ol>
<ol start="2">
<li><strong>select_type</strong>：查询操作类型，有下面几种：<ul>
<li>SIMPLE：简单查询，不含子查询和 union</li>
<li>PRIMARY：复杂查询中最外层查询</li>
<li>SUBQUERY：子查询语句</li>
<li>DERIVED：表示派生表（如果子查询的结果是一张表，这张表就是 derived）</li>
<li>UNION：标记 union 后面的 select，若 union 包含在 from 子句的子查询中，外层 select 将被标记为 derived </li>
<li>UNION RESULT：从 union 后的表中获取结果的 select</li>
</ul>
</li>
</ol>
<ol start="3">
<li><strong>table</strong>：查询的表</li>
</ol>
<ol start="4">
<li><p><strong>type</strong>：访问类型，有很多种，常用的有下面几种：</p>
<ul>
<li>system：表只有一行记录（等于系统表），是 const 类型的特例，一般情况下不会出现，可以忽略</li>
<li>const：表示通过索引一次就找到了，用于比较主键索引或唯一索引。因为只匹配一行数据，所以很快。如果将主键置于 where 列表中，MySQL 就能将该查询转换为一个常量。  <code>???</code></li>
<li>eq_ref：唯一索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描</li>
<li>ref：非唯一性索引扫描，返回匹配某个单独值的所有行</li>
<li>range：只检索给定范围的行，使用一个索引来选择行，key 列显示使用了哪个索引。一般就是在 where 子句中出现了 <code>between and</code>、<code>&gt;</code>、<code>&lt;</code>、<code>in</code></li>
<li>index：遍历索引树，查询数据</li>
<li>ALL：遍历表，查询数据</li>
</ul>
<blockquote>
<p>type 从最好到最坏：system &gt;  const &gt; eq_ref &gt; ref &gt; renge &gt; index &gt; ALL</p>
</blockquote>
</li>
</ol>
<ol start="5">
<li><strong>possible_keys</strong>：查询中可能会用到的索引（只是 MySQL 自己推测的，并不一定真的用到）</li>
</ol>
<ol start="6">
<li><strong>key</strong>：查询中实际用到的索引</li>
</ol>
<ol start="7">
<li><strong>key_len</strong>：表示索引中使用的字节数，不损失精度的情况下，字节数越小越好  <code>???</code></li>
</ol>
<ol start="8">
<li><strong>ref</strong>：显示索引的哪一列被使用了，如果可能的话，是一个常数，哪些列或常量被用于查找索引列上的值</li>
</ol>
<ol start="9">
<li><strong>rows</strong>：显示查询的行数</li>
</ol>
<ol start="10">
<li><p><strong>Extra</strong>：额外的信息</p>
<ul>
<li><strong>Using filesort</strong>：表示 MySQL 无法利用索引完成排序（<strong>bad</strong>）</li>
<li><strong>Using temporary</strong>：表示使用了中间表，会极大的影响速度，因为表的拷贝会消耗大量的时间（<strong>bad</strong>）</li>
<li><strong>Using index</strong>：表示使用了索引（<strong>good</strong>）</li>
<li>Using where</li>
<li>Using join buffer</li>
<li>impossible where</li>
<li>select tables optimized away</li>
<li>distinct</li>
</ul>
</li>
</ol>
<h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><p><strong>索引添加规则：</strong>在 where 子句后面出现的列上面加上索引（不一定全加），一般情况下添加复合索引</p>
<ul>
<li><p>单表：根据实际情况添加，从而达到最优</p>
</li>
<li><p>多表：在 join 的情况下，左连接，加右表；右连接，加左表。</p>
<blockquote>
<p>join 优化：</p>
<ol>
<li>永远是小表驱动大表</li>
<li>优先优化 NestedLoop 的内循环</li>
<li>保证 join 语句被驱动表的 join 条件字段已经被索引</li>
</ol>
</blockquote>
</li>
</ul>
<p><strong>索引失效的几种情况：</strong>（索引为什么会失效呢？？？）</p>
<ol>
<li>复合索引的最左列不在查询条件中</li>
<li>对索引列进行计算、使用函数、进行类型转换</li>
<li>范围条件后面索引会失效</li>
<li>like 子句中以通配符开头 <code>%om</code></li>
<li>使用 or 连接会导致索引失效</li>
</ol>
<p><strong>☆☆☆☆☆ 索引优化：</strong>（ 就是让索引不失效）</p>
<ol>
<li>全值匹配我最爱</li>
<li>最佳左前缀法则</li>
<li>不在索引列上做任何的计算，函数，（自动、手动）类型转换。（因为会导致索引失效）</li>
<li>范围条件后面的列索引失效 </li>
<li>尽量使用覆盖索引</li>
<li>like 子句尽量不使用通配符开头</li>
<li>字符串不加单引号会导致索引失效（因为这时候 MySQL 会自动进行类型转换）</li>
<li>尽量少用 or 连接</li>
</ol>
<blockquote>
<p>几个问题点：</p>
<ol>
<li>使用不等于（ <code>!=</code>， <code>&lt;&gt;</code>）时不一定会导致索引失效</li>
<li>使用 <code>is null</code>，<code>is not null</code> 也不一定会导致索引失效</li>
</ol>
</blockquote>
<p>order by 排序优化：尽量使用 Index 方式排序，避免使用 FileSort 方式排序。</p>
<p>order by 满足两种情况会使用 Index 排序：</p>
<ol>
<li>order by 子句条件满足索引最左前缀法则</li>
<li>where 子句和 order by 子句条件组合满足索引最左前缀法则</li>
</ol>
<h2 id="MySQL-锁"><a href="#MySQL-锁" class="headerlink" title="MySQL 锁"></a>MySQL 锁</h2><p>数据库的锁机制：为了共享资源在并发访问的时候能够保证数据的一致性。</p>
<h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><blockquote>
<p>MyISAM 存储引擎使用的是表锁（该表锁由 MySQL 提供）</p>
</blockquote>
<p>表锁有两种模式：</p>
<ul>
<li>读锁（共享锁）：不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求。</li>
<li>写锁（排他锁）：会阻塞其他用户对同一表的读请求和写请求。</li>
</ul>
<p>如何给表加锁：</p>
<ul>
<li><p>执行查询操作前，会自动给涉及的表加读锁。</p>
</li>
<li><p>执行更新操作前，会自动给涉及的表加写锁。</p>
</li>
</ul>
<p>表锁的特点：</p>
<ul>
<li>颗粒度最大</li>
<li>获取锁释放锁速度快</li>
<li>可以避免死锁问题</li>
<li>阻塞概率大，很难高并发</li>
</ul>
<h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><blockquote>
<p>InnoDB 存储引擎使用的是行锁（InnoDB 自己实现）</p>
<p>InnoDB 行锁实现方式：通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁。也就有了 <strong>索引失效导致行锁变表锁</strong>。（实际使用中一定要特别注意）</p>
</blockquote>
<p><strong>间隙锁</strong>：当我们用范围条件检索数据，并请求共享锁或排他锁时，InnoDB 会给符合条件的已有数据记录索引项加锁，对于键值符合条件但并不存在的记录（间隙），也会加锁，这种锁机制就是间隙锁</p>
<p>行锁的特点：</p>
<ul>
<li>颗粒度最小</li>
<li>可能出现死锁</li>
<li>容易实现高并发</li>
</ul>
<blockquote>
<p>为何 MyISAM 的表锁不会出现死锁，而 InnoDB 的行锁可能出现死锁？</p>
<p>MyISAM表锁是deadlock free的，这是因为MyISAM总是一次获得所需的全部锁，要么全部满足，要么等待，因此不会出现死锁。但在InnoDB中，除单个SQL组成的事务外，锁是逐步获得的，当两个事务都需要获得对方持有的排他锁才能继续完成事务，这种循环锁等待就是典型的死锁。</p>
</blockquote>
<p><strong>如何锁定一行</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;  <span class="comment">-- 先 begin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">3</span> <span class="keyword">for</span> <span class="keyword">update</span>;  <span class="comment">-- 使用 for update 锁定一行</span></span><br></pre></td></tr></table></figure>



<p><strong>分析行锁情况：</strong><code>show status like &#39;innodb_row_lock%&#39;;</code></p>
<ul>
<li>Innodb_row_lock_time_avg（等待平均时长）</li>
<li>Innodb_row_lock_waits（等待总次数）</li>
<li>Innodb_row_lock_time（等待总时长）</li>
</ul>
<p><strong>如何优化行锁：</strong></p>
<ul>
<li>让数据检索都通过索引来完成</li>
<li>合理设计索引，尽量缩小锁的范围</li>
<li>尽可能减少检索条件，避免间隙锁</li>
<li>尽量控制事务大小，减少锁定资源量和锁定时间</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 项目放到 Tomcat 运行</title>
    <url>/2021/04/05/Java/Spring%20Boot%E9%A1%B9%E7%9B%AE%E6%94%BE%E5%88%B0Tomcat/</url>
    <content><![CDATA[<p>手动把 Spring Boot 项目打包并放到 Tomcat 中运行，记录一下需要调整的地方。</p>
<a id="more"></a>

<h2 id="Spring-Boot-项目放到-Tomcat-运行"><a href="#Spring-Boot-项目放到-Tomcat-运行" class="headerlink" title="Spring Boot 项目放到 Tomcat 运行"></a>Spring Boot 项目放到 Tomcat 运行</h2><p>Spring Boot 项目直接打包放到 Tomcat中是不能运行的，需要对 Spring Boot 的项目做一些修改。</p>
<ol>
<li><p><strong>修改打包方式</strong></p>
<p>Spring Boot 的项目默认是打 jar 包，现在修改为打 war 包</p>
<p><img src="/images/Spring%20Boot%E9%A1%B9%E7%9B%AE%E6%94%BE%E5%88%B0Tomcat/%E6%89%93%E5%8C%85%E6%96%B9%E5%BC%8F.png" alt="打包方式"></p>
</li>
<li><p><strong>屏蔽自带 Tomcat</strong></p>
<p><img src="/images/Spring%20Boot%E9%A1%B9%E7%9B%AE%E6%94%BE%E5%88%B0Tomcat/%E5%B1%8F%E8%94%BD%E8%87%AA%E5%B8%A6tomcat.png" alt="屏蔽自带tomcat"></p>
</li>
<li><p><strong>修改 Spring Boot 主启动类</strong></p>
<ol>
<li>继承 SpringBootServletInitializer 类</li>
<li>重写 configure 方法</li>
<li>修改 return 为 <code>builder.sources(SpringbootDemoApplication.class);</code></li>
</ol>
<p><img src="/images/Spring%20Boot%E9%A1%B9%E7%9B%AE%E6%94%BE%E5%88%B0Tomcat/%E7%BB%A7%E6%89%BF%E7%B1%BB.png" alt="继承类"></p>
</li>
<li><p><strong>maven clean，maven package</strong></p>
</li>
<li><p><strong>把 war 包放到 Tomcat 目录下的 webapps 目录下</strong></p>
</li>
<li><p><strong>启动 Tomcat（启动 Tomcat 时会自动解压 Tomcat 目录下的 war 包）</strong></p>
</li>
<li><p><strong>浏览器访问（war 包解压后的文件夹名称就是项目的虚拟目录）</strong></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>Java/微服务/Docker</title>
    <url>/2021/04/05/Java/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Docker/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java/微服务/Spring Cloud</title>
    <url>/2021/04/05/Java/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Spring%20Cloud/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>JSON</title>
    <url>/2021/01/05/Java/2.JavaWeb/JSON/</url>
    <content><![CDATA[<p>JSON：<strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation <code>JavaScript对象表示法</code></p>
<a id="more"></a>



<p>简介：</p>
<ul>
<li><p>JSON 是纯文本的信息</p>
</li>
<li><p>JSON 是存储和交换文本信息的语法，类似于 XML</p>
</li>
<li><p>JSON 比 XML 更小，更快，更易解析</p>
</li>
</ul>
<h4 id="JSON定义："><a href="#JSON定义：" class="headerlink" title="JSON定义："></a>JSON定义：</h4><ul>
<li><p>对象形式 : <code>{&quot;name&quot;:&quot;jack&quot;, &quot;age&quot;:22, &quot;gender&quot;:true}</code></p>
<ul>
<li>键 : 只能是字符串</li>
<li>值:<ol>
<li>数字（整数或浮点数）</li>
<li>字符串（在双引号中）</li>
<li>逻辑值（true 或 false）</li>
<li>数组（在中括号中）</li>
<li>对象（在大括号中）</li>
<li>null</li>
</ol>
</li>
</ul>
</li>
<li><p>数组形式 : <code>[&quot;dog&quot;, &quot;cat&quot;]</code></p>
<ul>
<li>键: 数组索引（从 0 开始的数字）</li>
<li>值: 数组中的元素</li>
</ul>
</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本定义格式</span></span><br><span class="line">&#123;"name":"jack","age":22,"gender":true&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌套定义格式</span></span><br><span class="line">&#123;<span class="attr">"persons"</span>:[</span><br><span class="line">    &#123;<span class="attr">"name"</span>:<span class="string">"张三"</span>,<span class="attr">"age"</span>:<span class="number">22</span>,<span class="attr">"gender"</span>:<span class="literal">true</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">"name"</span>:<span class="string">"李四"</span>,<span class="attr">"age"</span>:<span class="number">23</span>,<span class="attr">"gender"</span>:<span class="literal">true</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">"name"</span>:<span class="string">"王五"</span>,<span class="attr">"age"</span>:<span class="number">24</span>,<span class="attr">"gender"</span>:<span class="literal">true</span>&#125;</span><br><span class="line">]&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="获取-JSON-中的数据"><a href="#获取-JSON-中的数据" class="headerlink" title="获取 JSON 中的数据"></a>获取 JSON 中的数据</h4><ol>
<li><code>JSON对象.键名</code></li>
<li><code>JSON对象[&quot;键名&quot;]</code></li>
</ol>
<hr>
<h4 id="JSON-和-Java对象-相互转换"><a href="#JSON-和-Java对象-相互转换" class="headerlink" title="JSON 和 Java对象 相互转换"></a>JSON 和 Java对象 相互转换</h4><ul>
<li><p>JSON 解析器：</p>
<ul>
<li>Jsonlib：官方提供</li>
<li>fastjson：阿里提供</li>
<li>Jackson：SpringMVC 内置</li>
<li>Gson：谷歌提供</li>
</ul>
</li>
</ul>
<ul>
<li><p>JSON 转为 Java 对象 (使用 Jackson)</p>
<ol>
<li><p>导入 Jackson 的相关坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--以下【三个jar包紧密依赖】同时存在--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ul>
<ol start="2">
<li><p>创建 Jackson 核心对象 <code>ObjectMapper</code></p>
</li>
<li><p>调用 <code>ObjectMapper</code> 的相关方法进行转换 : <code>readValue( JSON 字符串数据,Class)</code></p>
</li>
</ol>
<ul>
<li><p>Java 对象转换 JSON</p>
<ol>
<li><p>导坐标 (同上)</p>
</li>
<li><p>创建 Jackson 核心对象 <code>ObjectMapper</code></p>
</li>
<li><p>调用 <code>ObjectMapper</code> 的相关方法进行转换</p>
<ol>
<li><code>writeValue(参数1，obj)</code> : 把 obj 对象转换为 JSON 字符串, 然后<pre><code>根据参数1不同：
    File：把 JSON 并保存到指定的文件
    Writer：把 JSON 放到字符输出流
    OutputStream：把 JSON 放到字节输出流</code></pre></li>
<li><code>writeValueAsString(obj)</code>：将对象转为 JSON 字符串</li>
</ol>
</li>
<li><p>注解：</p>
<ol>
<li><code>@JsonIgnore</code>：排除属性</li>
<li><code>@JsonFormat</code>：属性值的格式化<ul>
<li><code>@JsonFormat(pattern = &quot;yyyy-MM-dd&quot;)</code></li>
</ul>
</li>
</ol>
</li>
<li><p>复杂 Java 对象转换</p>
<ol>
<li>List：转换后为 JSON 数组</li>
<li>Map：转换后为 JSON 对象</li>
</ol>
</li>
</ol>
</li>
</ul>
]]></content>
      <tags>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title>Python第三方库</title>
    <url>/2020/09/22/Python/Python_old/Python%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/</url>
    <content><![CDATA[<p>Python 常用的第三方库，在此做一些用法记录。 </p>
<a id="more"></a>



<h2 id="pyinstaller"><a href="#pyinstaller" class="headerlink" title="pyinstaller"></a>pyinstaller</h2><p>将<code>.py</code>文件打包成可执行文件(<code>.exe</code>)的库</p>
<blockquote>
<p>  不只是windows平台, linux 和 macos 平台都可以使用</p>
</blockquote>
<p>基本使用方法: </p>
<ol>
<li>在<code>.py</code>文件所在的目录打开<code>cmd</code></li>
<li>使用命令: <code>pyinstaller -F 文件名</code></li>
</ol>
<p>pyinstaller库常用参数:</p>
<ul>
<li><code>-h</code> : 查看帮助</li>
<li><code>--clean</code> : 清理</li>
<li><code>-D, --onedir</code> : 默认值, 生成dist文件夹</li>
<li><code>-F, --onefile</code> : 在dist文件夹中只生成独立的打包文件</li>
<li><code>-i&lt;图标文件名.ico&gt;</code> : 指定打包文件使用的图标(icon)文件</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>pyinstaller库</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC_请求</title>
    <url>/2020/07/25/Java/3.SSM%E6%A1%86%E6%9E%B6/SpringMVC_%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<p>SpringMVC 请求参数的绑定 &amp; 处理请求常用注解</p>
<a id="more"></a>



<h2 id="请求参数的绑定"><a href="#请求参数的绑定" class="headerlink" title="请求参数的绑定"></a>请求参数的绑定</h2><p><strong>绑定机制：</strong></p>
<ul>
<li><strong>请求参数 ==&gt; Controller 中相关方法的参数</strong></li>
</ul>
<p><strong>支持的数据类型：</strong></p>
<ul>
<li><p>基本数据类型 / String 类型</p>
<ul>
<li><code>请求参数名称</code> 和 <code>方法中参数名</code>相同</li>
<li>区分大小写</li>
</ul>
</li>
<li><p>实体类（JavaBean）</p>
</li>
<li><p>Controller 中方法的参数类型为 JavaBean 的类型</p>
<ul>
<li><p><code>请求参数名称</code> 和 <code>JavaBean的属性名称</code>需要一致</p>
</li>
<li><p>如果一个 JavaBean 类中包含其他的引用类型，那么请求参数名称要写成：<code>对象.属性</code> 例如：<br><code>address.name</code></p>
</li>
</ul>
</li>
<li><p>集合数据类型（List、map 集合等）</p>
<ul>
<li>如果集合是 JavaBean 的一个属性, 请求参数名和集合属性名相同</li>
</ul>
</li>
</ul>
<hr>
<p><strong>请求参数中文乱码的解决</strong>：</p>
<p>在 web.xml 中使用 SpringMVC 提供的 CharacterEncodingFilter</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置过滤器，解决中文乱码的问题 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 指定字符集 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>自定义类型转换器：</strong></p>
<blockquote>
<p>表单提交的任何数据类型全部都是字符串类型，但是后台定义Integer类型，数据也可以封装上，说明Spring框架内部会默认进行数据类型转换。</p>
<p>但是并不是所有的字符串都可以被成功转换, 有些时候需要自定义类型转换器</p>
</blockquote>
<p>1、自己写一个类，并<strong>实现Converter的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 把字符串转换成日期的转换器</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> pika</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToDateConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Date</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 进行类型转换的方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        <span class="keyword">if</span>(source == <span class="keyword">null</span>) &#123;</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数不能为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">            <span class="comment">// 解析字符串</span></span><br><span class="line">            Date date = df.parse(source);</span><br><span class="line">            <span class="keyword">return</span> date;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"类型转换错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2、注册自定义的类型转换器，在springmvc.xml配置文件中编写配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注册自定义类型转换器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conversionService"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"converters"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"cn.pika.utils.StringToDateConverter"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启Spring对MVC注解的支持 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">"conversionService"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>在控制器中使用原生的ServletAPI对象</strong></p>
<ul>
<li>只需要在控制器的方法参数定义<code>HttpServletRequest</code>和<code>HttpServletResponse</code>对象即可</li>
</ul>
<h2 id="SpringMVC常用注解"><a href="#SpringMVC常用注解" class="headerlink" title="SpringMVC常用注解"></a>SpringMVC常用注解</h2><p> <code>@RequestParam()</code></p>
<ul>
<li><p>作用：把请求中的指定名称的参数传递给控制器中的形参赋值</p>
</li>
<li><p>属性</p>
<ul>
<li>value<strong>/</strong>name：请求参数的名称, 不写则默认为形参的名称</li>
<li>required：请求参数中是否必须提供此参数，默认值是true，必须提供</li>
</ul>
</li>
<li><p>defaultValue：参数的默认值</p>
</li>
<li><p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 接收请求</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(path=<span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(@RequestParam(value=<span class="string">"username"</span>,required=<span class="keyword">false</span>)</span>String name) </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"aaaa"</span>);</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p><code>@RequestBody()</code></p>
<ul>
<li><p>作用：用于获取请求体的内容（注意：get方法不可以）</p>
</li>
<li><p>属性</p>
<ul>
<li>required：是否必须有请求体，默认值是true</li>
</ul>
</li>
<li><p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 接收请求</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(path=<span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(@RequestBody String body)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"aaaa"</span>);</span><br><span class="line">    System.out.println(body);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p><code>PathVariable()</code></p>
<ul>
<li><p>作用：拥有绑定url中的占位符的。例如：url中有/delete/{id}，{id}就是占位符</p>
</li>
<li><p>属性</p>
<ul>
<li>value：指定url中的占位符名称</li>
</ul>
</li>
<li><p><strong>Restful</strong> 风格的 URL</p>
<ul>
<li>请求路径一样，可以根据不同的请求方式去执行后台的不同方法</li>
<li>restful 风格的 URL 优点<ul>
<li>结构清晰</li>
<li>符合标准</li>
<li>易于理解</li>
<li>扩展方便</li>
</ul>
</li>
</ul>
</li>
<li><p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;a href="user/hello/1"&gt;入门案例&lt;/a&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 接收请求</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(path=<span class="string">"/hello/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(@PathVariable(value=<span class="string">"id"</span>)</span> String id) </span>&#123;</span><br><span class="line">    System.out.println(id);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p><code>@RequestHeader()</code></p>
<ul>
<li><p>作用：获取指定请求头的值</p>
</li>
<li><p>属性</p>
<ul>
<li>value：请求头的名称</li>
</ul>
</li>
<li><p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path=<span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(@RequestHeader(value=<span class="string">"Accept"</span>)</span> String header) </span>&#123;</span><br><span class="line">    System.out.println(header);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p><code>@CookieValue()</code></p>
<ul>
<li><p>作用：用于获取指定cookie的名称的值</p>
</li>
<li><p>属性</p>
</li>
<li><p>value：cookie的名称</p>
</li>
<li><p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path=<span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(@CookieValue(value=<span class="string">"JSESSIONID"</span>)</span> String cookieValue) </span>&#123;</span><br><span class="line">    System.out.println(cookieValue);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p> <code>@ModelAttribute()</code></p>
<ul>
<li><p>作用</p>
<ul>
<li>出现在方法上：表示当前方法会在控制器方法执行前执行。</li>
<li>出现在参数上：获取指定的数据给参数赋值。</li>
</ul>
</li>
<li><p>应用场景</p>
<ul>
<li>当提交表单数据不是完整的实体数据时，保证没有提交的字段使用数据库原来的数据。</li>
</ul>
</li>
<li><p>具体的代码</p>
<p>1、修饰的方法有返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 作用在方法，先执行</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">showUser</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"showUser执行了..."</span>);</span><br><span class="line">    <span class="comment">// 模拟从数据库中查询对象</span></span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setName(<span class="string">"哈哈"</span>);</span><br><span class="line">    user.setPassword(<span class="string">"123"</span>);</span><br><span class="line">    user.setMoney(<span class="number">100</span>d);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 修改user的方法</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> cookieValue</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(path=<span class="string">"/updateUser"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">updateUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、修饰的方法没有返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 作用在方法，先执行</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showUser</span><span class="params">(String name,Map&lt;String, User&gt; map)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"showUser执行了..."</span>);</span><br><span class="line">    <span class="comment">// 模拟从数据库中查询对象</span></span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setName(<span class="string">"哈哈"</span>);</span><br><span class="line">    user.setPassword(<span class="string">"123"</span>);</span><br><span class="line">    user.setMoney(<span class="number">100</span>d);</span><br><span class="line">    map.put(<span class="string">"abc"</span>, user);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 修改用户的方法</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> cookieValue</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(path=<span class="string">"/updateUser"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">updateUser</span><span class="params">(@ModelAttribute(value=<span class="string">"abc"</span>)</span> User user) </span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p><code>@SessionAttributes()</code></p>
<ul>
<li><p>作用：用于多次执行控制器方法间的参数共享</p>
</li>
<li><p>属性</p>
<ul>
<li>value：指定存入属性的名称</li>
</ul>
</li>
<li><p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(path=<span class="string">"/user"</span>)</span><br><span class="line"><span class="meta">@SessionAttributes</span>(value= &#123;<span class="string">"username"</span>,<span class="string">"password"</span>,<span class="string">"age"</span>&#125;,types=</span><br><span class="line">&#123;String<span class="class">.<span class="keyword">class</span>,<span class="title">Integer</span>.<span class="title">class</span>&#125;) // 把数据存入到<span class="title">session</span>域对象中</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 向session中存入值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(path=<span class="string">"/save"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">save</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"向session域中保存数据"</span>);</span><br><span class="line">        model.addAttribute(<span class="string">"username"</span>, <span class="string">"root"</span>);</span><br><span class="line">        model.addAttribute(<span class="string">"password"</span>, <span class="string">"123"</span>);</span><br><span class="line">        model.addAttribute(<span class="string">"age"</span>, <span class="number">20</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 从session中获取值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(path=<span class="string">"/find"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">find</span><span class="params">(ModelMap modelMap)</span> </span>&#123;</span><br><span class="line">        String username = (String) modelMap.get(<span class="string">"username"</span>);</span><br><span class="line">        String password = (String) modelMap.get(<span class="string">"password"</span>);</span><br><span class="line">        Integer age = (Integer) modelMap.get(<span class="string">"age"</span>);</span><br><span class="line">        System.out.println(username + <span class="string">" : "</span>+password +<span class="string">" : "</span>+age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 清除值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(path=<span class="string">"/delete"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">delete</span><span class="params">(SessionStatus status)</span> </span>&#123;</span><br><span class="line">        status.setComplete();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Filter &amp; Listener</title>
    <url>/2020/06/29/Java/2.JavaWeb/Filter%20&amp;%20Listener/</url>
    <content><![CDATA[<p>Filter 和 Listener 是 JavaWeb 的两个重要组成部分</p>
<a id="more"></a>

<h1 id="Filter-amp-Listener"><a href="#Filter-amp-Listener" class="headerlink" title="Filter &amp; Listener"></a>Filter &amp; Listener</h1><blockquote>
<p>Filter： 过滤器</p>
<p>Listener：监听器</p>
</blockquote>
<h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p><strong>概念：</strong>在 web 中，当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能</p>
<p><strong>作用：</strong>一般用于完成一些通用的操作，如：登录验证，统一编码处理，敏感字符过滤…</p>
<p><strong>快速入门：</strong>(基于注解)</p>
<ol>
<li><p>新建一个 Java 类，实现 <code>Filter</code> 接口（<code>javax.Servlet</code> 包），实现方法（<code>init()</code>, <code>doFilter()</code>, <code>destroy()</code>）</p>
</li>
<li><p>然后用 <code>@WebFilter(&quot;/*&quot;)</code> 注解标识这个类是一个过滤器，并配置过滤资源路径</p>
</li>
<li><p>在 <code>doFilter()</code> 方法里面添加过滤器的功能，并使用 <code>filterChain.doFilter()</code> 执行<strong>放行</strong></p>
</li>
</ol>
<h4 id="Filter-细节"><a href="#Filter-细节" class="headerlink" title="Filter 细节"></a>Filter 细节</h4><p><strong>Filter 的 xml 配置：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filterDemo1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>cn.pika.FilterDemo1<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filterDemo1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>Filter 的执行流程：</strong></p>
<ol>
<li>执行过滤器放行前代码</li>
<li>执行放行后访问的资源</li>
<li>执行过滤器放行代码下面的代码</li>
</ol>
<p><strong>Filter 的生命周期：</strong></p>
<ol>
<li>init：服务器启动，init 方法执行，创建 Filter 对象</li>
<li>doFilter：每一次访问被该过滤器拦截的资源时，都会执行</li>
<li>destroy：服务器正常关闭时，执行 destroy 方法，销毁 Filter 对象</li>
</ol>
<p><strong>Filter 配置详解：</strong></p>
<ol>
<li>拦截路径的配置：<ul>
<li>具体资源路径：<code>/index.jsp</code>  只有访问 index.jsp 时，过滤器才会执行 （一般不常用）</li>
<li>目录拦截：<code>/user/*</code>  访问 user 下的所有资源时，过滤器都会执行</li>
<li>后缀名拦截：<code>*.jsp</code> 访问所有后缀名为 jsp 的资源时，过滤器都会执行</li>
<li>拦截所有资源：<code>/*</code>  访问所有资源时，过滤器都会执行</li>
</ul>
</li>
<li>拦截方式的配置：资源被访问的方式<ul>
<li>注解配置：设置 <code>dispatcherTypes</code> 属性<ol>
<li><code>REQUEST</code>: 默认值， 浏览器直接请求资源</li>
<li><code>FORWARD</code>: 转发访问资源</li>
<li><code>INCLUDE</code>: 包含访问资源</li>
<li><code>ERROR</code>: 错误跳转资源</li>
<li><code>ASYNC</code>: 异步访问资源</li>
</ol>
</li>
<li>web.xml 配置<ul>
<li>设置<code>&lt;dispatcher&gt;&lt;/dispatcher&gt;</code>标签</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>过滤器链（配置多个过滤器）</strong></p>
<ol>
<li>执行过程：如果有两个过滤器（过滤器1 和 过滤器2）<ol>
<li>过滤器1</li>
<li>过滤器2</li>
<li>资源执行</li>
<li>过滤器2</li>
<li>过滤器1</li>
</ol>
</li>
<li>执行顺序：<ul>
<li>注解配置：按照过滤器的类名字符串比较规则比较，值小的先执行</li>
<li>web.xml 配置：按照 <code>&lt;filter-mapping&gt;</code> 的定义顺序执行, 写在上面的先执行</li>
</ul>
</li>
</ol>
<h2 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h2><blockquote>
<p>Listener 是 JavaWeb 的三大组件之一</p>
</blockquote>
<p>事件监听机制:</p>
<ul>
<li>事件: 一件事情</li>
<li>事件源: 事件发生的地方</li>
<li>监听器: 事件发生时执行的动作</li>
<li>注册监听: 将事件, 事件源, 监听器绑定在一块. 当事件源上发生某件事情后, 执行监听器代码</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Filter</tag>
        <tag>Listener</tag>
      </tags>
  </entry>
  <entry>
    <title>Python高级变量类型</title>
    <url>/2020/05/15/Python/Python_new/14_%E9%AB%98%E7%BA%A7%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>列表 / 元组 / 字典/ 字符串</p>
<a id="more"></a>



<h1 id="高级变量类型"><a href="#高级变量类型" class="headerlink" title="高级变量类型"></a>高级变量类型</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>列表</li>
<li>元组</li>
<li>字典</li>
<li>字符串</li>
<li>公共方法</li>
<li>变量高级</li>
</ul>
<h3 id="知识点回顾"><a href="#知识点回顾" class="headerlink" title="知识点回顾"></a>知识点回顾</h3><ul>
<li><p>Python 中数据类型可以分为 <strong>数字型</strong> 和 <strong>非数字型</strong></p>
</li>
<li><p>数字型</p>
<ul>
<li>整型 (<code>int</code>)</li>
<li>浮点型（<code>float</code>）</li>
<li>布尔型（<code>bool</code>） <ul>
<li>真 <code>True</code> <code>非 0 数</code> —— <strong>非零即真</strong></li>
<li>假 <code>False</code> <code>0</code></li>
</ul>
</li>
<li>复数型 (<code>complex</code>)<ul>
<li>主要用于科学计算，例如：平面场问题、波动问题、电感电容等问题</li>
</ul>
</li>
</ul>
</li>
<li><p>非数字型</p>
<ul>
<li>字符串</li>
<li>列表</li>
<li>元组</li>
<li>字典</li>
</ul>
</li>
<li><p>在 <code>Python</code> 中，所有 <strong>非数字型变量</strong> 都支持以下特点：</p>
<ol>
<li>都是一个 <strong>序列</strong> <code>sequence</code>，也可以理解为 <strong>容器</strong></li>
<li><strong>取值</strong> <code>[]</code></li>
<li><strong>遍历</strong> <code>for in</code></li>
<li><strong>计算长度</strong>、<strong>最大/最小值</strong>、<strong>比较</strong>、<strong>删除</strong></li>
<li><strong>链接</strong> <code>+</code> 和 <strong>重复</strong> <code>*</code></li>
<li><strong>切片</strong></li>
</ol>
</li>
</ul>
<h2 id="01-列表"><a href="#01-列表" class="headerlink" title="01. 列表"></a>01. 列表</h2><h3 id="1-1-列表的定义"><a href="#1-1-列表的定义" class="headerlink" title="1.1 列表的定义"></a>1.1 列表的定义</h3><ul>
<li><code>List</code>（列表） 是 <code>Python</code> 中使用 <strong>最频繁</strong> 的数据类型，在其他语言中通常叫做 <strong>数组</strong></li>
<li>专门用于存储 <strong>一串 信息</strong></li>
<li>列表用 <code>[]</code> 定义，<strong>数据</strong> 之间使用 <code>,</code> 分隔</li>
<li>列表的 <strong>索引</strong> 从 <code>0</code> 开始<ul>
<li><strong>索引</strong> 就是数据在 <strong>列表</strong> 中的位置编号，<strong>索引</strong> 又可以被称为 <strong>下标</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：从列表中取值时，如果 <strong>超出索引范围</strong>，程序会报错</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">"zhangsan"</span>, <span class="string">"lisi"</span>, <span class="string">"wangwu"</span>]</span><br></pre></td></tr></table></figure>

<p><img src="./images/014/001_%E5%88%97%E8%A1%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="001_列表示意图"></p>
<h3 id="1-2-列表常用操作"><a href="#1-2-列表常用操作" class="headerlink" title="1.2 列表常用操作"></a>1.2 列表常用操作</h3><ul>
<li>在 <code>ipython3</code> 中定义一个 <strong>列表</strong>，例如：<code>name_list = []</code></li>
<li>输入 <code>name_list.</code> 按下 <code>TAB</code> 键，<code>ipython</code> 会提示 <strong>列表</strong> 能够使用的 <strong>方法</strong> 如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [1]: name_list.</span><br><span class="line">name_list.append   name_list.count    name_list.insert   name_list.reverse</span><br><span class="line">name_list.clear    name_list.extend   name_list.pop      name_list.sort</span><br><span class="line">name_list.copy     name_list.index    name_list.remove</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>序号</th>
<th>分类</th>
<th>关键字 / 函数 / 方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>增加</td>
<td>列表.insert(索引, 数据)</td>
<td>在指定位置插入数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td>列表.append(数据)</td>
<td>在末尾追加数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td>列表.extend(列表2)</td>
<td>将列表2 的数据追加到列表</td>
</tr>
<tr>
<td>2</td>
<td>修改</td>
<td>列表[索引] = 数据</td>
<td>修改指定索引的数据</td>
</tr>
<tr>
<td>3</td>
<td>删除</td>
<td>del 列表[索引]</td>
<td>删除指定索引的数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td>列表.remove[数据]</td>
<td>删除第一个出现的指定数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td>列表.pop</td>
<td>删除末尾数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td>列表.pop(索引)</td>
<td>删除指定索引数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td>列表.clear</td>
<td>清空列表</td>
</tr>
<tr>
<td>4</td>
<td>统计</td>
<td>len(列表)</td>
<td>列表长度</td>
</tr>
<tr>
<td></td>
<td></td>
<td>列表.count(数据)</td>
<td>数据在列表中出现的次数</td>
</tr>
<tr>
<td>5</td>
<td>排序</td>
<td>列表.sort()</td>
<td>升序排序</td>
</tr>
<tr>
<td></td>
<td></td>
<td>列表.sort(reverse=True)</td>
<td>降序排序</td>
</tr>
<tr>
<td></td>
<td></td>
<td>列表.reverse()</td>
<td>逆序、反转</td>
</tr>
</tbody></table>
<h4 id="del-关键字（科普）"><a href="#del-关键字（科普）" class="headerlink" title="del 关键字（科普）"></a>del 关键字（科普）</h4><ul>
<li>使用 <code>del</code> 关键字(<code>delete</code>) 同样可以删除列表中元素</li>
<li><code>del</code> 关键字本质上是用来 <strong>将一个变量从内存中删除的</strong></li>
<li>如果使用 <code>del</code> 关键字将变量从内存中删除，后续的代码就不能再使用这个变量了</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> name_list[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在日常开发中，要从列表删除数据，建议 <strong>使用列表提供的方法</strong></p>
</blockquote>
<h4 id="关键字、函数和方法（科普）"><a href="#关键字、函数和方法（科普）" class="headerlink" title="关键字、函数和方法（科普）"></a>关键字、函数和方法（科普）</h4><ul>
<li><strong>关键字</strong> 是 Python 内置的、具有特殊意义的标识符</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> keyword</span><br><span class="line">In [<span class="number">2</span>]: print(keyword.kwlist)</span><br><span class="line">In [<span class="number">3</span>]: print(len(keyword.kwlist))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关键字后面不需要使用括号</p>
</blockquote>
<ul>
<li><strong>函数</strong> 封装了独立功能，可以直接调用</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">函数名(参数)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>函数需要死记硬背</p>
</blockquote>
<ul>
<li><strong>方法</strong> 和函数类似，同样是封装了独立的功能</li>
<li><strong>方法</strong> 需要通过 <strong>对象</strong> 来调用，表示针对这个 <strong>对象</strong> 要做的操作</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">对象.方法名(参数)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在变量后面输入 <code>.</code>，然后选择针对这个变量要执行的操作，记忆起来比函数要简单很多</p>
</blockquote>
<h3 id="1-3-循环遍历"><a href="#1-3-循环遍历" class="headerlink" title="1.3 循环遍历"></a>1.3 循环遍历</h3><ul>
<li><p><strong>遍历</strong> 就是 <strong>从头到尾</strong> <strong>依次</strong> 从 <strong>列表</strong> 中获取数据</p>
<ul>
<li>在 <strong>循环体内部</strong> 针对 <strong>每一个元素</strong>，执行相同的操作</li>
</ul>
</li>
<li><p>在 <code>Python</code> 中为了提高列表的遍历效率，专门提供的 <strong>迭代 iteration 遍历</strong></p>
</li>
<li><p>使用 <code>for</code> 就能够实现迭代遍历</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># for 循环内部使用的变量 in 列表</span></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> name_list:</span><br><span class="line"></span><br><span class="line">    循环内部针对列表元素进行操作</span><br><span class="line">    print(name)</span><br></pre></td></tr></table></figure>

<p><img src="./images/014/002_forin%E5%BE%AA%E7%8E%AF%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="002_forin循环流程图-w420"></p>
<h3 id="1-4-应用场景"><a href="#1-4-应用场景" class="headerlink" title="1.4 应用场景"></a>1.4 <strong>应用场景</strong></h3><ul>
<li>尽管 <code>Python</code> 的 <strong>列表</strong> 中可以 <strong>存储不同类型的数据</strong></li>
<li>但是在开发中，更多的应用场景是<ol>
<li><strong>列表</strong> 存储相同类型的数据</li>
<li>通过 <strong>迭代遍历</strong>，在循环体内部，针对列表中的每一项元素，执行相同的操作</li>
</ol>
</li>
</ul>
<h2 id="02-元组"><a href="#02-元组" class="headerlink" title="02. 元组"></a>02. 元组</h2><h3 id="2-1-元组的定义"><a href="#2-1-元组的定义" class="headerlink" title="2.1 元组的定义"></a>2.1 元组的定义</h3><ul>
<li><code>Tuple</code>（元组）与列表类似，不同之处在于元组的 <strong>元素不能修改</strong><ul>
<li><strong>元组</strong> 表示多个元素组成的序列</li>
<li><strong>元组</strong> 在 <code>Python</code> 开发中，有特定的应用场景</li>
</ul>
</li>
<li>用于存储 <strong>一串 信息</strong>，<strong>数据</strong> 之间使用 <code>,</code> 分隔</li>
<li>元组用 <code>()</code> 定义</li>
<li>元组的 <strong>索引</strong> 从 <code>0</code> 开始<ul>
<li><strong>索引</strong> 就是数据在 <strong>元组</strong> 中的位置编号</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">info_tuple = (<span class="string">"zhangsan"</span>, <span class="number">18</span>, <span class="number">1.75</span>)</span><br></pre></td></tr></table></figure>

<h4 id="创建空元组"><a href="#创建空元组" class="headerlink" title="创建空元组"></a>创建空元组</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">info_tuple = ()</span><br></pre></td></tr></table></figure>

<h4 id="元组中-只包含一个元素-时，需要-在元素后面添加逗号"><a href="#元组中-只包含一个元素-时，需要-在元素后面添加逗号" class="headerlink" title="元组中 只包含一个元素 时，需要 在元素后面添加逗号"></a>元组中 <strong>只包含一个元素</strong> 时，需要 <strong>在元素后面添加逗号</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">info_tuple = (<span class="number">50</span>, )</span><br></pre></td></tr></table></figure>

<p><img src="./images/014/003_%E5%85%83%E7%BB%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="003_元组示意图-w500"></p>
<h3 id="2-2-元组常用操作"><a href="#2-2-元组常用操作" class="headerlink" title="2.2 元组常用操作"></a>2.2 元组常用操作</h3><ul>
<li>在 <code>ipython3</code> 中定义一个 <strong>元组</strong>，例如：<code>info = ()</code></li>
<li>输入 <code>info.</code> 按下 <code>TAB</code> 键，<code>ipython</code> 会提示 <strong>元组</strong> 能够使用的函数如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">info.count  info.index</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有关 <strong>元组</strong> 的 <strong>常用操作</strong> 可以参照上图练习</p>
</blockquote>
<h3 id="2-3-循环遍历"><a href="#2-3-循环遍历" class="headerlink" title="2.3 循环遍历"></a>2.3 循环遍历</h3><ul>
<li><strong>取值</strong> 就是从 <strong>元组</strong> 中获取存储在指定位置的数据</li>
<li><strong>遍历</strong> 就是 <strong>从头到尾</strong> <strong>依次</strong> 从 <strong>元组</strong> 中获取数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># for 循环内部使用的变量 in 元组:</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> info:</span><br><span class="line"></span><br><span class="line">    循环内部针对元组元素进行操作</span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>在 <code>Python</code> 中，可以使用 <code>for</code> 循环遍历所有非数字型类型的变量：<strong>列表</strong>、<strong>元组</strong>、<strong>字典</strong> 以及 <strong>字符串</strong></li>
<li>提示：在实际开发中，除非 <strong>能够确认元组中的数据类型</strong>，否则针对元组的循环遍历需求并不是很多</li>
</ul>
</blockquote>
<h3 id="2-4-应用场景"><a href="#2-4-应用场景" class="headerlink" title="2.4 应用场景"></a>2.4 应用场景</h3><ul>
<li>尽管可以使用 <code>for in</code> 遍历 <strong>元组</strong></li>
<li>但是在开发中，更多的应用场景是：<ul>
<li><strong>函数的 参数 和 返回值</strong>，一个函数可以接收 <strong>任意多个参数</strong>，或者 <strong>一次返回多个数据</strong><ul>
<li>有关 <strong>函数的参数 和 返回值</strong>，在后续 <strong>函数高级</strong> 给大家介绍</li>
</ul>
</li>
<li><strong>格式字符串</strong>，格式化字符串后面的 <code>()</code> 本质上就是一个元组</li>
<li><strong>让列表不可以被修改</strong>，以保护数据安全</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">info = (<span class="string">"zhangsan"</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"%s 的年龄是 %d"</span> % info)</span><br></pre></td></tr></table></figure>

<h4 id="元组和列表之间的转换"><a href="#元组和列表之间的转换" class="headerlink" title="元组和列表之间的转换"></a>元组和列表之间的转换</h4><ul>
<li>使用 <code>list</code> 函数可以把元组转换成列表</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list(元组)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>tuple</code> 函数可以把列表转换成元组</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuple(列表)</span><br></pre></td></tr></table></figure>

<h2 id="03-字典"><a href="#03-字典" class="headerlink" title="03. 字典"></a>03. 字典</h2><h3 id="3-1-字典的定义"><a href="#3-1-字典的定义" class="headerlink" title="3.1 字典的定义"></a>3.1 字典的定义</h3><ul>
<li><code>dictionary</code>（字典） 是 <strong>除列表以外</strong> <code>Python</code> 之中 <strong>最灵活</strong> 的数据类型</li>
<li>字典同样可以用来 <strong>存储多个数据</strong><ul>
<li>通常用于存储 <strong>描述一个 <code>物体</code> 的相关信息</strong> </li>
</ul>
</li>
<li>和列表的区别<ul>
<li><strong>列表</strong> 是 <strong>有序</strong> 的对象集合</li>
<li><strong>字典</strong> 是 <strong>无序</strong> 的对象集合</li>
</ul>
</li>
<li>字典用 <code>{}</code> 定义</li>
<li>字典使用 <strong>键值对</strong> 存储数据，键值对之间使用 <code>,</code> 分隔<ul>
<li><strong>键</strong> <code>key</code> 是索引</li>
<li><strong>值</strong> <code>value</code> 是数据</li>
<li><strong>键</strong> 和 <strong>值</strong> 之间使用 <code>:</code> 分隔</li>
<li><strong>键必须是唯一的</strong></li>
<li><strong>值</strong> 可以取任何数据类型，但 <strong>键</strong> 只能使用 <strong>字符串</strong>、<strong>数字</strong>或 <strong>元组</strong></li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xiaoming = &#123;<span class="string">"name"</span>: <span class="string">"小明"</span>,</span><br><span class="line">            <span class="string">"age"</span>: <span class="number">18</span>,</span><br><span class="line">            <span class="string">"gender"</span>: <span class="literal">True</span>,</span><br><span class="line">            <span class="string">"height"</span>: <span class="number">1.75</span>&#125;</span><br></pre></td></tr></table></figure>

<p><img src="./images/014/002_%E5%AD%97%E5%85%B8%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="002_字典示意图"></p>
<h3 id="3-2-字典常用操作"><a href="#3-2-字典常用操作" class="headerlink" title="3.2 字典常用操作"></a>3.2 字典常用操作</h3><ul>
<li>在 <code>ipython3</code> 中定义一个 <strong>字典</strong>，例如：<code>xiaoming = {}</code></li>
<li>输入 <code>xiaoming.</code> 按下 <code>TAB</code> 键，<code>ipython</code> 会提示 <strong>字典</strong> 能够使用的函数如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [1]: xiaoming.</span><br><span class="line">xiaoming.clear       xiaoming.items       xiaoming.setdefault</span><br><span class="line">xiaoming.copy        xiaoming.keys        xiaoming.update</span><br><span class="line">xiaoming.fromkeys    xiaoming.pop         xiaoming.values</span><br><span class="line">xiaoming.get         xiaoming.popitem</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有关 <strong>字典</strong> 的 <strong>常用操作</strong> 可以参照上图练习</p>
</blockquote>
<h3 id="3-3-循环遍历"><a href="#3-3-循环遍历" class="headerlink" title="3.3 循环遍历"></a>3.3 循环遍历</h3><ul>
<li><strong>遍历</strong> 就是 <strong>依次</strong> 从 <strong>字典</strong> 中获取所有键值对</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># for 循环内部使用的 `key 的变量` in 字典</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> xiaoming:</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"%s: %s"</span> % (k, xiaoming[k]))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：在实际开发中，由于字典中每一个键值对保存数据的类型是不同的，所以针对字典的循环遍历需求并不是很多</p>
</blockquote>
<h3 id="3-4-应用场景"><a href="#3-4-应用场景" class="headerlink" title="3.4 应用场景"></a>3.4 <strong>应用场景</strong></h3><ul>
<li>尽管可以使用 <code>for in</code> 遍历 <strong>字典</strong></li>
<li>但是在开发中，更多的应用场景是：<ul>
<li>使用 <strong>多个键值对</strong>，存储 <strong>描述一个 <code>物体</code> 的相关信息</strong> —— 描述更复杂的数据信息</li>
<li>将 <strong>多个字典</strong> 放在 <strong>一个列表</strong> 中，再进行遍历，在循环体内部针对每一个字典进行 <strong>相同的处理</strong></li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">card_list = [&#123;<span class="string">"name"</span>: <span class="string">"张三"</span>,</span><br><span class="line">              <span class="string">"qq"</span>: <span class="string">"12345"</span>,</span><br><span class="line">              <span class="string">"phone"</span>: <span class="string">"110"</span>&#125;,</span><br><span class="line">             &#123;<span class="string">"name"</span>: <span class="string">"李四"</span>,</span><br><span class="line">              <span class="string">"qq"</span>: <span class="string">"54321"</span>,</span><br><span class="line">              <span class="string">"phone"</span>: <span class="string">"10086"</span>&#125;</span><br><span class="line">             ]</span><br></pre></td></tr></table></figure>


<h2 id="04-字符串"><a href="#04-字符串" class="headerlink" title="04. 字符串"></a>04. 字符串</h2><h3 id="4-1-字符串的定义"><a href="#4-1-字符串的定义" class="headerlink" title="4.1 字符串的定义"></a>4.1 字符串的定义</h3><ul>
<li><strong>字符串</strong> 就是 <strong>一串字符</strong>，是编程语言中表示文本的数据类型</li>
<li>在 Python 中可以使用 <strong>一对双引号</strong> <code>&quot;</code> 或者 <strong>一对单引号</strong> <code>&#39;</code> 定义一个字符串<ul>
<li>虽然可以使用 <code>\&quot;</code> 或者 <code>\&#39;</code> 做字符串的转义，但是在实际开发中：<ul>
<li>如果字符串内部需要使用 <code>&quot;</code>，可以使用 <code>&#39;</code> 定义字符串</li>
<li>如果字符串内部需要使用 <code>&#39;</code>，可以使用 <code>&quot;</code> 定义字符串</li>
</ul>
</li>
</ul>
</li>
<li>可以使用 <strong>索引</strong> 获取一个字符串中 <strong>指定位置的字符</strong>，索引计数从 <strong>0</strong> 开始</li>
<li>也可以使用 <code>for</code> <strong>循环遍历</strong> 字符串中每一个字符</li>
</ul>
<blockquote>
<p>大多数编程语言都是用 <code>&quot;</code> 来定义字符串</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">string = <span class="string">"Hello Python"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> string:</span><br><span class="line">    print(c)</span><br></pre></td></tr></table></figure>

<p><img src="./images/014/005_%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="005_字符串示意图-w500"></p>
<h3 id="4-2-字符串的常用操作"><a href="#4-2-字符串的常用操作" class="headerlink" title="4.2 字符串的常用操作"></a>4.2 字符串的常用操作</h3><ul>
<li>在 <code>ipython3</code> 中定义一个 <strong>字符串</strong>，例如：<code>hello_str = &quot;&quot;</code></li>
<li>输入 <code>hello_str.</code> 按下 <code>TAB</code> 键，<code>ipython</code> 会提示 <strong>字符串</strong> 能够使用的 <strong>方法</strong> 如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [1]: hello_str.</span><br><span class="line">hello_str.capitalize    hello_str.isidentifier  hello_str.rindex</span><br><span class="line">hello_str.casefold      hello_str.islower       hello_str.rjust</span><br><span class="line">hello_str.center        hello_str.isnumeric     hello_str.rpartition</span><br><span class="line">hello_str.count         hello_str.isprintable   hello_str.rsplit</span><br><span class="line">hello_str.encode        hello_str.isspace       hello_str.rstrip</span><br><span class="line">hello_str.endswith      hello_str.istitle       hello_str.split</span><br><span class="line">hello_str.expandtabs    hello_str.isupper       hello_str.splitlines</span><br><span class="line">hello_str.find          hello_str.join          hello_str.startswith</span><br><span class="line">hello_str.format        hello_str.ljust         hello_str.strip</span><br><span class="line">hello_str.format_map    hello_str.lower         hello_str.swapcase</span><br><span class="line">hello_str.index         hello_str.lstrip        hello_str.title</span><br><span class="line">hello_str.isalnum       hello_str.maketrans     hello_str.translate</span><br><span class="line">hello_str.isalpha       hello_str.partition     hello_str.upper</span><br><span class="line">hello_str.isdecimal     hello_str.replace       hello_str.zfill</span><br><span class="line">hello_str.isdigit       hello_str.rfind</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：正是因为 python 内置提供的方法足够多，才使得在开发时，能够针对字符串进行更加灵活的操作！应对更多的开发需求！</p>
</blockquote>
<h4 id="1-判断类型-9"><a href="#1-判断类型-9" class="headerlink" title="1) 判断类型 - 9"></a>1) 判断类型 - 9</h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>string.isspace()</td>
<td>如果 string 中只包含空格，则返回 True</td>
</tr>
<tr>
<td>string.isalnum()</td>
<td>如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True</td>
</tr>
<tr>
<td>string.isalpha()</td>
<td>如果 string 至少有一个字符并且所有字符都是字母则返回 True</td>
</tr>
<tr>
<td>string.isdecimal()</td>
<td>如果 string 只包含数字则返回 True，<code>全角数字</code></td>
</tr>
<tr>
<td>string.isdigit()</td>
<td>如果 string 只包含数字则返回 True，<code>全角数字</code>、<code>⑴</code>、<code>\u00b2</code></td>
</tr>
<tr>
<td>string.isnumeric()</td>
<td>如果 string 只包含数字则返回 True，<code>全角数字</code>，<code>汉字数字</code></td>
</tr>
<tr>
<td>string.istitle()</td>
<td>如果 string 是标题化的(每个单词的首字母大写)则返回 True</td>
</tr>
<tr>
<td>string.islower()</td>
<td>如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True</td>
</tr>
<tr>
<td>string.isupper()</td>
<td>如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True</td>
</tr>
</tbody></table>
<h4 id="2-查找和替换-7"><a href="#2-查找和替换-7" class="headerlink" title="2) 查找和替换 - 7"></a>2) 查找和替换 - 7</h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>string.startswith(str)</td>
<td>检查字符串是否是以 str 开头，是则返回 True</td>
</tr>
<tr>
<td>string.endswith(str)</td>
<td>检查字符串是否是以 str 结束，是则返回 True</td>
</tr>
<tr>
<td>string.find(str, start=0, end=len(string))</td>
<td>检测 str 是否包含在 string 中，如果 start 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回 <code>-1</code></td>
</tr>
<tr>
<td>string.rfind(str, start=0, end=len(string))</td>
<td>类似于 find()，不过是从右边开始查找</td>
</tr>
<tr>
<td>string.index(str, start=0, end=len(string))</td>
<td>跟 find() 方法类似，不过如果 str 不在 string 会报错</td>
</tr>
<tr>
<td>string.rindex(str, start=0, end=len(string))</td>
<td>类似于 index()，不过是从右边开始</td>
</tr>
<tr>
<td>string.replace(old_str, new_str, num=string.count(old))</td>
<td>把 string 中的 old_str 替换成 new_str，如果 num 指定，则替换不超过 num 次</td>
</tr>
</tbody></table>
<h4 id="3-大小写转换-5"><a href="#3-大小写转换-5" class="headerlink" title="3) 大小写转换 - 5"></a>3) 大小写转换 - 5</h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>string.capitalize()</td>
<td>把字符串的第一个字符大写</td>
</tr>
<tr>
<td>string.title()</td>
<td>把字符串的每个单词首字母大写</td>
</tr>
<tr>
<td>string.lower()</td>
<td>转换 string 中所有大写字符为小写</td>
</tr>
<tr>
<td>string.upper()</td>
<td>转换 string 中的小写字母为大写</td>
</tr>
<tr>
<td>string.swapcase()</td>
<td>翻转 string 中的大小写</td>
</tr>
</tbody></table>
<h4 id="4-文本对齐-3"><a href="#4-文本对齐-3" class="headerlink" title="4) 文本对齐 - 3"></a>4) 文本对齐 - 3</h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>string.ljust(width)</td>
<td>返回一个原字符串左对齐，并使用空格填充至长度 width 的新字符串</td>
</tr>
<tr>
<td>string.rjust(width)</td>
<td>返回一个原字符串右对齐，并使用空格填充至长度 width 的新字符串</td>
</tr>
<tr>
<td>string.center(width)</td>
<td>返回一个原字符串居中，并使用空格填充至长度 width 的新字符串</td>
</tr>
</tbody></table>
<h4 id="5-去除空白字符-3"><a href="#5-去除空白字符-3" class="headerlink" title="5) 去除空白字符 - 3"></a>5) 去除空白字符 - 3</h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>string.lstrip()</td>
<td>截掉 string 左边（开始）的空白字符</td>
</tr>
<tr>
<td>string.rstrip()</td>
<td>截掉 string 右边（末尾）的空白字符</td>
</tr>
<tr>
<td>string.strip()</td>
<td>截掉 string 左右两边的空白字符</td>
</tr>
</tbody></table>
<h4 id="6-拆分和连接-5"><a href="#6-拆分和连接-5" class="headerlink" title="6) 拆分和连接 - 5"></a>6) 拆分和连接 - 5</h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>string.partition(str)</td>
<td>把字符串 string 分成一个 3 元素的元组 (str前面, str, str后面)</td>
</tr>
<tr>
<td>string.rpartition(str)</td>
<td>类似于 partition() 方法，不过是从右边开始查找</td>
</tr>
<tr>
<td>string.split(str=””, num)</td>
<td>以 str 为分隔符拆分 string，如果 num 有指定值，则仅分隔 num + 1 个子字符串，str 默认包含 ‘\r’, ‘\t’, ‘\n’ 和空格</td>
</tr>
<tr>
<td>string.splitlines()</td>
<td>按照行(‘\r’, ‘\n’, ‘\r\n’)分隔，返回一个包含各行作为元素的列表</td>
</tr>
<tr>
<td>string.join(seq)</td>
<td>以 string 作为分隔符，将 seq 中所有的元素（的字符串表示）合并为一个新的字符串</td>
</tr>
</tbody></table>
<h3 id="4-3-字符串的切片"><a href="#4-3-字符串的切片" class="headerlink" title="4.3 字符串的切片"></a>4.3 字符串的切片</h3><ul>
<li><strong>切片</strong> 方法适用于 <strong>字符串</strong>、<strong>列表</strong>、<strong>元组</strong><ul>
<li><strong>切片</strong> 使用 <strong>索引值</strong> 来限定范围，从一个大的 <strong>字符串</strong> 中 <strong>切出</strong> 小的 <strong>字符串</strong></li>
<li><strong>列表</strong> 和 <strong>元组</strong> 都是 <strong>有序</strong> 的集合，都能够 <strong>通过索引值</strong> 获取到对应的数据</li>
<li><strong>字典</strong> 是一个 <strong>无序</strong> 的集合，是使用 <strong>键值对</strong> 保存数据</li>
</ul>
</li>
</ul>
<p><img src="./images/014/006_%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B4%A2%E5%BC%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="006_字符串索引示意图"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字符串[开始索引:结束索引:步长]</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：</p>
<ol>
<li>指定的区间属于 <strong>左闭右开</strong> 型 <code>[开始索引,  结束索引)</code> =&gt; <code>开始索引 &gt;= 范围 &lt; 结束索引</code><ul>
<li>从 <code>起始</code> 位开始，到 <strong><code>结束</code>位的前一位</strong> 结束（<strong>不包含结束位本身</strong>)</li>
</ul>
</li>
<li>从头开始，<strong>开始索引</strong> <strong>数字可以省略，冒号不能省略</strong></li>
<li>到末尾结束，<strong>结束索引</strong> <strong>数字可以省略，冒号不能省略</strong></li>
<li>步长默认为 <code>1</code>，如果连续切片，<strong>数字和冒号都可以省略</strong></li>
</ol>
<h4 id="索引的顺序和倒序"><a href="#索引的顺序和倒序" class="headerlink" title="索引的顺序和倒序"></a>索引的顺序和倒序</h4><ul>
<li>在 Python 中不仅支持 <strong>顺序索引</strong>，同时还支持 <strong>倒序索引</strong></li>
<li>所谓倒序索引就是 <strong>从右向左</strong> 计算索引<ul>
<li>最右边的索引值是 <strong>-1</strong>，依次递减</li>
</ul>
</li>
</ul>
<p><strong>演练需求</strong></p>
<ul>
<li><ol>
<li>截取从 2 ~ 5 位置 的字符串</li>
</ol>
</li>
<li><ol start="2">
<li>截取从 2 ~ <code>末尾</code> 的字符串</li>
</ol>
</li>
<li><ol start="3">
<li>截取从 <code>开始</code> ~ 5 位置 的字符串</li>
</ol>
</li>
<li><ol start="4">
<li>截取完整的字符串</li>
</ol>
</li>
<li><ol start="5">
<li>从开始位置，每隔一个字符截取字符串</li>
</ol>
</li>
<li><ol start="6">
<li>从索引 1 开始，每隔一个取一个</li>
</ol>
</li>
<li><ol start="7">
<li>截取从 2 ~ <code>末尾 - 1</code> 的字符串</li>
</ol>
</li>
<li><ol start="8">
<li>截取字符串末尾两个字符</li>
</ol>
</li>
<li><ol start="9">
<li>字符串的逆序（面试题）</li>
</ol>
</li>
</ul>
<p><strong>答案</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">num_str &#x3D; &quot;0123456789&quot;</span><br><span class="line"></span><br><span class="line"># 1. 截取从 2 ~ 5 位置 的字符串</span><br><span class="line">print(num_str[2:6])</span><br><span class="line"></span><br><span class="line"># 2. 截取从 2 ~ &#96;末尾&#96; 的字符串</span><br><span class="line">print(num_str[2:])</span><br><span class="line"></span><br><span class="line"># 3. 截取从 &#96;开始&#96; ~ 5 位置 的字符串</span><br><span class="line">print(num_str[:6])</span><br><span class="line"></span><br><span class="line"># 4. 截取完整的字符串</span><br><span class="line">print(num_str[:])</span><br><span class="line"></span><br><span class="line"># 5. 从开始位置，每隔一个字符截取字符串</span><br><span class="line">print(num_str[::2])</span><br><span class="line"></span><br><span class="line"># 6. 从索引 1 开始，每隔一个取一个</span><br><span class="line">print(num_str[1::2])</span><br><span class="line"></span><br><span class="line"># 倒序切片</span><br><span class="line"># -1 表示倒数第一个字符</span><br><span class="line">print(num_str[-1])</span><br><span class="line"></span><br><span class="line"># 7. 截取从 2 ~ &#96;末尾 - 1&#96; 的字符串</span><br><span class="line">print(num_str[2:-1])</span><br><span class="line"></span><br><span class="line"># 8. 截取字符串末尾两个字符</span><br><span class="line">print(num_str[-2:])</span><br><span class="line"></span><br><span class="line"># 9. 字符串的逆序（面试题）</span><br><span class="line">print(num_str[::-1])</span><br></pre></td></tr></table></figure>

<h2 id="05-公共方法"><a href="#05-公共方法" class="headerlink" title="05. 公共方法"></a>05. 公共方法</h2><h3 id="5-1-Python-内置函数"><a href="#5-1-Python-内置函数" class="headerlink" title="5.1 Python 内置函数"></a>5.1 Python 内置函数</h3><p>Python 包含了以下内置函数：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>len(item)</td>
<td>计算容器中元素个数</td>
<td></td>
</tr>
<tr>
<td>del(item)</td>
<td>删除变量</td>
<td>del 有两种方式</td>
</tr>
<tr>
<td>max(item)</td>
<td>返回容器中元素最大值</td>
<td>如果是字典，只针对 key 比较</td>
</tr>
<tr>
<td>min(item)</td>
<td>返回容器中元素最小值</td>
<td>如果是字典，只针对 key 比较</td>
</tr>
</tbody></table>
<p><strong>注意</strong></p>
<ul>
<li><strong>字符串</strong> 比较符合以下规则： “0” &lt; “A” &lt; “a”</li>
</ul>
<h3 id="5-2-切片"><a href="#5-2-切片" class="headerlink" title="5.2 切片"></a>5.2 切片</h3><p>| 描述 | Python 表达式 | 结果 | 支持的数据类型 |<br>| :—: | — | — | — | — |<br>| 切片 | “0123456789”[::-2] | “97531” | 字符串、列表、元组 |</p>
<ul>
<li><strong>切片</strong> 使用 <strong>索引值</strong> 来限定范围，从一个大的 <strong>字符串</strong> 中 <strong>切出</strong> 小的 <strong>字符串</strong></li>
<li><strong>列表</strong> 和 <strong>元组</strong> 都是 <strong>有序</strong> 的集合，都能够 <strong>通过索引值</strong> 获取到对应的数据</li>
<li><strong>字典</strong> 是一个 <strong>无序</strong> 的集合，是使用 <strong>键值对</strong> 保存数据</li>
</ul>
<h3 id="5-3-运算符"><a href="#5-3-运算符" class="headerlink" title="5.3 运算符"></a>5.3 运算符</h3><table>
<thead>
<tr>
<th align="center">运算符</th>
<th>Python 表达式</th>
<th>结果</th>
<th>描述</th>
<th>支持的数据类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td>[1, 2] + [3, 4]</td>
<td>[1, 2, 3, 4]</td>
<td>合并</td>
<td>字符串、列表、元组</td>
</tr>
<tr>
<td align="center">*</td>
<td>[“Hi!”] * 4</td>
<td>[‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’]</td>
<td>重复</td>
<td>字符串、列表、元组</td>
</tr>
<tr>
<td align="center">in</td>
<td>3 in (1, 2, 3)</td>
<td>True</td>
<td>元素是否存在</td>
<td>字符串、列表、元组、字典</td>
</tr>
<tr>
<td align="center">not in</td>
<td>4 not in (1, 2, 3)</td>
<td>True</td>
<td>元素是否不存在</td>
<td>字符串、列表、元组、字典</td>
</tr>
<tr>
<td align="center">&gt; &gt;= == &lt; &lt;=</td>
<td>(1, 2, 3) &lt; (2, 2, 3)</td>
<td>True</td>
<td>元素比较</td>
<td>字符串、列表、元组</td>
</tr>
</tbody></table>
<p><strong>注意</strong></p>
<ul>
<li><code>in</code> 在对 <strong>字典</strong> 操作时，判断的是 <strong>字典的键</strong></li>
<li><code>in</code> 和 <code>not in</code> 被称为 <strong>成员运算符</strong></li>
</ul>
<h4 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h4><p>成员运算符用于 <strong>测试</strong> 序列中是否包含指定的 <strong>成员</strong></p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>in</td>
<td>如果在指定的序列中找到值返回 True，否则返回 False</td>
<td><code>3 in (1, 2, 3)</code> 返回 <code>True</code></td>
</tr>
<tr>
<td>not in</td>
<td>如果在指定的序列中没有找到值返回 True，否则返回 False</td>
<td><code>3 not in (1, 2, 3)</code> 返回 <code>False</code></td>
</tr>
</tbody></table>
<p>注意：在对 <strong>字典</strong> 操作时，判断的是 <strong>字典的键</strong></p>
<h3 id="5-4-完整的-for-循环语法"><a href="#5-4-完整的-for-循环语法" class="headerlink" title="5.4 完整的 for 循环语法"></a>5.4 完整的 for 循环语法</h3><ul>
<li>在 <code>Python</code> 中完整的 <code>for 循环</code> 的语法如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> 集合:</span><br><span class="line">    </span><br><span class="line">    循环体代码</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    没有通过 <span class="keyword">break</span> 退出循环，循环结束后，会执行的代码</span><br></pre></td></tr></table></figure>

<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>在 <strong>迭代遍历</strong> 嵌套的数据类型时，例如 <strong>一个列表包含了多个字典</strong></li>
<li>需求：要判断 某一个字典中 是否存在 指定的 值 <ul>
<li>如果 <strong>存在</strong>，提示并且退出循环</li>
<li>如果 <strong>不存在</strong>，在 <strong>循环整体结束</strong> 后，希望 <strong>得到一个统一的提示</strong></li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">students = [</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"阿土"</span>,</span><br><span class="line">     <span class="string">"age"</span>: <span class="number">20</span>,</span><br><span class="line">     <span class="string">"gender"</span>: <span class="literal">True</span>,</span><br><span class="line">     <span class="string">"height"</span>: <span class="number">1.7</span>,</span><br><span class="line">     <span class="string">"weight"</span>: <span class="number">75.0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"小美"</span>,</span><br><span class="line">     <span class="string">"age"</span>: <span class="number">19</span>,</span><br><span class="line">     <span class="string">"gender"</span>: <span class="literal">False</span>,</span><br><span class="line">     <span class="string">"height"</span>: <span class="number">1.6</span>,</span><br><span class="line">     <span class="string">"weight"</span>: <span class="number">45.0</span>&#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">find_name = <span class="string">"阿土"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> stu_dict <span class="keyword">in</span> students:</span><br><span class="line"></span><br><span class="line">    print(stu_dict)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断当前遍历的字典中姓名是否为find_name</span></span><br><span class="line">    <span class="keyword">if</span> stu_dict[<span class="string">"name"</span>] == find_name:</span><br><span class="line">        print(<span class="string">"找到了"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果已经找到，直接退出循环，就不需要再对后续的数据进行比较</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"没有找到"</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"循环结束"</span>)</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python列表</tag>
        <tag>python元组</tag>
        <tag>python字典</tag>
        <tag>python字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Cookie &amp; Session</title>
    <url>/2020/04/26/Java/2.JavaWeb/10.Cookie&amp;Session/</url>
    <content><![CDATA[<p>会话：浏览器第一次给服务器发送请求，会话建立，直到有一方断开为止</p>
<p>功能：在<strong>一次会话的多次请求</strong>中<strong>共享数据</strong></p>
<p>Cookie：客户端会话技术</p>
<p>Session：服务器端会话技术</p>
<a id="more"></a>


<h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p><strong>概念：</strong>客户端会话技术，将数据保存在客户端</p>
<p><strong>使用：</strong></p>
<ol>
<li><p>创建 Cookie 对象</p>
<p><code>Cookie cookie = new Cookie(&quot;msg&quot;, &quot;hellocookie&quot;);</code></p>
<blockquote>
<p>发现一个小问题：</p>
<p>Cookie对象的 value 字符串中不能有空格，不知缘由。。。</p>
</blockquote>
</li>
<li><p>发送 Cookie 到客户端</p>
<p><code>response.addCookie(cookie);</code></p>
</li>
<li><p>接收其它请求中携带的 Cookie，</p>
<p><code>Cookie[] cookies = request.getCookies();</code></p>
</li>
</ol>
<p><strong>原理：</strong></p>
<blockquote>
<p>Cookie 是基于响应头 <code>Set-Cookie</code> 和请求头 <code>Cookie</code> 来实现的</p>
</blockquote>
<p>发送 Cookie 到客户端：</p>
<ul>
<li>在响应头里面有：<code>Set-Cookie: msg=hellocookie</code></li>
<li>当浏览器看到 Set-Cookie 响应头时，会把该响应头的内容存到浏览器中</li>
</ul>
<p>再次发送其它请求时会携带浏览器中存储的所有 Cookie</p>
<ul>
<li>请求头中有：<code>Cookie: msg=hellocookie</code></li>
</ul>
<p><strong>Cookie 细节：</strong></p>
<ol>
<li><p>一次可不可以发送多个 Cookie</p>
<p>可以，创建多个 Cookie 对象，多次调用<code>response.addCookie(cookie);</code></p>
</li>
<li><p>Cookie 在浏览器的存活时间</p>
<ul>
<li><p>默认情况下，浏览器关闭，Cookie 数据销毁</p>
</li>
<li><p>持久化存储</p>
<ul>
<li><p><code>cookie.setMaxAge(int seconds)</code></p>
<p>正数：Cookie存储到文件中，文件存在的时间（秒）</p>
<p>负数：默认情况，浏览器关闭，Cookie数据销毁</p>
<p>0：删除Cookie</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Cookie 可不可以存中文</p>
<ul>
<li>在 Tomcat 8 之前，不能直接存储中文<ul>
<li>需要将中文数据转码，一般转为 url 编码</li>
</ul>
</li>
<li>在 Tomcat 8 之后，可以直接存储中文</li>
</ul>
</li>
<li><p>Cookie 共享数据的范围</p>
<ul>
<li><p>在一个 Tomcat 服务器中部署的多个项目中共享数据？</p>
<ul>
<li><p>默认情况下不能</p>
</li>
<li><p><code>setPath(String path)</code>设置同一个服务器中 Cookie 的获取范围，默认为当前虚拟目录</p>
<p><code>setPath(&quot;/&quot;)</code> –&gt; 设置获取范围为当前服务器</p>
</li>
</ul>
</li>
<li><p>在不同的 Tomcat 服务器中共享数据</p>
<p><code>setDomain(String path)</code> –&gt; 设置一级域名相同，多个服务器之间的 Cookie 可以共享</p>
</li>
</ul>
</li>
</ol>
<p><strong>Cookie的特点及作用：</strong></p>
<ul>
<li>特点：<ul>
<li>cookie存储在浏览器中（不安全）</li>
<li>浏览器对 <strong>单个cookie的大小</strong> 及 <strong>同一域名下cookie的总数量</strong> 都有限制</li>
</ul>
</li>
<li>作用：<ul>
<li>存储少量不敏感的数据</li>
<li>在不登录的情况下，完成服务器对客户端的身份识别</li>
</ul>
</li>
</ul>
<h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><p>概念：服务器端会话技术，在<strong>一次会话</strong>的<strong>多次请求</strong>间共享数据，将数据保存在服务器的 <strong>HttpSession 对象</strong>中</p>
<p>使用：</p>
<ul>
<li><p>获取 HttpSession 对象：</p>
<p><code>HttpSession session = request.getSession();</code></p>
</li>
<li><p>使用 HttpSession 对象存取数据：</p>
<ul>
<li>存储数据：<code>setAttribute(String name, Object Value);</code></li>
<li>获取数据：<code>getSttribute(String name);</code></li>
<li>移除数据：<code>removeAttribute(String name);</code></li>
</ul>
</li>
</ul>
<p>原理：</p>
<p>Session 是<strong>依赖于 Cookie</strong> 实现的：</p>
<ol>
<li>使用 <code>request.getSession()</code> 获取 Session 对象</li>
<li>Session 对象使用 <code>session.getId()</code> 获取 SessionId （String）</li>
<li>服务器通过 HTTP 响应头 <code>Set-Cookie: JSESSIONID=8E56ADBC35</code></li>
<li>同一次会话的其他请求访问服务器时，请求头 <code>Cookie: JSESSIONID=8E56ADBC35</code></li>
</ol>
<blockquote>
<p>Session 在服务器中是 <strong>单例</strong> 的</p>
<p>单例也是通过 Cookie 来实现的</p>
</blockquote>
<p>Session 的细节：</p>
<ol>
<li><p>客户端关闭，服务器不关闭，两次获取的 Session 是否为同一个？</p>
<ul>
<li><p>默认情况下不是同一个，因为不是同一次会话了</p>
</li>
<li><p>如果想要是同一个，可以单独创建 Cookie，键名为 <code>JSESSIONID</code>，值为 <code>session.getId()</code>，并设置 <code>cookie.setMaxAge(int second)</code></p>
<p><code>Cookie cookie = new Cookie(&quot;JSESSIONID&quot;, session.getId())</code></p>
<p><code>cookie.setMaxAge(int second)</code></p>
</li>
</ul>
</li>
<li><p>客户端不关闭，服务器关闭，两次获取的 Session 是同一个吗</p>
<p>两次获取的 Session 对象不是同一个，但是要确保两个对象中的数据是一致的</p>
<ul>
<li>Session 的钝化：在服务器正常关闭之前，将 Session 对象序列化到硬盘上</li>
<li>Session 的活化：在服务器启动后，将硬盘上的 Session 文件转化为内存中的 Session 对象</li>
</ul>
<blockquote>
<p>Tomcat 可以自动完成 Session 的钝化和活化，但是 idea 不可以</p>
</blockquote>
</li>
<li><p>Session 对象的销毁：</p>
<ul>
<li><p>服务器关闭</p>
</li>
<li><p>Session 对象调用 <code>invalidate()</code>方法</p>
</li>
<li><p>Session 的默认失效时间为 30 min</p>
<p>可以在 web.xml 中自定义 Session 的失效时间：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--单位为分钟--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>60<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ol>
<blockquote>
<p>Session 和 Cookie 的区别</p>
<ol>
<li>Session 数据存储在服务器，Cookie 存储在客户端</li>
<li>Session 数据大小没有限制，Cookie 有限制</li>
<li>Session 数据安全，Sookie 相对来说不太安全</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Cookie</tag>
        <tag>Session</tag>
      </tags>
  </entry>
  <entry>
    <title>Python异常</title>
    <url>/2020/04/25/Python/Python_new/python%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<p>Python处理异常以及捕获异常</p>
<a id="more"></a>



<h3 id="处理异常的基础语法："><a href="#处理异常的基础语法：" class="headerlink" title="处理异常的基础语法："></a>处理异常的基础语法：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 要执行的代码，可能存在异常</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="comment"># 出现异常时，要执行的操作</span></span><br></pre></td></tr></table></figure>



<h3 id="按照错误类型捕获异常："><a href="#按照错误类型捕获异常：" class="headerlink" title="按照错误类型捕获异常："></a>按照错误类型捕获异常：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 要执行的代码，可能存在异常</span></span><br><span class="line"><span class="keyword">except</span> 错误类型<span class="number">1</span>:</span><br><span class="line">    <span class="comment"># 出现这种类型异常时，要执行的操作</span></span><br><span class="line"><span class="keyword">except</span> 错误类型<span class="number">2</span>:</span><br><span class="line">    <span class="comment"># 出现这种类型异常时，要执行的操作</span></span><br></pre></td></tr></table></figure>



<h3 id="捕获未知异常："><a href="#捕获未知异常：" class="headerlink" title="捕获未知异常："></a>捕获未知异常：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 要执行的代码，可能存在异常</span></span><br><span class="line"><span class="keyword">except</span> 错误类型:</span><br><span class="line">    <span class="comment"># 出现这种类型异常时，要执行的操作</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">    print(<span class="string">"未知错误：%s"</span> % result)</span><br></pre></td></tr></table></figure>



<h3 id="处理异常的完整语法："><a href="#处理异常的完整语法：" class="headerlink" title="处理异常的完整语法："></a>处理异常的完整语法：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 要执行的代码，可能存在异常</span></span><br><span class="line"><span class="keyword">except</span> 错误类型<span class="number">1</span>:</span><br><span class="line">    <span class="comment"># 出现这种类型异常时，要执行的操作</span></span><br><span class="line"><span class="keyword">except</span> (错误类型<span class="number">2</span>, 错误类型<span class="number">3</span>):</span><br><span class="line">    <span class="comment"># 出现这2种类型异常时，要执行的操作</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">    print(<span class="string">"未知错误：%s"</span> % result)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 没有异常才会执行 else 中的代码</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># 无论是否有异常，都会执行的代码</span></span><br></pre></td></tr></table></figure>



<h3 id="异常的传递性："><a href="#异常的传递性：" class="headerlink" title="异常的传递性："></a>异常的传递性：</h3><ul>
<li><p>当函数出现异常时，程序不会立即终止，异常会被<strong>传递到调用函数</strong>的地方</p>
</li>
<li><p>如果异常传递到主程序，仍然没有被处理，程序才会终止</p>
</li>
</ul>
<h3 id="主动抛出异常："><a href="#主动抛出异常：" class="headerlink" title="主动抛出异常："></a>主动抛出异常：</h3><p>Python 中的异常类：<code>Exception</code></p>
<p>抛出异常关键字：<code>raise</code></p>
<p>主动抛出异常实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个 Exception 对象</span></span><br><span class="line">ex = Exception(<span class="string">"自定义异常"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 raise 抛出异常</span></span><br><span class="line"><span class="keyword">raise</span> ex</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python异常</tag>
      </tags>
  </entry>
  <entry>
    <title>Python文件操作</title>
    <url>/2020/04/25/Python/Python_new/Python%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>Python 操作文件的步骤: 打开文件 –&gt; 读/写 –&gt; 关闭文件</p>
<a id="more"></a>



<h3 id="Python-操作文件的步骤："><a href="#Python-操作文件的步骤：" class="headerlink" title="Python 操作文件的步骤："></a>Python 操作文件的步骤：</h3><ol>
<li><p>打开文件</p>
<ul>
<li><code>file = open(&quot;filename&quot;, &quot;访问方式&quot;)</code></li>
<li><code>open()</code>函数打开文件，会返回文件操作对象</li>
</ul>
</li>
<li><p>操作文件</p>
<ul>
<li><p>读</p>
<ul>
<li><p><code>file.read()</code></p>
</li>
<li><p><code>read()</code>方法可以一次性读入并返回<strong>文件的全部内容</strong></p>
</li>
</ul>
</li>
<li><p>写 <code>file.write()</code></p>
</li>
</ul>
</li>
<li><p>关闭文件</p>
<ul>
<li><code>file.close()</code></li>
</ul>
</li>
</ol>
<h3 id="文件指针"><a href="#文件指针" class="headerlink" title="文件指针"></a>文件指针</h3><p>读取文件的时候，会有一个指针标记从哪个位置开始读取数据</p>
<p>第一次打开文件时，文件指针会指向文件的开始位置</p>
<p>执行了 <code>read</code> 方法后，文件指针会移动到文件末尾</p>
<h3 id="文件的访问方式"><a href="#文件的访问方式" class="headerlink" title="文件的访问方式"></a>文件的访问方式</h3><blockquote>
<p>open 默认以<strong>只读</strong>方式打开文件</p>
</blockquote>
<table>
<thead>
<tr>
<th>访问方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>以<strong>只读</strong>方式打开文件，如果文件不存在，则报错</td>
</tr>
<tr>
<td>w</td>
<td>以<strong>只写</strong>方式打开文件，如果文件存在，则会被覆盖；如果文件不存在，则会创建新的文件</td>
</tr>
<tr>
<td>a</td>
<td>以<strong>追加写</strong>方式打开文件，如果文件存在，则从文件末尾追加写入，如果文件不存在，则创建新文件</td>
</tr>
<tr>
<td>r+</td>
<td>以<strong>读写</strong>方式打开文件，其他同 r</td>
</tr>
<tr>
<td>w+</td>
<td>以<strong>读写</strong>方式打开文件，其他同 w</td>
</tr>
<tr>
<td>a+</td>
<td>以<strong>读写</strong>方式打开文件，其他同 a</td>
</tr>
</tbody></table>
<blockquote>
<p>开发中常用只读，只写的方式操作文件</p>
</blockquote>
<h3 id="按行读取文件"><a href="#按行读取文件" class="headerlink" title="按行读取文件"></a>按行读取文件</h3><p><code>file.readline()</code></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python文件</tag>
      </tags>
  </entry>
  <entry>
    <title>Python模块&amp;包</title>
    <url>/2020/04/24/Python/Python_new/Python%E6%A8%A1%E5%9D%97&amp;%E5%8C%85/</url>
    <content><![CDATA[<p>模块是工具的集合, 包是模块的集合</p>
<a id="more"></a>



<p>模块的概念:</p>
<p>导入模块:</p>
<ul>
<li><p><code>import 模块名</code></p>
<p>直接导入模块 (会导入模块中的全部工具)</p>
<p>使用: <code>模块名.工具名</code></p>
</li>
<li><p><code>import 模块名 as 别名</code></p>
<p>直接导入模块,并给模块起别名</p>
<p>使用: <code>别名.工具名</code></p>
</li>
</ul>
<ul>
<li><p><code>from 模块名 import 工具名</code></p>
<p>从模块中导入指定工具</p>
<p>使用: <code>工具名</code></p>
</li>
<li><p><code>from 模块名 import *</code>  (<strong>不推荐使用</strong>, 导入多个模块时, 无法提示重名情况)</p>
<p>从模块中导入全部工具</p>
<p>使用: <code>工具名</code></p>
</li>
</ul>
<p>模块的搜索顺序:</p>
<ol>
<li>会根据模块名, 先在 <strong>当前目录</strong> 找指定文件, 如果有则直接导入</li>
<li>如果当前目录没有, 会到 <strong>系统目录</strong> 中搜索</li>
</ol>
<blockquote>
<p>给文件起名时, 不要与系统模块重名</p>
<p><code>模块名.__file__</code> (内置属性) 可以查看模块的完整路径</p>
</blockquote>
<p><code>__name__</code> 属性:</p>
<p><code>__name__</code> 属性是Python的一个内置属性, 其中记录着一个字符串</p>
<p>字符串会有两种值: </p>
<ul>
<li>如果是当前执行的程序: <code>__name__ == &quot;__main__&quot;</code></li>
<li>如果是被其他文件导入: <code>__name__ == 模块名</code></li>
</ul>
<p>通常用法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入模块</span></span><br><span class="line"><span class="comment"># 定义全局变量</span></span><br><span class="line"><span class="comment"># 定义函数</span></span><br><span class="line"><span class="comment"># 定义类</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 测试相关代码</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 __name__ 判断,如果是当前文件执行,则调用测试代码</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>





<h3 id="安装第三方模块"><a href="#安装第三方模块" class="headerlink" title="安装第三方模块"></a>安装第三方模块</h3><p><code>pip install 模块名</code></p>
<h3 id="Python包"><a href="#Python包" class="headerlink" title="Python包"></a>Python包</h3><p><strong>概念：</strong></p>
<ul>
<li>包是一个包含<strong>多个模块</strong>的<strong>特殊目录</strong></li>
<li>包目录中必须有一个文件：<code>__init__.py</code></li>
<li>包名的命名方式和变量名一致</li>
</ul>
<p>包相较于模块的<strong>优势</strong>：</p>
<p>可以使用 <code>import 包名</code> 一次性导入包中的<strong>所有模块</strong></p>
<p><code>__init__.py</code> 文件：</p>
<p>在 <code>__init__.py</code> 文件中指定要对外界提供的模块的列表</p>
<p>写法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> 模块名<span class="number">1</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> 模块名<span class="number">2</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>



<p>外界使用包：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> 包名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过包调用模块中的相关函数</span></span><br><span class="line">包名.模块名.函数名()</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python模块</tag>
      </tags>
  </entry>
  <entry>
    <title>Python面向对象</title>
    <url>/2020/04/22/Python/Python_new/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>只有一些入门, 待后续深入…</p>
<a id="more"></a>





<blockquote>
<p>dir 内置函数：</p>
<p>Python 中的一切皆对象，像变量、函数等都是对象</p>
<p><code>dir(标识符/数据)</code> 可以查看对象内的所有属性和方法</p>
<p><code>__方法/属性名__</code> ：在方法/属性名前面和后面都有<strong>两个下划线</strong>的格式，是 Python 为该对象提供的<strong>内置</strong>方法/属性</p>
</blockquote>
<h3 id="定义类-amp-创建对象"><a href="#定义类-amp-创建对象" class="headerlink" title="定义类&amp;创建对象"></a>定义类&amp;创建对象</h3><p>定义类：</p>
<ul>
<li>类名的命名规则：大驼峰</li>
<li>类中定义方法时，第一个参数必须是 <code>self</code>（相当于 <code>this</code>）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> 方法1<span class="params">(self, 参数列表)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> 方法2<span class="params">(self, 参数列表)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>



<p>创建对象：</p>
<p><code>对象变量 = 类名()</code></p>
<p>创建对象的过程：</p>
<ol>
<li>在内存中为对象 分配空间</li>
<li>自动调用 <code>__init__</code> 方法（相当于 <u>构造函数</u>），为属性设置初始值</li>
</ol>
<h3 id="对象的内置方法"><a href="#对象的内置方法" class="headerlink" title="对象的内置方法"></a>对象的内置方法</h3><p><code>__del__</code> 方法，对象销毁之前自动调用的方法 (相当于 Java <code>destroy</code>)</p>
<p><code>__str__</code> 方法，使用该方法可以自定义 <code>print(对象)</code> 输出的内容 (相当于 Java <code>toString</code>)</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Python高级</title>
    <url>/2020/04/20/Python/Python_new/Python%E9%AB%98%E7%BA%A7/</url>
    <content><![CDATA[<p>变量\返回值\参数</p>
<a id="more"></a>



<h3 id="可变类型和不可变类型："><a href="#可变类型和不可变类型：" class="headerlink" title="可变类型和不可变类型："></a>可变类型和不可变类型：</h3><ol>
<li>不可变类型：<ul>
<li>数字</li>
<li>字符串</li>
<li>元组</li>
</ul>
</li>
<li>可变类型：<ul>
<li>列表</li>
<li>字典</li>
</ul>
</li>
</ol>
<ul>
<li><p>可变类型调用方法时，改变的是自身（如：列表）</p>
</li>
<li><p>不可变类型调用方法时，自身不变，生成一个新的（如：字符串）</p>
</li>
</ul>
<blockquote>
<p>字典的 <code>key</code> 只能使用不可变类型的数据</p>
</blockquote>
<h3 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h3><ul>
<li><p>全局变量：定义在函数外部的变量</p>
<ul>
<li><p>在所有的函数中都可以使用全局变量</p>
</li>
<li><p>在 Python中，函数内部不能修改全局变量</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">()</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 这里的 num 只是定义的一个局部变量，并不是修改全局变量</span></span><br><span class="line">    <span class="comment"># 如果想在函数内部修改全局变量，使用 global 关键字声明一下全局变量</span></span><br><span class="line">    <span class="comment"># global num</span></span><br><span class="line">    num = <span class="number">66</span></span><br><span class="line">    print(num)  <span class="comment"># 输出 66</span></span><br></pre></td></tr></table></figure>

<ul>
<li>所有的全局变量 定义在 所有的函数 上方</li>
<li>全局变量命名时一般会有一些特殊规则，如变量名前加 <code>g_</code> 或 <code>gl_</code></li>
</ul>
</li>
<li><p>局部变量：定义在函数内部的变量</p>
</li>
</ul>
<h3 id="函数的返回值："><a href="#函数的返回值：" class="headerlink" title="函数的返回值："></a>函数的返回值：</h3><p>函数如果要返回多个数据时，可以使用元组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">measure</span><span class="params">()</span>:</span></span><br><span class="line">    temp = <span class="number">23</span></span><br><span class="line">    wetness = <span class="number">50</span></span><br><span class="line">    <span class="comment"># 如果返回值为元组，小括号可以省略</span></span><br><span class="line">    <span class="keyword">return</span> temp, wetness</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果函数的返回值是元组，可以使用 多个变量（数量与元组元素数量一致）来接收函数的返回结果</span></span><br><span class="line">gl_temp, gl_wetness = measure()</span><br><span class="line">print(gl_temp)</span><br><span class="line">print(gl_wetness)</span><br></pre></td></tr></table></figure>



<h3 id="函数的参数："><a href="#函数的参数：" class="headerlink" title="函数的参数："></a>函数的参数：</h3><blockquote>
<p>在函数中修改参数对外部变量的影响：</p>
<ol>
<li>在函数内部对参数赋值，不会影响外部变量</li>
<li>如果传入的参数是可变类型数据，在函数内部使用方法修改了数据的内容，会影响到外部变量</li>
</ol>
<blockquote>
<p>列表变量使用 <code>+=</code> ,相当于调用了列表的 <code>extend</code> 方法，同样会影响外部变量</p>
</blockquote>
</blockquote>
<h4 id="缺省参数："><a href="#缺省参数：" class="headerlink" title="缺省参数："></a>缺省参数：</h4><p>定义函数时，可以个某个参数指定一个默认值，<strong>具有默认值</strong>的参数就叫缺省参数</p>
<p><strong>缺省参数的注意事项：</strong></p>
<ul>
<li>缺省参数，应该使用<strong>最常见的值</strong>作为默认值</li>
<li>缺省参数必须定义在参数列表的末尾</li>
<li>调用含有多个缺省参数的函数时，需要指定参数名</li>
</ul>
<h4 id="多值参数：（-Java中的可变参数-）"><a href="#多值参数：（-Java中的可变参数-）" class="headerlink" title="多值参数：（ Java中的可变参数 ）"></a>多值参数：（ Java中的可变参数 ）</h4><p>Python中有两种多值参数：</p>
<ul>
<li>参数名前增加  <code>*</code> ，可以接收<strong>元组</strong>  –&gt;  <code>*args</code></li>
<li>参数名前增加  <code>**</code> ，可以接收<strong>字典</strong>  –&gt;  <code>**kwargs</code></li>
</ul>
<p><strong>元组和字典的拆包：</strong></p>
<p>在调用带有多值参数的函数时，如果希望：</p>
<ul>
<li>将一个 元组变量，直接传递给 <code>args</code></li>
<li>将一个 字典变量，直接传递给 <code>kwargs</code></li>
</ul>
<p>就需要使用拆包，拆包方式：</p>
<ul>
<li>在元组变量前，增加 <code>*</code></li>
<li>在字典变量前，增加 <code>**</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    </span><br><span class="line">    print(args)</span><br><span class="line">    print(kwargs)</span><br><span class="line">    </span><br><span class="line">gl_nums = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">gl_people = &#123;<span class="string">"name"</span>:<span class="string">"zhangsan"</span>, <span class="string">"age"</span>:<span class="number">18</span>&#125;</span><br><span class="line"></span><br><span class="line">demo(*gl_num, **gl_people)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python高级</tag>
      </tags>
  </entry>
  <entry>
    <title>Request &amp; Response</title>
    <url>/2020/03/26/Java/2.JavaWeb/9.Request&amp;Response/</url>
    <content><![CDATA[<p>request 对象和 response 对象是由<strong>服务器创建</strong>，我们直接使用<br>request 对象用来获取<strong>请求消息</strong>；response 对象用来设置<strong>响应消息</strong></p>
<a id="more"></a>


<h1 id="request-对象"><a href="#request-对象" class="headerlink" title="request 对象"></a>request 对象</h1><h3 id="request-对象获取请求消息："><a href="#request-对象获取请求消息：" class="headerlink" title="request 对象获取请求消息："></a>request 对象获取请求消息：</h3><ol>
<li><p>获取请求行中的数据：</p>
<ul>
<li><p>获取请求方式：<code>String getMethod()</code></p>
</li>
<li><p>★获取虚拟目录：<code>String getContextPath()</code></p>
<ul>
<li>也就是项目的根路径</li>
</ul>
</li>
<li><p>★获取 Servlet 路径：<code>String getServletPath()</code></p>
<ul>
<li>也就是能和 url-patten 中完全匹配的路径（ * 不算）</li>
</ul>
</li>
<li><p>获取 get 请求方式的请求参数：<code>String getQueryString()</code></p>
</li>
<li><p>★获取 URI / URL：</p>
<p><code>String getRequestURI()</code></p>
<p><code>StringBuffer getRequestURL()</code></p>
</li>
<li><p>获取协议及版本：<code>String getProtocol()</code></p>
</li>
<li><p>获取客户端的 IP 地址：<code>String getRemoteAddr()</code></p>
</li>
</ul>
</li>
<li><p>获取请求头中的数据</p>
<ul>
<li>★<code>String getHeader(String name)</code>：根据请求头名称获取请求头的值</li>
<li><code>Enumeration&lt;String&gt; getHeaderNames()</code>：获取所有请求头名称</li>
</ul>
</li>
<li><p>获取请求体中的数据</p>
<blockquote>
<p>只有POST请求才有请求体，在请求体中封装了POST请求的请求参数</p>
</blockquote>
<p>获取数据的步骤：</p>
<ol>
<li>获取流对象<ul>
<li><code>BufferReader getReader()</code>: 获取字符输入流，只能操作字符数据</li>
<li><code>ServletInputStream getInputStream()</code>: 获取字节输入流，可以操作所有类型数据</li>
</ul>
</li>
<li>再从流中拿数据</li>
</ol>
</li>
</ol>
<h3 id="request-对象获取请求参数："><a href="#request-对象获取请求参数：" class="headerlink" title="request 对象获取请求参数："></a>request 对象获取请求参数：</h3><blockquote>
<p><strong>页面参数的传递：</strong></p>
<p><code>url?key1=value1&amp;key2=value2</code></p>
<p>参数是以<code>键值对</code>的方式进行提交（get和post都是）</p>
<p>两者不同的是：get 使用 <code>?</code> 将参数挂在 url 后面，post 则是隐式提交</p>
</blockquote>
<ul>
<li><code>String getParameter(String name)</code>: 根据参数名获取<strong>参数值</strong></li>
<li><code>String[] getParameterValues(String name)</code>: 根据参数名获取参数<strong>值的数组</strong>（多选框）</li>
<li><code>Enumeration&lt;String&gt; getParameterNames()</code>: 获取所有请求参数的<strong>名称</strong> （不常用）</li>
<li><code>Map&lt;String, String[]&gt; getParameterMap()</code>: 获取所有请求<strong>参数的map集合</strong> （不常用）</li>
</ul>
<blockquote>
<p>请求参数中有中文，乱码问题：</p>
<ul>
<li>get 方式：Tomcat 8 就已经解决了 get 方式中文乱码的问题</li>
<li>post 方式：获取请求参数之前，设置 request 的编码：<ul>
<li><code>request.setCharacterEncoding(&quot;utf-8&quot;)</code></li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><p><strong>原理：</strong>转发是服务器内部进行资源访问，一次请求，一次响应</p>
<p><strong>语法：</strong><code>request.getRequestDispatcher(&quot;路径&quot;).forward(request,response);</code></p>
<p><strong>注意：</strong></p>
<ul>
<li>转发中的路径为绝对路径去掉 <strong>/项目名</strong>，又称<strong>内部路径</strong></li>
<li>转发后，浏览器地址栏中的<strong>地址不发生变化</strong></li>
<li>转发可以访问到 <strong>WEB-INF</strong> 下的资源</li>
<li>转发只能访问<strong>当前服务器</strong>下的资源</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转发到普通页面</span></span><br><span class="line">request.getRequestDisPatcher(<span class="string">"/index.html"</span>).forward(request,response);</span><br><span class="line"><span class="comment">// 转发到 WEB-INF 下的资源</span></span><br><span class="line">request.getRequestDispatcher(<span class="string">"/WEB-INF/html/index.html"</span>).forward(request,response);</span><br><span class="line"><span class="comment">// 转发到另一个 servlet</span></span><br><span class="line">request.getRequestDispatcher(<span class="string">"/Myservlet2.do"</span>).forward(request,response);</span><br></pre></td></tr></table></figure>



<h3 id="共享数据"><a href="#共享数据" class="headerlink" title="共享数据"></a>共享数据</h3><p><strong>域对象：</strong>一个有作用范围的对象，可以在作用范围内共享数据</p>
<p><strong>request 域对象</strong>：代表一次请求的范围，一般用于请求转发的多个资源中共享数据</p>
<p>方法：</p>
<ul>
<li><code>setAttribute(String name, Object obj)</code>: 存储数据（键值对形式）</li>
<li><code>getAttribute(String name)</code>: 通过键获取值</li>
<li><code>removeAttribute(String name)</code>: 通过键删除数据</li>
</ul>
<h3 id="获取-ServletContext-对象"><a href="#获取-ServletContext-对象" class="headerlink" title="获取 ServletContext 对象"></a>获取 ServletContext 对象</h3><p><code>ServletContext context = request.getServletContext()</code></p>
<br/>

<h1 id="response-对象"><a href="#response-对象" class="headerlink" title="response 对象"></a>response 对象</h1><h3 id="Ⅰ-response-对象设置响应消息："><a href="#Ⅰ-response-对象设置响应消息：" class="headerlink" title="Ⅰ. response 对象设置响应消息："></a>Ⅰ. response 对象设置响应消息：</h3><ol>
<li><p>设置响应行</p>
<p>设置状态码：<code>setStatus(int sc)</code></p>
</li>
<li><p>设置响应头</p>
<p><code>setHeader(String name, String value)</code></p>
</li>
<li><p>设置响应体</p>
<ul>
<li><p>获取输出流</p>
<ul>
<li><p>字符输出流：<code>PrintWriter getWriter()</code></p>
</li>
<li><p>字节输出流：<code>ServletOutputStream getOutputStream()</code></p>
</li>
</ul>
</li>
<li><p>使用输出流，将数据输出到浏览器</p>
</li>
</ul>
</li>
</ol>
<h3 id="Ⅱ-重定向"><a href="#Ⅱ-重定向" class="headerlink" title="Ⅱ. 重定向"></a>Ⅱ. 重定向</h3><p><strong>原理：</strong> 重定向是服务器响应重定向资源的路径，浏览器再根据响应的路径访问资源，<strong>两次请求，两次响应</strong></p>
<blockquote>
<p>第一次请求时，服务器返回给浏览器的内容：</p>
<ol>
<li>状态码：302，告诉浏览器进行重定向</li>
<li>响应头：<code>location:重定向资源的路径</code></li>
</ol>
</blockquote>
<p><strong>语法：</strong><code>response.sendRedirect(&quot;路径&quot;);</code></p>
<p><strong>注意：</strong></p>
<ul>
<li>重定向的路径为传统的<strong>绝对路径</strong></li>
<li>重定向后，浏览器地址栏中的地址会变为<strong>重定向后的地址</strong></li>
<li>重定向<strong>不能</strong>够访问 WEB-INF 下的资源</li>
<li>重定向可以访问到<strong>其他服务器</strong>的资源</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重定向到普通页面</span></span><br><span class="line">response.sendRedirect(<span class="string">"/2_Servlet/index.html"</span>);</span><br><span class="line"><span class="comment">// 重定向到另一个 servlet</span></span><br><span class="line">response.sendRedirect(<span class="string">"/2_servlet/Myservlet4.do"</span>);</span><br></pre></td></tr></table></figure>


<blockquote>
<p>绝对路径和相对路径: （一般情况下都是使用 绝对路径）</p>
<ul>
<li><p>相对路径（通过相对路径不可以确定唯一资源）</p>
<ul>
<li><p>如：<code>./index.html</code></p>
</li>
<li><p>不以 <code>/</code> 开头，以 <code>.</code> 开头</p>
</li>
<li><p>书写技巧：找到当前资源和目标资源的相对位置关系</p>
<ul>
<li><code>./</code>: 当前目录</li>
<li><code>../</code>: 后退一级目录</li>
</ul>
</li>
</ul>
</li>
<li><p>绝对路径（通过绝对路径可以确定唯一资源）</p>
<ul>
<li>如：<code>/day01/responseDemo02</code></li>
<li>以 <code>/</code> 开头</li>
<li>书写技巧：判断定义的路径是谁使用（判断请求从哪发出）<ul>
<li>浏览器使用(浏览器发出请求)：需要加虚拟目录（重定向，html中 a标签，form表单，）</li>
<li>服务器使用(服务器发出请求)：不需要加虚拟目录（转发操作）</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="Ⅲ-response-输出数据"><a href="#Ⅲ-response-输出数据" class="headerlink" title="Ⅲ. response 输出数据"></a>Ⅲ. response 输出数据</h3><p>在创建流之前，可以加一行<strong>字符编码设置信息</strong>，预防字符乱码</p>
<p><code>response.setContentType(&quot;text/html;charset=utf-8&quot;);</code></p>
<p><strong>使用步骤：</strong></p>
<ol>
<li>输出字符数据</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取字符输出流(流名称: out 约定俗成)</span></span><br><span class="line">PrintWriter out = response.getWriter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用流 输出信息</span></span><br><span class="line">out.write(<span class="string">"要输出的字符信息"</span>);</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>输出字节数据</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取字节输出流</span></span><br><span class="line">ServletOutputStream out = response.getOutputStream();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出信息</span></span><br><span class="line">out.write(<span class="string">"要输出的字节信息"</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Request</tag>
        <tag>Response</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP</title>
    <url>/2020/03/24/Java/2.JavaWeb/6.HTTP/</url>
    <content><![CDATA[<p>互联网三大基石之一</p>
<a id="more"></a>

<h2 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h2><p><strong>概念：</strong>超文本传输协议（Hyper Text Transfer Protocol）</p>
<p><strong>作用：</strong>规范了浏览器和服务器的数据交互的格式</p>
<p><strong>特点：</strong></p>
<ul>
<li>基于 TCP/IP 的高级协议</li>
<li>默认端口号为 80</li>
<li>基于请求/响应模型：一次请求对应一次响应</li>
<li>无状态：每次请求之间相互独立</li>
</ul>
<p>历史版本：</p>
<ul>
<li>1.0：每一次请求都会建立一个新的连接</li>
<li>1.1：连接可复用</li>
</ul>
<p><strong>HTTP的交互流程：</strong></p>
<ol>
<li><p>客户端与服务器端建立连接</p>
</li>
<li><p>客户端发送<strong>请求</strong>数据到服务器端</p>
</li>
<li><p>服务器端接收到请求后进行处理，然后将处理结果<strong>响应</strong>客户端</p>
</li>
<li><p>关闭客户端与服务器端的连接（HTTP 1.1 之后不会马上关闭）</p>
</li>
</ol>
<h4 id="HTTP-协议-–-请求格式："><a href="#HTTP-协议-–-请求格式：" class="headerlink" title="HTTP 协议 – 请求格式："></a>HTTP 协议 – 请求格式：</h4><p>结构：</p>
<ul>
<li><p><strong>请求行：</strong>请求方式、请求地址（url）、HTTP 协议版本</p>
<p>请求方式：HTTP 协议有 7 种请求方式，主要还是 get 和 post</p>
<ul>
<li>get 请求：<ul>
<li>请求参数会以 <code>?</code> 的形式隔开拼接在请求行中，相对不安全</li>
<li>因为浏览器对 URL 的长度有限制，所以 get 请求不能携带大量数据</li>
<li>没有请求体</li>
</ul>
</li>
<li>post 请求：<ul>
<li>请求数据在请求体中进行发送，相对安全</li>
<li>可以携带大量数据</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>请求头</strong>：消息报头，浏览器告诉服务器的一些信息</p>
<p>常见请求头：</p>
<ul>
<li><p><code>User-Agent</code>：浏览器的版本信息</p>
<p>可以在服务器端获取 User-Agent 的信息，来解决浏览器兼容性的问题</p>
</li>
<li><p><code>Referer</code>：告诉服务器，当前请求从哪里来</p>
<p>作用：防盗链、做相关统计</p>
</li>
</ul>
</li>
<li><p><strong>空行：</strong>用于分隔请求头和请求体，必须要有</p>
</li>
<li><p><strong>请求体：</strong>get 方式没有，post 方式有</p>
</li>
</ul>
<h4 id="HTTP-协议-–-响应格式："><a href="#HTTP-协议-–-响应格式：" class="headerlink" title="HTTP 协议 – 响应格式："></a>HTTP 协议 – 响应格式：</h4><p>结构：</p>
<ul>
<li><p>响应行：HTTP 版本，状态码，状态消息</p>
</li>
<li><p>响应头：消息报头，客户端使用的附加信息</p>
<p>常见响应头：</p>
<ul>
<li><code>Content-Type</code>: 响应体数据格式 及 字符编码</li>
<li><code>Content-disposition</code>: 打开响应体数据的位置<ul>
<li><code>in-line</code>: 默认值，在当前页面打开响应体</li>
<li><code>attachment; filename=xxx</code>: 以附件形式打开响应体（文件下载）</li>
</ul>
</li>
</ul>
</li>
<li><p>空行：响应行和响应实体之间，必须要有</p>
</li>
<li><p>响应体（数据）：正文，服务器返回给浏览器的信息</p>
</li>
</ul>
<p><strong>HTTP 常见响应状态码含义：</strong></p>
<p>HTTP 状态码都是三位数，共分为 5 种类型：</p>
<ul>
<li><code>1**</code>：信息，服务器收到请求，需要请求者继续执行操作</li>
<li><code>2**</code>：成功，操作被成功接收并处理</li>
<li><code>3**</code>：重定向，需要进一步的操作以完成请求</li>
<li><code>4**</code>：客户端错误，请求包含语法错误或无法完成请求</li>
<li><code>5**</code>：服务器错误，服务器在处理请求的过程中发生了错误</li>
</ul>
<p>常见状态码：</p>
<ul>
<li><code>200 OK</code>：客户请求成功</li>
<li><code>302</code>：重定向</li>
<li><code>400 Bad Request</code>：客户端请求有语法错误</li>
<li><code>401 Unauthorized</code>：请求未经授权</li>
<li><code>403 Forbidden</code>：服务器收到请求，但是拒绝提供服务</li>
<li><code>404 Not Found</code>：请求资源找不到了</li>
<li><code>500 Interval Server Error</code>：服务器内部出现了错误</li>
<li><code>503 Server Unavailable</code>：服务器当前不能处理请求，一段时间后可能恢复正常</li>
</ul>
]]></content>
      <categories>
        <category>其他技术</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>idea中使用maven遇到的一些小问题</title>
    <url>/2020/03/20/Java/idea%E4%B8%AD%E4%BD%BF%E7%94%A8maven%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在pom.xml 中导坐标没有提示, 点击<strong>阅读全文</strong>看看如何解决吧.</p>
<a id="more"></a>

<h2 id="idea中使用maven遇到的一些小问题"><a href="#idea中使用maven遇到的一些小问题" class="headerlink" title="idea中使用maven遇到的一些小问题"></a>idea中使用maven遇到的一些小问题</h2><p>idea版本：2019.3.2，maven版本：3.6.1（idea内置maven）</p>
<p>在使用idea构建maven项目，在项目的pom.xml文件中导坐标时，发现<strong>输入之后没有提示了</strong>，之前使用idea的时候没有遇到过这种情况。</p>
<p>首先想到的是maven的问题，因为之前都是使用自己的maven，所以我就去maven官网自己下载了maven 3.6.3版本，但是在idea中配置了自己的maven之后并没有作用，还是不提示。。</p>
<p>去百度，关于没有提示，是因为没有maven索引造成的，大家给出的解决方案都是在idea–&gt;file–&gt;settings–&gt;maven–&gt;repository 中把两个仓库update一下就好了，这是一个建立索引的过程，索引文件夹在 ${用户目录}.IntelliJIdea2019.1\system\Maven\Indices 中。</p>
<p>点击update，local直接完成，<strong>remote一直error，检查发现，是在maven的setting.xml文件中配置了仓库的mirror</strong>，需要先把mirror注释掉，然后再更新remote仓库（需要网络环境良好）</p>
<p>local和remote都update完成之后，再次尝试是否有提示了，发现在手动 ctrl+shift+space 提示，可以出现提示，但是过程非常卡。。。</p>
<p>这时候就又去百度了，看到大家说idea 2019.2 和 maven 的兼容性出了一些问题，导致idea–&gt;file–&gt;settings–&gt;maven–&gt;repository 中没有内容，local和remote都没有。有人也是和我一样的问题，确定是idea版本的问题，大家都说2019.2.x 和2019.3.x bug甚多。</p>
<p>更换版本：idea 2019.3.4，最新的一个release版本（截止2019.3.19），以为idea会把这个小问题给干掉了，结果。。。</p>
<p>更换版本：<strong>idea 2019.1.4</strong>，2019.2 之前的最后一个版本，<strong>一切OK</strong>（这个版本很多朋友都推荐，完全没有maven相关的问题）</p>
]]></content>
      <categories>
        <category>bugfix</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>学习中遇到的问题</title>
    <url>/2020/02/06/%E5%85%B6%E5%AE%83%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>学习和工作中遇到的一些问题及解决过程</p>
<p>避免以后在同一个坑里跌倒</p>
<a id="more"></a>



<h3 id="Mac-OS-配置-Maven-环境变量"><a href="#Mac-OS-配置-Maven-环境变量" class="headerlink" title="Mac OS 配置 Maven 环境变量"></a>Mac OS 配置 Maven 环境变量</h3><ol>
<li><p>maven 下载 tar.gz 格式压缩包 下载完成会自动解压</p>
</li>
<li><p>将解压后的 maven 拖入终端可以得到 maven 解压后的路径</p>
</li>
<li><p>在终端输入 vim ~/.bash_profile</p>
</li>
<li><p>按 i 进入编辑</p>
</li>
<li><p>输入以下命令</p>
<p>MAVEN_HOME=/Users/qiuzhijie/Downloads/apache-maven-3.5.4  （这里是自己的maven路径）PATH=$JAVA_HOME/bin:$MAVEN_HOME/bin:$PATH:</p>
<p>export MAVEN_HOME PATH</p>
</li>
<li><p>按 esc  :wq  保存编辑</p>
</li>
<li><p>终端输入 source .bash_profile</p>
</li>
<li><p>mvn -v 如果有 maven 的信息则说明配置成功</p>
</li>
</ol>
<h3 id="idea-中新建-XML-文件"><a href="#idea-中新建-XML-文件" class="headerlink" title="idea 中新建 XML 文件"></a>idea 中新建 XML 文件</h3><p>idea 中新建 XML 文件时，（如果选的是 <code>File</code> 创建）一定要自己把后缀 <code>.xml</code> 写上。</p>
]]></content>
      <categories>
        <category>bugfix</category>
      </categories>
      <tags>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title>Python数据分析</title>
    <url>/2019/12/10/Python/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>用 Python 做数据分析</p>
<a id="more"></a>



<p>python 做数据分析的几个常用库：numpy，pandas</p>
<h2 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h2><p>Anaconda 是一个基于 conda 的<strong>整合框架</strong>，其中包含了 <strong>Spyder</strong> 和 <strong>IPython</strong></p>
<ul>
<li><p>conda：包管理和环境管理工具</p>
</li>
<li><p>Spyder：一个 Python 的 IDE</p>
</li>
<li><p>IPython：Python 的交互式 shell</p>
<ul>
<li><p>变量<strong>前面</strong>或<strong>后面</strong>加上 <code>?</code>，可以显示变量的一些通用信息，如果是函数会显示源代码</p>
</li>
<li><p><code>%run</code>：运行 python 程序（在一个空的命名空间内运行 python 程序）</p>
<p><code>%run demo.py</code></p>
</li>
<li><p><code>%</code>魔术命令：</p>
<ul>
<li><code>%magic</code>：显示所有魔术命令</li>
<li><code>%hist</code>：显示 IPython 的输入历史</li>
<li><code>pdb</code>：异常发生后自动进入调试器</li>
<li><code>%reset</code>：删除当前命名空间中所有变量或名称</li>
<li><code>%time 执行语句</code>：给出代码的执行时间</li>
<li><code>%timeit 执行语句</code>：多次执行代码，计算综合平均执行时间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="NumPy"><a href="#NumPy" class="headerlink" title="NumPy"></a>NumPy</h2><p><strong>简介</strong>：NumPy 是一个开源的 python 科学计算基础库</p>
<p>NumPy 包含：</p>
<ul>
<li>一个强大的 N 维<strong>数组对象</strong> ndarray</li>
<li>广播功能函数</li>
<li>整合 C / C++ / Fortran 代码的工具</li>
<li>线性代数、傅里叶变换、随机数生成等功能</li>
</ul>
<p>NumPy 是 SciPy、Pandas 等科学计算及数据处理库的基础</p>
<h3 id="ndarray"><a href="#ndarray" class="headerlink" title="ndarray"></a>ndarray</h3><p>ndarray 是一个<strong>N维数组对象</strong>，由两部分组成：</p>
<ul>
<li>实际的数据</li>
<li>描述这些数据的<strong>元数据</strong>（数据维度、数据类型等）</li>
</ul>
<blockquote>
<ul>
<li>ndarray 数组一般要求所有的<strong>元素的类型相同</strong>（<strong>同质</strong>）</li>
<li>ndarray 数组可以由非同质元素组成，但是由非同质元素组成的时候，数组中的每个元素都会被看成 object 类型。</li>
<li>非同质元素组成的 ndarray 数组无法发挥 NumPy 的优势，尽量避免使用</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><p>ndarray 在程序中的别名是：<code>array</code>，所以在程序中使用 <code>np.array()</code> 来创建一个数组</p>
</li>
<li><p><code>np.array()</code> 输出成 <code>[]</code> 形式，元素由空格分隔</p>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>轴（axis）：保存数据的<strong>维度</strong></li>
<li>秩（rank）：轴的<strong>数量</strong> / 有几个维度</li>
</ul>
</blockquote>
<p><strong>ndarray 数组对象的属性</strong>：</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">.ndim</td>
<td align="left">秩，即轴的数量或维度的数量</td>
</tr>
<tr>
<td align="left">.shape</td>
<td align="left">数组的尺度，对于矩阵，n 行 m 列</td>
</tr>
<tr>
<td align="left">.size</td>
<td align="left">数组中元素的个数</td>
</tr>
<tr>
<td align="left">.dtype</td>
<td align="left">数组中数据的类型</td>
</tr>
<tr>
<td align="left">.itemsize</td>
<td align="left">每个元素所占内存空间大小，以字节为单位</td>
</tr>
</tbody></table>
<p><strong>ndarray 数组的创建方法：</strong></p>
<ul>
<li>从 Python 中的列表、元组等类型创建 ndarray 数组<ul>
<li><code>x = np.array(list/tuple)</code></li>
<li><code>x = np.array(list/tuple, dtype = np.float32)</code></li>
</ul>
</li>
<li>使用 NumPy 中的相关函数创建 ndarray 数组</li>
</ul>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>np.arange(n)</code></td>
<td align="left">类似 <code>range()</code> 函数，返回 <code>ndarray</code> 类型，元素从 <code>0</code> 到 <code>n-1</code></td>
</tr>
<tr>
<td align="left"><code>np.ones(shape)</code></td>
<td align="left">根据 <code>shape</code> 生成一个全 <code>1</code> 的数组，shape 是<strong>元组类型</strong></td>
</tr>
<tr>
<td align="left"><code>np.zeros(shape)</code></td>
<td align="left">根据 shape 生成一个全 0 的数组，shape 是<strong>元组类型</strong></td>
</tr>
<tr>
<td align="left"><code>np.full(shape, val)</code></td>
<td align="left">根据 shape 生成一个数组，每个元素的值都是 val</td>
</tr>
<tr>
<td align="left"><code>np.eye(n)</code></td>
<td align="left">创建一个 n*n 的矩阵，对角线元素为 1，其余全为 0</td>
</tr>
<tr>
<td align="left"><code>np.ones_like(a)</code></td>
<td align="left">根据数组 a 的形状创建一个全 1 的数组</td>
</tr>
<tr>
<td align="left"><code>np.zeros_like(a)</code></td>
<td align="left">根据数组 a 的形状创建一个全 0 的数组</td>
</tr>
<tr>
<td align="left"><code>np.full_like(a, val)</code></td>
<td align="left">根据数组 a 的形状创建一个全 val 的数组</td>
</tr>
<tr>
<td align="left"><code>np.linspace()</code></td>
<td align="left">根据起止数据等间距的填充数据，形成数组</td>
</tr>
<tr>
<td align="left"><code>np.concatenate()</code></td>
<td align="left">将两个或多个数组合并成一个新的数组</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不指定dtype，默认为浮点数</span></span><br><span class="line">In[<span class="number">24</span>]: np.ones((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">Out[<span class="number">24</span>]: </span><br><span class="line">array([[<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>]])</span><br></pre></td></tr></table></figure>

<ul>
<li>从字节流中创建 ndarray 数组</li>
<li>从文件中读取特定格式，创建 ndarray 数组</li>
</ul>
<p><strong>ndarray 数组的变换：</strong></p>
<p>对于创建后的 ndarray 数组，可以对其进行<strong>维度变换</strong>和<strong>元素类型变换</strong></p>
<ul>
<li>维度变换 (<code>a=np.array(list)</code>)</li>
</ul>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>a.reshape(shape)</code></td>
<td align="left">不改变原数组，返回一个 shape 形状的数组，shape 为元祖</td>
</tr>
<tr>
<td align="left"><code>a.resize(shape)</code></td>
<td align="left">将原数组修改，然后返回</td>
</tr>
<tr>
<td align="left"><code>a.swapaxes(ax1, ax2)</code></td>
<td align="left">将数组 n 个维度中两个维度进行调换</td>
</tr>
<tr>
<td align="left"><code>a.flatten()</code></td>
<td align="left">不改变原数组，返回降维后的一维数组</td>
</tr>
</tbody></table>
<ul>
<li><p>类型变换</p>
<p><code>new_a = a.astype(new_type)</code></p>
</li>
</ul>
<p>ndarray 数组转换为列表：</p>
<p> <code>ls = a.tolist()</code></p>
<p><strong>ndarray 数组的索引和切片</strong></p>
<p>一维数组的索引：<code>a[2]</code></p>
<p>一维数组的切片：<code>a[1:4:2]</code></p>
<p>多维数组的索引：<code>a[2,1,3]</code></p>
<p>多维数组的切片：<code>a[:,1:3,:3]</code></p>
<p><strong>ndarray 数组的运算</strong></p>
<ol>
<li><p>数组与标量之间的运算作用于数组的每一个元素</p>
</li>
<li><p>使用函数对 ndarray 数组进行运算</p>
<ol>
<li><p>一元函数：（使用一元函数，都不会修改原数组）</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>np.abs(x)</code> \ <code>np.fabs(x)</code></td>
<td>计算 数组各元素的<strong>绝对值</strong></td>
</tr>
<tr>
<td><code>np.sqrt(x)</code></td>
<td>计算 数组各元素的<strong>平方根</strong></td>
</tr>
<tr>
<td><code>np.square(x)</code></td>
<td>计算 数组各元素的<strong>平方</strong></td>
</tr>
<tr>
<td><code>np.log(x)</code> \ <code>np.log10(x)</code> \ <code>np.log2(x)</code></td>
<td>计算 数组各元素的自然<strong>对数</strong>、10为底的对数、2为底的对数</td>
</tr>
<tr>
<td><code>np.ceil(x)</code> \ <code>np.floor(x)</code></td>
<td>计算 数组各元素的 <strong>ceiling</strong> 值、<strong>floor</strong>值</td>
</tr>
<tr>
<td><code>np.rint(x)</code></td>
<td>计算 数组各元素的<strong>四舍五入</strong>值</td>
</tr>
<tr>
<td><code>np.modf(x)</code></td>
<td>将数组各元素的小数部分和整数部分以两个独立数组形式返回</td>
</tr>
<tr>
<td><code>np.exp(x)</code></td>
<td>计算 数组各元素的<strong>指数值</strong></td>
</tr>
<tr>
<td><code>np.sign(x)</code></td>
<td>计算 数组各元素的<strong>符号值</strong>，1， 0， -1</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<ol start="2">
<li><p>二元函数：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>+  -  *  /  **</code></td>
<td>两个数组各元素进行对应计算</td>
</tr>
<tr>
<td><code>np.maximum(x,y)</code> \ <code>np.minimum(x,y)</code></td>
<td>两个数组各元素进行对应比较，返回最大、最小值</td>
</tr>
<tr>
<td><code>np.mod(x,y)</code></td>
<td>元素级模运算</td>
</tr>
<tr>
<td><code>np.copysign(x,y)</code></td>
<td>将数组 y 中各元素值的符号赋值给数组 x 对应元素</td>
</tr>
<tr>
<td><code>&gt;  &lt;  &gt;=  &lt;=  ==  !=</code></td>
<td>算术比较，产生布尔型数组</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="数据的-CSV-文件的存取"><a href="#数据的-CSV-文件的存取" class="headerlink" title="数据的 CSV 文件的存取"></a>数据的 CSV 文件的存取</h3><blockquote>
<p> CSV：(Comma-Separated Value  逗号分隔值)</p>
</blockquote>
<p>将数组保存到文件中：</p>
<ol>
<li><code>np.savetxt(frame, array, fmt=&#39;%.18e&#39;, delimiter=None)</code><ul>
<li>frame: 要存入的文件，可以是 <code>.gz</code> 或 <code>.bz2</code> 的压缩文件</li>
<li>array: 要存入文件的数组</li>
<li>fmt: 写入文件的格式，如：<code>%d</code>，<code>%.2f</code>，<code>%.18e</code></li>
<li>delimiter: 分隔字符串，默认是空格</li>
</ul>
</li>
</ol>
<p>读取文件到数组中：</p>
<p><code>np.loadtxt(frame, dtype=np.float, delimiter=None, unpack=False)</code></p>
<ul>
<li>frame: 要读取的文件，可以是 <code>.gz</code> 或 <code>.bz2</code> 的压缩文件</li>
<li>dtype: 数据类型，可选</li>
<li>delimiter: 分隔字符串，默认为空格</li>
<li>unpack: 如果是 True，读入属性将分别写入不同变量</li>
</ul>
<p>csv 文件的局限性：</p>
<ul>
<li><p>csv 文件只能有效的存储一维和二维数组</p>
</li>
<li><p><code>np.savetxt()</code> &amp; <code>np.loadtxt()</code> 只能有效存取一维和二维数组</p>
</li>
</ul>
<h3 id="多维数据的存取"><a href="#多维数据的存取" class="headerlink" title="多维数据的存取"></a>多维数据的存取</h3><p>存多维数据</p>
<p><code>np.tofile(frame, sep=&#39;&#39;, format=&#39;%s&#39;)</code></p>
<ul>
<li>frame：文件，字符串</li>
<li>sep：数据分隔字符串，如果是空串，则写入为二进制文件</li>
<li>format：写入数据格式</li>
</ul>
<p>读多维数据</p>
<p><code>np.fromfile(frame, dtype=float, count=-1, sep=&#39;&#39;)</code></p>
<ul>
<li>frame：文件，字符串</li>
<li>dtype：读入的数据类型</li>
<li>count：读入元素的个数，-1 代表读入整个文件</li>
<li>sep：数据分隔字符串，如果为空串，读入的为二进制文件</li>
</ul>
<blockquote>
<p>上面的存取多维数据的方法无法存取维度信息</p>
<p>要想读取的时候复原维度信息，需要使用reshape</p>
</blockquote>
<p>Numpy 提供的便捷文件存取</p>
<p><code>np.save(fname, array)</code>或<code>np.savez(fname, array)</code></p>
<ul>
<li>fname：文件名，扩展名为 <code>.npy</code>，压缩扩展名为 <code>npz</code></li>
<li>array：数组变量</li>
</ul>
<p><code>np.load(fname)</code></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora + Hexo 图片相关设置</title>
    <url>/2019/10/14/Typora+Hexo%20%E5%9B%BE%E7%89%87%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p>使用 Hexo 部署博客时，在 Typora 中添加图片的正确姿势</p>
<a id="more"></a>



<h3 id="需求"><a href="#需求" class="headerlink" title="需求:"></a>需求:</h3><ul>
<li>在 Typora 中写笔记的时候能够方便的添加图片, 把需要添加的图片直接拖进去就可以, 而不需要手写图片路径</li>
<li>直接拖到 Typora 里面的图片可以自动放到 <code>source/images</code> 文件夹中</li>
<li>图片在 Typora 里面和 Hexo 渲染之后都可以正常的显示 (需要图片的路径适合两种情况)</li>
</ul>
<h3 id="设置"><a href="#设置" class="headerlink" title="设置:"></a>设置:</h3><ol>
<li><p>在 Typora  <code>文件--&gt;偏好设置--&gt;图像</code>  设置如下: </p>
<p>(直接拖入或者复制进Typora的图片会被复制到images文件夹下面的 以笔记文件名命名的文件夹中)</p>
<p><img src="/images/Typora+Hexo%20%E5%9B%BE%E7%89%87%E8%AE%BE%E7%BD%AE/image-20210322100052295.png" alt="image-20210322100052295"></p>
</li>
</ol>
<ol start="2">
<li><p>在 Typora <code>格式--&gt;图像--&gt;设置图片根目录</code> 中设置根目录为 <code>source</code> 目录</p>
<p>设置了图片根目录之后, 在markdown笔记文件的头部信息中会出现 <code>typora-root-url</code></p>
<p><img src="/images/Typora+Hexo%20%E5%9B%BE%E7%89%87%E8%AE%BE%E7%BD%AE/image-20210322100713968.png" alt="image-20210322100713968"></p>
</li>
</ol>
<p>经过以上两步设置之后就可以直接将图片放到markdown笔记中了</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项:"></a>注意事项:</h3><ul>
<li>一定要先设置 <code>图片根目录</code>, 再往笔记中添加图片, 否则图片路径会不正确, 在 Hexo 渲染后就无法显示</li>
</ul>
]]></content>
      <tags>
        <tag>Typora - Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>YAML</title>
    <url>/2019/10/14/YAML/</url>
    <content><![CDATA[<p>YAML 是Spring Boot 官方推荐的配置文件格式</p>
<a id="more"></a>



<p>YAML 是一种以<strong>数据</strong>为核心的语言</p>
<h3 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h3><p><code>k: v</code>： 表示一对键值对（冒号后面的空格是必须的）</p>
<p>以<strong>空格的缩进</strong>来控制层级关系，只要一列数据左对齐，它们就属于同一个层级</p>
<p>k，v 都是大小写敏感的</p>
<p>文件后缀：yml / yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span> </span><br><span class="line">    <span class="attr">port:</span> <span class="number">8090</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/hello</span></span><br></pre></td></tr></table></figure>



<h4 id="值的类型及写法："><a href="#值的类型及写法：" class="headerlink" title="值的类型及写法："></a>值的类型及写法：</h4><ul>
<li><p>数、字符串（不需要加引号）、布尔值</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">zhangsan</span></span><br><span class="line"><span class="attr">age:</span> <span class="number">18</span></span><br><span class="line"><span class="attr">gender:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>对象、Map</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对象</span></span><br><span class="line"><span class="attr">people:</span></span><br><span class="line">	<span class="attr">name:</span> <span class="string">zhangsan</span></span><br><span class="line">	<span class="attr">age:</span> <span class="number">18</span></span><br><span class="line">	<span class="attr">gender:</span> <span class="literal">true</span></span><br><span class="line">	</span><br><span class="line"><span class="comment"># 对象的行内写法（也是Map的写法）</span></span><br><span class="line"><span class="attr">people:</span> <span class="string">&#123;name:</span> <span class="string">zhangsan,</span> <span class="attr">age:</span> <span class="number">18</span><span class="string">,</span> <span class="attr">gender:</span> <span class="literal">true</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>数组：用 <code>-</code> 表示数组中的元素</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数组</span></span><br><span class="line"><span class="attr">fruits:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">apple</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">orange</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">banana</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 数组的行内写法</span></span><br><span class="line"><span class="attr">fruits:</span> <span class="string">[apple,</span> <span class="string">orange,</span> <span class="string">banana]</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="为-JavaBean-的属性赋值："><a href="#为-JavaBean-的属性赋值：" class="headerlink" title="为 JavaBean 的属性赋值："></a>为 JavaBean 的属性赋值：</h3><p>使用 <code>@ConfigurationProperties</code> 注解</p>
<p>属性名称必须和配置文件中的名称一一对应</p>
<p>YAML 配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">people:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">lisi</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line">  <span class="attr">isman:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">dog:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">niuer</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">list:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">haha</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">hehe</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">heihei</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">xixi</span></span><br></pre></td></tr></table></figure>



<p>JavaBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只有将 JavaBean 作为容器的组件，才能使用容器提供的 @ConfigurationProperties 注解来为属性赋值</span></span><br><span class="line"><span class="meta">@Component</span>  <span class="comment">// 将 Javabean 作为组件添加到容器中</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"people"</span>)  <span class="comment">// 获取yaml中值的注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isman;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// Getter &amp; Setter (必须要有)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Value-获取值和-ConfigurationProperties-获取值的区别"><a href="#Value-获取值和-ConfigurationProperties-获取值的区别" class="headerlink" title="@Value 获取值和 @ConfigurationProperties 获取值的区别"></a><code>@Value</code> 获取值和 <code>@ConfigurationProperties</code> 获取值的区别</h4><table>
<thead>
<tr>
<th></th>
<th>@ConfigurationProperties</th>
<th>@Value</th>
</tr>
</thead>
<tbody><tr>
<td>获取方式</td>
<td>批量注入配置文件中的属性</td>
<td>一个个注入</td>
</tr>
<tr>
<td>松散绑定</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>SpEL</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>JSR303数据校验</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>复杂类型封装</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<blockquote>
<p>松散绑定：在 YAML 中 <code>-</code> 后面的一个字母会自动变为大写，下面两个可以对应起来</p>
<ul>
<li>YAML 中：last-name</li>
<li>JavaBean 中：lastName</li>
</ul>
<p>JSR303数据校验：可以在 JavaBean 的属性上添加过滤器验证，以保证数据的合法性。</p>
<p>如何使用：</p>
<ol>
<li>在类上添加 <code>@Validated</code> 注解（Spring的这个注解，不要弄错了）</li>
<li>在属性上面添加验证注解，如 <code>@Email()</code></li>
</ol>
</blockquote>
<p><strong>使用哪一个？</strong></p>
<ul>
<li>如果只是在业务逻辑中获取配置文件中的某个值，用 <code>@Value</code></li>
<li>如果专门写了一个 JavaBean 来和配置文件进行映射时，果断用 <code>@ConfigurationProperties</code></li>
</ul>
<h3 id="YAML-文件中使用-EL表达式："><a href="#YAML-文件中使用-EL表达式：" class="headerlink" title="YAML 文件中使用 EL表达式："></a>YAML 文件中使用 EL表达式：</h3><p>获取随机数：<code>${random.value}</code>、<code>${random.int}</code></p>
<p>占位符可以获取之间配置过的值，如果没有，可以指定默认值</p>
<ul>
<li><p><code>${app.name}</code> ：获取值</p>
</li>
<li><p><code>${app.name:默认值}</code>：没有值的情况下指定默认值</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>YAML</tag>
      </tags>
  </entry>
  <entry>
    <title>Thymeleaf</title>
    <url>/2019/10/09/Thymeleaf/</url>
    <content><![CDATA[<p>Thymeleaf 是 Spring Boot 官方推荐使用的模板引擎</p>
<a id="more"></a>

<h3 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h3><p>概念：将页面和数据整合到一起的东西。</p>
<p>常见的模板引擎：JSP、FreeMarker、Thymeleaf</p>
<h3 id="Thymeleaf-语法"><a href="#Thymeleaf-语法" class="headerlink" title="Thymeleaf 语法"></a>Thymeleaf 语法</h3><blockquote>
<p>要想使用 Thymeleaf 的提示功能，需要在 HTML 中引入 Thymeleaf 的 xmlns<br><code>xmlns:th = &quot;http://www.thymeleaf.org&quot;</code></p>
</blockquote>
<p><code>th:*</code>：* 几乎可以代表所有 HTML 的元素</p>
<p>Simple Expression：</p>
<ul>
<li>Variable Expressions: <code>${...}</code></li>
<li>Selection Variable Expressions: <code>*{...}</code></li>
<li>Message Expressions: <code>#{...}</code></li>
<li>Link URL Expressions: <code>@{...}</code></li>
<li>Fragment Expressions: <code>~{...}</code></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--表达式基本使用演示--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- $&#123;&#125; 取值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:text</span>=<span class="string">"$&#123;hello&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- @&#123;&#125; 链接--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/css/bootstrap.min.css&#125;"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- ~&#123;&#125; 提取模板--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container-fluid"</span> <span class="attr">th:fragment</span>=<span class="string">"sidebar"</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--在需要提取的代码块上使用 th:fragment="sidebar"--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--在需要使用模板的地方使用 th:replace 或者 th:insert 导入模板--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">"~&#123;commons::sidebar&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>Thymeleaf 判断：<code>th:if=&quot;&quot;</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--回显错误信息，当错误信息不为空时才显示--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color: red"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;errorMsg&#125;"</span> <span class="attr">th:if</span>=<span class="string">"$&#123;not #strings.isEmpty(errorMsg)&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>







<p>Thymeleaf 遍历：<code>th:each=&quot;item : ${items}&quot;</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--把后端返回的集合遍历出来--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">"emp:$&#123;emps&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;emp.getId()&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;emp.getEmpName()&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--表达式内使用三元运算符--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;emp.getGender()==0?'女':'男'&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;emp.getDepartment().getDepName()&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用 # 来调用函数，完成一下高级操作--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;#dates.format(emp.getBirth(), 'yyyy/MM/dd HH:mm')&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"btn btn-sm btn-primary"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/emp/edit.do/&#125;+$&#123;emp.getId()&#125;"</span>&gt;</span>修改<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"btn btn-sm btn-danger"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/emp/delete.do/&#125;+$&#123;emp.getId()&#125;"</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java EE</category>
      </categories>
      <tags>
        <tag>Thymeleaf</tag>
        <tag>模板引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot</title>
    <url>/2019/10/09/Java/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Spring%20Boot/</url>
    <content><![CDATA[<p>Spring Boot 是现在 Java 企业级开发最流行的框架</p>
<blockquote>
<p>约定大于配置</p>
</blockquote>
<blockquote>
<p>自动装配</p>
</blockquote>
<a id="more"></a>

<p>Spring Boot 是什么？</p>
<ul>
<li>Spring Boot 就是一个 JavaWeb 开发框架，相比于其他框架的优势是：<code>它极大程度的简化了开发</code></li>
</ul>
<p>核心思想：</p>
<ul>
<li>约定大于配置</li>
</ul>
<blockquote>
<p>什么是微服务架构？</p>
<p>​    微服务是一种架构风格</p>
<p>单体架构：所有的模块都集成在同一个应用中（放在一个 jar / war 包中），想要提高单体应用的响应能力只能使用负载均衡。</p>
<p>MVC 三层架构：把整个应用分为三层，可以把每一层放到一个服务器上。</p>
<p>微服务架构：把应用中的每个模块都独立出来（比如可以把 UserService 单独拿出来），模块之间使用 http / rpc 进行通信。</p>
<p>一张来自 Dubbo 官网的架构演进图：</p>
<p><img src="/images/springboot/dubbo-architecture-roadmap.jpg" alt="dubbo-architecture-roadmap"></p>
</blockquote>
<p>Spring Boot 项目的快速创建：使用 <strong>idea</strong> 里面的 *<em>Spring Initializr *</em></p>
<h2 id="Profile-多环境配置"><a href="#Profile-多环境配置" class="headerlink" title="Profile 多环境配置"></a>Profile 多环境配置</h2><blockquote>
<p>在 Spring Boot 中可以使用 Profile 来快速切换环境，如生产环境，测试环境等，可以快速为每种环境设置不同的参数</p>
</blockquote>
<h3 id="YAML-配置文件的-Profile："><a href="#YAML-配置文件的-Profile：" class="headerlink" title="YAML 配置文件的 Profile："></a>YAML 配置文件的 Profile：</h3><p>yaml配置文件支持多文档块的形式</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不指定 active，默认走8081</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> </span><br><span class="line">	<span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">	</span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8082</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">dev</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8083</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">test</span></span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="Profile-的其他几种激活方式："><a href="#Profile-的其他几种激活方式：" class="headerlink" title="Profile 的其他几种激活方式："></a>Profile 的其他几种激活方式：</h3><ol>
<li><p>properties 配置文件：</p>
<p>新建多个配置文件，每一个配置文件对应一种环境</p>
<ul>
<li><p>application-dev.properties</p>
</li>
<li><p>application-test.properties</p>
</li>
</ul>
<p>激活：<code>spring.profiles.active=dev</code></p>
</li>
</ol>
<ol start="2">
<li><p>命令行：<code>–spring.profiles.active=dev</code></p>
</li>
<li><p>JVM：<code>-Dpring.profiles.active=dev</code></p>
</li>
</ol>
</blockquote>
<h2 id="配置文件的加载"><a href="#配置文件的加载" class="headerlink" title="配置文件的加载"></a>配置文件的加载</h2><p>Spring Boot 启动之后会默认访问以下位置下的 <code>application.properties</code> 或 <code>application.yaml</code> 来作为主配置文件</p>
<blockquote>
<p>配置文件名称叫 application 为约定。</p>
</blockquote>
<p>优先级由高到低：</p>
<ol>
<li><code>file:/config/</code></li>
<li><code>file:/</code></li>
<li><code>classpath:/config/</code></li>
<li><code>classpath:/</code></li>
</ol>
<blockquote>
<p><code>file:/</code>：为 pom.xml 同级路径</p>
<p><code>classpath:/</code>：为 resources 文件夹下</p>
</blockquote>
<p>以上所有目录下的配置文件都会被加载，如果有相同的配置，优先级高的会覆盖优先级低的，也有可能形成互补配置。</p>
<h2 id="外部配置的加载顺序"><a href="#外部配置的加载顺序" class="headerlink" title="外部配置的加载顺序"></a>外部配置的加载顺序</h2><p>优先级仍然是从高到低：</p>
<ol>
<li>命令行参数</li>
<li>由jar包外向jar包内寻找，优先加载带spring.profile的配置文件<ul>
<li>jar包外，带profile</li>
<li>jar包内，带profile</li>
<li>jar包外，不带profile</li>
<li>jar包内，不带profile</li>
</ul>
</li>
</ol>
<p>Spring Boot 推荐的给容器中添加组件的方式：在配置类中使用@Bean注解</p>
<ul>
<li>配置类：用于替代配置文件，一个普通的Java类加上@Configuration注解</li>
<li><code>@Bean</code>： 标注在配置类中的方法上，将方法的返回值作为组件添加到容器中，这个组件在容器中的默认id就是方法名</li>
</ul>
<h2 id="日志框架"><a href="#日志框架" class="headerlink" title="日志框架"></a>日志框架</h2><p>springboot内部的使用的日志框架：</p>
<ul>
<li>日志抽象层：SLF4J</li>
<li>日志实现：Logback</li>
</ul>
<p>​    SLF4J的使用：导入SLF4J的jar包，就可以使用了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.loggerfactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Logger logger = LoggerFactory.getLogger(HelloWorld<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        logger.info(<span class="string">"HelloWorld"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SpringBoot框架中使用日志框架"><a href="#SpringBoot框架中使用日志框架" class="headerlink" title="SpringBoot框架中使用日志框架"></a>SpringBoot框架中使用日志框架</h2><p>SpringBoot底层使用的是slf4j + logback进行日志记录，</p>
<p>如果我们要在SpringBoot中引入其他的框架时，首先就要把这个框架依赖的日志框架移除</p>
<h2 id="SpringBoot-与-web-开发"><a href="#SpringBoot-与-web-开发" class="headerlink" title="SpringBoot 与 web 开发"></a>SpringBoot 与 web 开发</h2><h3 id="Spring-Boot-对静态资源的映射规则"><a href="#Spring-Boot-对静态资源的映射规则" class="headerlink" title="Spring Boot 对静态资源的映射规则"></a>Spring Boot 对静态资源的映射规则</h3><ol>
<li><p>webjars：以 jar 包的形式引入静态资源（<strong>了解即可，不常用</strong>）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过在pom.xml中引入maven依赖的方式来引入静态资源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jquery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>所有的 <code>webjars/**</code> ，都去 <code>classpath:/META-INF/resources/webjars/</code> 找资源</p>
</li>
</ol>
<ol start="2">
<li><p>项目中静态资源默认可以存放的位置</p>
<ol>
<li><p><code>classpath:/META-INF/resources/</code></p>
</li>
<li><p><code>classpath:/resources/</code></p>
</li>
<li><p><code>classpath:/static/</code></p>
</li>
<li><p><code>classpath:/public/</code></p>
<blockquote>
<p>为什么是这四个文件夹？</p>
<p>因为 Spring Boot 在 <code>WebProperties.java</code> 中的静态内部类 <code>Resources</code> 中配置了这四个文件夹：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Resources</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; <span class="string">"classpath:/META-INF/resources/"</span>,<span class="string">"classpath:/resources/"</span>, <span class="string">"classpath:/static/"</span>, <span class="string">"classpath:/public/"</span> &#125;;</span><br></pre></td></tr></table></figure>


</blockquote>
<blockquote>
<p>以上文件夹为静态资源的文件夹，当使用 / 来访问项目中的资源时，如果资源没人处理，则会到上面文件夹中按先后顺序寻找</p>
<p>例如：</p>
<p>​    有 dog.jpg 图片文件，路径为 <code>classpath:/static/img/dog.jpg</code></p>
<p>​    在 Spring Boot 中（未配置虚拟目录）可以直接使用 <code>localhost:8080/img/dog.jpg</code> 访问到文件，而不用写 static 目录，因为 Spring Boot 中会自动映射到静态文件夹中。</p>
<p>​    这也是在 tmlplates 文件夹中的 html 文件中可以直接使用 <code>th:href=&quot;@{/css/bootstrap.min.css}&quot;</code> 获取到 static 文件夹中资源的原因（使用 <code>@{相对路径}</code> 时，Relative URLs starting with / (eg: /css/bootstrap.min.css ) will be automatically prefixed by the application context name）</p>
</blockquote>
<blockquote>
<p>自己修改静态资源文件夹的位置：在 properties 配置文件中这样配置：</p>
<p><code>spring.resources.static-locations=/mystatic</code></p>
</blockquote>
</li>
</ol>
</li>
</ol>
<p>首页和网站图标：</p>
<ol>
<li>首页：静态资源文件夹下的 <code>index.html</code> 文件</li>
<li>网页图标：在静态资源文件夹下找 <code>favicon.ico</code> 文件</li>
</ol>
<h3 id="Spring-Boot-使用模板引擎"><a href="#Spring-Boot-使用模板引擎" class="headerlink" title="Spring Boot 使用模板引擎"></a>Spring Boot 使用模板引擎</h3><p>Spring Boot 推荐使用 Thymeleaf 作为项目的模板引擎</p>
<p><strong>使用 Thymeleaf 步骤：</strong></p>
<ol>
<li><p>在 pom.xml 文件中引入 Thymeleaf 的启动器</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>把  <code>.html</code> 文件放到 <code>classpath:/templates/</code> 路径下，Thymeleaf 就能自动渲染 。</p>
</li>
</ol>
<h3 id="Spring-Boot-整合-Mybatis"><a href="#Spring-Boot-整合-Mybatis" class="headerlink" title="Spring Boot 整合 Mybatis"></a>Spring Boot 整合 Mybatis</h3><ol>
<li><p>引入 <code>mybatis-spring-boot-starter</code>，<code>mysql-connector-java</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置数据库连接信息</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="comment"># serverTimezone=UTC解决时区的报错</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/springboot-demo?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建接口，并增加注解</p>
<ul>
<li><code>@Mapper</code>：标注这个接口是一个 mapper，在 ssm 时期，是在配置文件中使用包扫描的方式完成的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span>		<span class="comment">// 这个注解可以不用，只要在springboot的主配置类上添加 @MapperScan("cn.hellopika.dao")</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 还是和原来一样写增删改查的方法</span></span><br><span class="line">    <span class="function">List&lt;UserEntity&gt; <span class="title">selectAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 resource 目录下创建 mapper 接口对应的 xml 文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"cn.hellopika.dao.UserMapper"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里 resultType 使用了别名的形式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectAll"</span> <span class="attr">resultType</span>=<span class="string">"userEntity"</span>&gt;</span></span><br><span class="line">        select * from usertable;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 Spring Boot 的配置文件中添加 Mybatis 相关配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mappers/*.xml</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">cn.hellopika.pojo.entity</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>Java EE</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>idea配置</title>
    <url>/2019/10/08/Java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/idea%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>新安装的idea在使用前需要进行的配置</p>
<a id="more"></a>

<h2 id="新建项目时idea如何配置"><a href="#新建项目时idea如何配置" class="headerlink" title="新建项目时idea如何配置"></a>新建项目时idea如何配置</h2><ol>
<li>每次新建一个project，都要设置<strong>maven仓库</strong>&amp;设置<strong>jdk</strong></li>
</ol>
<h2 id="如何新建项目"><a href="#如何新建项目" class="headerlink" title="如何新建项目"></a>如何新建项目</h2><ol>
<li>直接创建项目</li>
<li>从 git （或者其他版本控制工具）上面获取项目</li>
</ol>
<h2 id="往git上提交哪些内容？"><a href="#往git上提交哪些内容？" class="headerlink" title="往git上提交哪些内容？"></a>往git上提交哪些内容？</h2><ul>
<li>pom.xml</li>
<li>src下面的内容</li>
</ul>
<blockquote>
<p>绝对不能提交 .idea 这些带点的配置文件\</p>
</blockquote>
<h2 id="idea-展开-折叠-目录快捷键"><a href="#idea-展开-折叠-目录快捷键" class="headerlink" title="idea 展开/折叠 目录快捷键:"></a>idea 展开/折叠 目录快捷键:</h2><p>右箭头展开 / 左箭头折叠</p>
]]></content>
      <categories>
        <category>其他技术</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>谷粒商城</tag>
      </tags>
  </entry>
  <entry>
    <title>笔记</title>
    <url>/2019/08/02/%E5%85%B6%E5%AE%83%E7%AC%94%E8%AE%B0/%E8%BF%90%E5%8A%A8%E4%B8%8E%E5%81%A5%E5%BA%B7_%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>mooc 运动与健康 课堂笔记</p>
<a id="more"></a>
<h1 id="运动与健康"><a href="#运动与健康" class="headerlink" title="运动与健康"></a>运动与健康</h1><p><strong>影响人类健康的三大问题：</strong></p>
<ul>
<li>肥胖</li>
<li>缺乏运动导致的文明病</li>
<li>危险与紧张带来的心理病</li>
</ul>
<p><strong>肥胖的危害：</strong></p>
<p>血脂异常、增加脑血管病变、增加患高血压的概率、增加心脏负荷、增加糖尿病风险、易患癌症</p>
<p><strong>判断肥胖的方法：</strong></p>
<ol>
<li><p>BMI = w(体重_kg) / h<sup>2</sup>(身高_m)</p>
</li>
<li><p>腰围（可以测出脂肪在体内的大致分布）</p>
<ul>
<li>世界卫生组织：男 &lt; 95cm，女 &lt; 80cm</li>
<li>中国：男 &lt; 85cm，女 &lt; 80cm</li>
</ul>
</li>
<li><p>腰臀比：男 &lt; 0.95，女 &lt; 0.85    向心性肥胖</p>
</li>
<li><p>标准体重_kg = 身高_cm - 105</p>
</li>
</ol>
<blockquote>
<p>肥胖是仅次于吸烟和艾滋病的第三大慢性杀手</p>
<p>运动是减少脂肪最经济有效的方法</p>
</blockquote>
<hr>
<p><strong>判断心理健康的四个标准：</strong></p>
<ol>
<li>心理标准</li>
<li>心理测验标准</li>
<li>统计标准</li>
<li>社会适应标准</li>
</ol>
<p><strong>运动的好处：</strong></p>
<ul>
<li>健康幸福感</li>
<li>对抑郁有治疗作用</li>
<li>产生良好的情绪体验</li>
<li>对意志品质有促进作用</li>
<li>使认知能力提高</li>
</ul>
<blockquote>
<p>生命在于科学运动</p>
</blockquote>
<p><strong>科学运动的关键：</strong></p>
<ul>
<li>确定运动项目</li>
<li>设定运动量与运动强度</li>
<li>把握运动时间</li>
</ul>
<p><strong>有氧运动和无氧运动：</strong></p>
<ul>
<li>有氧运动：中低强度、时间长、不间断、有节奏（走、慢跑、游泳、健身操）</li>
<li>无氧运动：强度高、时间短、疲劳难以消除（短跑、举重、拳击）</li>
</ul>
<p><strong>靶心率</strong> =（220-年龄）*65%(下限) 或 85%(上限)</p>
<p><strong>运动量</strong> = 运动强度 * 运动时间</p>
<blockquote>
<p><strong>每周4~5次</strong>运动最为合适（贵在持之以恒）</p>
</blockquote>
<blockquote>
<p>在<strong>餐后30分钟~1小时</strong>运动最为合适</p>
</blockquote>
<blockquote>
<p><strong>晚上6~8点</strong>运动合适</p>
</blockquote>
]]></content>
      <tags>
        <tag>运动与健康</tag>
        <tag>课堂笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>新电脑开发环境搭建</title>
    <url>/2019/07/06/%E5%85%B6%E5%AE%83%E7%AC%94%E8%AE%B0/%E6%96%B0%E7%94%B5%E8%84%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>从头开始搭建自己的开发环境</p>
<a id="more"></a>
<h1 id="新电脑开发环境搭建"><a href="#新电脑开发环境搭建" class="headerlink" title="新电脑开发环境搭建"></a>新电脑开发环境搭建</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>作为一名数码爱好者，以及一名准Java程序员，之前一直是用自己大一的时候买的一台笔记本来做Java程序的编写，那台笔记本在使用两年之后卡的不行不行的，在把内存从4G加到8G，机械硬盘换成固态后，又焕发了第二春。一直使用到现在。得益于固态硬盘的加持，日常轻度办公影音是没有问题，但是受限于i5-4200U这颗远古时代的处理器，启动个Tomcat服务器都需要20秒的时间，实在忍受不了，故心心念一台台式机，谋划良久，终于行动。</p>
</blockquote>
<p><strong>台式机配置清单：</strong></p>
<ul>
<li>CPU：AMD R5-2400G （AMD YES）</li>
<li>内存：金士顿 骇客神条 DDR4 2400 8G*2</li>
<li>主板：B350M BAZOOKA</li>
<li>固态：三星 970 EVO 250G M.2</li>
<li>机械硬盘：西数蓝盘 2T</li>
<li>电源：安钛克 VP300P </li>
<li>机箱：航嘉 暗夜猎手3 （这个机箱是真的烂，要不是穷，肯定不会买它）</li>
<li>显示器：戴尔 U2518DR（这个显示器是真的好）</li>
</ul>
<p><strong>基础软件清单：</strong></p>
<ul>
<li>系统：win10 专业版 1903 （收费）</li>
<li>IDE：IDEA 2019.1.3 （收费）</li>
<li>JDK：1.8.0_212</li>
<li>数据库：MySQL 5.5 （5.5版本仍然是免费的，学习使用足够了）</li>
<li>数据库开发工具：Navicat Premium 12 （收费）</li>
<li>服务器：Tomcat 9.0.21</li>
<li>代码管理：git</li>
<li>项目管理：Maven  3.6.1</li>
<li>博客框架：Hexo</li>
<li>Markdown编辑器：Typora</li>
<li>浏览器：FireFox</li>
<li>文本编辑器：Notepad++</li>
</ul>
<p><strong>软件安装流程：</strong></p>
<ol>
<li><p>系统：下载地址：<a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">MSDN</a> </p>
<p>激活：我用的KMS</p>
</li>
<li><p>IDE：下载地址：<a href="https://www.jetbrains.com/idea/download/#section=windows" target="_blank" rel="noopener">官网下载</a></p>
<p>激活：google，<em>希望有能力的同学还是支持正版</em></p>
</li>
<li><p>JDK：下载地址：<a href="https://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">Oracle官网下载</a> 下载 jdk 送 jre</p>
</li>
<li><p>Navicat：下载地址：<a href="https://www.navicat.com.cn/products" target="_blank" rel="noopener">官网下载</a></p>
<p>破解：<a href="https://www.jianshu.com/p/5f693b4c9468/" target="_blank" rel="noopener">我参考的一篇文章</a></p>
</li>
<li><p>git：<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">官网下载</a>，<a href="https://github.com/waylau/git-for-win" target="_blank" rel="noopener">国内代理服务器下载</a></p>
</li>
<li><p>Hexo：hexo安装可参考<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">官网文档</a></p>
<p>一点注意事项：使用npm安装时速度比较慢，修改一下安装源即可：命令：npm config set registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>数码</tag>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat日志打印乱码问题解决</title>
    <url>/2019/07/06/%E5%85%B6%E5%AE%83%E7%AC%94%E8%AE%B0/Tomcat%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>解决 Tomcat 在 IDEA 中日志中文乱码的问题</p>
<a id="more"></a>



<p><em>idea 版本：2019.1.3</em></p>
<p><em>Tomcat 版本：9.0.21</em></p>
<p>出现 <strong>“淇℃伅”</strong> 乱码情况：</p>
<p>Tomcat 安装目录 –&gt; conf 文件夹 –&gt; logging.properties，找到 java.util.logging.ConsoleHandler.encoding = UTF-8 <strong>更改为</strong> java.util.logging.ConsoleHandler.encoding = GBK</p>
<p><em>已设置</em>  idea Settings –&gt; Editor –&gt; File Encodings 中：</p>
<ul>
<li>Global Encoding : UTF-8</li>
<li>Project Encoding : UTF-8</li>
<li>Default encoding for properties files : UTF-8</li>
</ul>
<p><em>未设置</em>  Tomcat 中 VM options，</p>
<p><em>未修改</em> idea.exe.vmoptions 和 idea64.exe.vmoptions 文件</p>
]]></content>
      <categories>
        <category>bugfix</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>乱码</tag>
      </tags>
  </entry>
  <entry>
    <title>集合</title>
    <url>/2019/06/18/Java/1.Java%E5%9F%BA%E7%A1%80/%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p>Java 集合是所有知识点中最重要的</p>
<a id="more"></a>

<h2 id="集合的基本继承结构"><a href="#集合的基本继承结构" class="headerlink" title="集合的基本继承结构"></a>集合的基本继承结构</h2><p><img src="../../../images/%E9%9B%86%E5%90%88/image-20210426210028013.png" alt="image-20210426210028013"></p>
<h2 id="Collection-常用方法"><a href="#Collection-常用方法" class="headerlink" title="Collection 常用方法"></a>Collection 常用方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Colection&lt;String&gt; c = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">c.add(<span class="string">"AA"</span>);  <span class="comment">// 向集合中添加元素</span></span><br><span class="line">c.add(<span class="string">"BB"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> size = c.size();  <span class="comment">// 集合的大小</span></span><br><span class="line">Boolean isContains = c.contains(<span class="string">"AA"</span>);  <span class="comment">// 判断集合中是否包含某个元素</span></span><br><span class="line">Boolean isEmpty = c.isEmpty();  <span class="comment">// 判断集合是否为空</span></span><br><span class="line">Object[] array = c.toArray();  <span class="comment">// 把集合转换为数组</span></span><br><span class="line">c.remove(<span class="string">"BB"</span>);  <span class="comment">// 从集合中移除元素</span></span><br><span class="line">c.clear();  <span class="comment">// 清空集合</span></span><br></pre></td></tr></table></figure>



<h2 id="Collection-操作集合方法"><a href="#Collection-操作集合方法" class="headerlink" title="Collection 操作集合方法"></a>Collection 操作集合方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Colection&lt;String&gt; c1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">Colection&lt;String&gt; c2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">c1.add(<span class="string">"zz"</span>);</span><br><span class="line">c1.add(<span class="string">"ff"</span>);</span><br><span class="line">c1.add(<span class="string">"xx"</span>);</span><br><span class="line"></span><br><span class="line">c2.add(<span class="string">"zz"</span>);</span><br><span class="line">c2.add(<span class="string">"hh"</span>);</span><br><span class="line">c2.add(<span class="string">"ll"</span>);</span><br><span class="line"></span><br><span class="line">c1.addAll(c2); 		<span class="comment">// 将c2中的所有元素添加到c1中</span></span><br><span class="line">c1.removeAll(c2); 	<span class="comment">// 将c1中和c2相同的元素删除</span></span><br><span class="line">c1.retainAll(c2); 	<span class="comment">// 将c1中和c2相同的元素保留</span></span><br><span class="line"></span><br><span class="line">c1.containsAll(c2); <span class="comment">// 判断c1是否包含了c2的全部元素，返回 boolean</span></span><br></pre></td></tr></table></figure>



<h2 id="List-常用方法"><a href="#List-常用方法" class="headerlink" title="List 常用方法"></a>List 常用方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">list.add(<span class="string">"A"</span>);  	<span class="comment">// 向集合中添加元素（尾部追加）</span></span><br><span class="line">list.add(<span class="string">"B"</span>);</span><br><span class="line">list.add(<span class="string">"C"</span>);</span><br><span class="line">list.add(<span class="string">"B"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> size = list.size();		<span class="comment">// 获取List的长度</span></span><br><span class="line">Boolean isEmpty = list.isEmpty();		<span class="comment">// 判断List是否为空</span></span><br><span class="line"></span><br><span class="line">list.add(<span class="number">2</span>,<span class="string">"H"</span>);	<span class="comment">// 在指定索引位置插入元素</span></span><br><span class="line">list.set(<span class="number">1</span>,<span class="string">"S"</span>);	<span class="comment">// 替换指定索引位置的元素</span></span><br><span class="line">list.get(<span class="number">1</span>);		<span class="comment">// 获取指定索引位置的元素</span></span><br><span class="line">list.remove(<span class="number">0</span>);		<span class="comment">// 移除指定索引位置的元素</span></span><br><span class="line"><span class="keyword">int</span> index = list.indexOf(<span class="string">"C"</span>);	<span class="comment">// 获取指定元素在集合中第一次出现的索引</span></span><br><span class="line"><span class="keyword">int</span> lastIndex = list.lastIndexOf(<span class="string">"B"</span>);  <span class="comment">//获取指定元素在集合中最后一次出现的索引</span></span><br></pre></td></tr></table></figure>





<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>创建：<code>ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;();</code></p>
<blockquote>
<p> <strong>注意：</strong></p>
<p> 泛型只能使用引用类型，不能使用基本数据类型</p>
<p> 因为集合中只能放<strong>地址值</strong></p>
<p> 要想往集合中存放数字、字符等基本数据类型的数据，需要使用基本数据类型对应的<strong>包装类型</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自己简单实现 ArrayList 类</span></span><br><span class="line"><span class="comment"> *	</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyArrayList04</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elementData;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;  <span class="comment">// 基础类型的成员变量会被赋予默认值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyArrayList04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 默认数组大小为10</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyArrayList04</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自动扩容</span></span><br><span class="line">        <span class="keyword">if</span>(size == elementData.length) &#123;</span><br><span class="line">            <span class="comment">// 扩容实现：</span></span><br><span class="line">            <span class="comment">// 1. 新建一个更大的数组</span></span><br><span class="line">            Object[] newArray = <span class="keyword">new</span> Object[elementData.length+(elementData.length&gt;&gt;<span class="number">1</span>)];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 把原来的数组拷贝到新数组中</span></span><br><span class="line">            System.arraycopy(elementData,<span class="number">0</span>,newArray,<span class="number">0</span>,elementData.length);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 把 elementData 指向新数组</span></span><br><span class="line">            elementData = newArray;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        elementData[size++] = element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>&#123;</span><br><span class="line">        checkIndexRange(index);</span><br><span class="line">        System.out.println(size);</span><br><span class="line">        System.arraycopy(elementData,index,elementData,index+<span class="number">1</span>,size-index);</span><br><span class="line">        size++;</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        checkIndexRange(index);</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>&#123;</span><br><span class="line">        checkIndexRange(index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        checkIndexRange(index);</span><br><span class="line">        System.out.println(size);</span><br><span class="line">        System.arraycopy(elementData,index+<span class="number">1</span>, elementData, index, --size-index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查索引越界</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkIndexRange</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;size-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"索引越界异常: "</span> + index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size==<span class="number">0</span>?<span class="keyword">true</span>:<span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">"["</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            sb.append(elementData[i] + <span class="string">","</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sb.setCharAt(sb.length()-<span class="number">1</span>, <span class="string">']'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>LinkedList 底层用<code>双向链表</code>实现储存（ArrayList 底层是 Object 数组）<br>特点：</p>
<ul>
<li>查询效率低，增删效率高</li>
<li>线程不安全</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表中的节点对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    Object element;</span><br><span class="line">    Node previous;</span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Node element, Node previous, Node next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">        <span class="keyword">this</span>.previous = previous;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Object element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自己手写 LinkedList</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node first;  <span class="comment">// 首节点</span></span><br><span class="line">    <span class="keyword">private</span> Node last;   <span class="comment">// 尾节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;    <span class="comment">// 链表长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(obj);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;  <span class="comment">// 插入第一个节点</span></span><br><span class="line">            first = node;</span><br><span class="line">            last = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;             <span class="comment">// 插入后续节点</span></span><br><span class="line">            <span class="comment">// 与末尾节点连接</span></span><br><span class="line">            node.previous = last;</span><br><span class="line">            last.next = node;</span><br><span class="line">            <span class="comment">// 把自己变成末尾节点</span></span><br><span class="line">            last = node;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据index查询节点数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        checkIndexRange(index);</span><br><span class="line">        </span><br><span class="line">        Node temp = first;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> temp != <span class="keyword">null</span> ? temp.element : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查索引</span></span><br><span class="line">        checkIndexRange(index);</span><br><span class="line"></span><br><span class="line">        Node temp = first;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(obj);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先找到要插入位置原来的节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入到首节点</span></span><br><span class="line">        <span class="keyword">if</span> (temp.previous == <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.next = temp;</span><br><span class="line">            temp.previous = node;</span><br><span class="line">            first = node;</span><br><span class="line"></span><br><span class="line">            size++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 插入到中间节点</span></span><br><span class="line">            node.previous = temp.previous;</span><br><span class="line">            node.next = temp;</span><br><span class="line"></span><br><span class="line">            node.previous.next = node;</span><br><span class="line">            temp.previous = node;</span><br><span class="line"></span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        checkIndexRange(index);</span><br><span class="line">        Node temp = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移除首节点</span></span><br><span class="line">        <span class="keyword">if</span> (temp.previous == <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp.next.previous = <span class="keyword">null</span>;</span><br><span class="line">            first = temp.next;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;  <span class="comment">// 移除尾节点</span></span><br><span class="line">            temp.previous.next = <span class="keyword">null</span>;</span><br><span class="line">            last = temp.previous;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                     <span class="comment">// 移除中间节点</span></span><br><span class="line">            temp.previous.next = temp.next;</span><br><span class="line">            temp.next.previous = temp.previous;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换节点 set</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, Object obj)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        checkIndexRange(index);</span><br><span class="line">        </span><br><span class="line">        Node node = <span class="keyword">new</span> Node(obj);</span><br><span class="line">        </span><br><span class="line">        Node temp = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 替换首节点</span></span><br><span class="line">        <span class="keyword">if</span> (temp.previous == <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.next = temp.next;</span><br><span class="line">            temp.next.previous = node;</span><br><span class="line">            first = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;    <span class="comment">// 替换尾节点</span></span><br><span class="line">            node.previous = temp.previous;</span><br><span class="line">            temp.previous.next = node;</span><br><span class="line">            last = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                     <span class="comment">// 替换中间节点</span></span><br><span class="line">            node.next = temp.next;</span><br><span class="line">            node.previous = temp.previous;</span><br><span class="line">            temp.previous.next = node;</span><br><span class="line">            temp.next.previous = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// index越界检查</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkIndexRange</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;size-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"索引越界异常: "</span> + index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 链表长度 size()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// isEmpty</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="Map-常用方法"><a href="#Map-常用方法" class="headerlink" title="Map 常用方法"></a>Map 常用方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">"one"</span>);  <span class="comment">// 向 Map 中添加键值对</span></span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">"two"</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">"three"</span>);</span><br><span class="line"></span><br><span class="line">map.get(<span class="number">2</span>);			<span class="comment">// 根据键取值</span></span><br><span class="line">map.size();			<span class="comment">// 返回 Map 中键值对的数量</span></span><br><span class="line">map.isEmpty();		<span class="comment">// 判断 Map 是否为空</span></span><br><span class="line">map.containsKey(<span class="number">3</span>); <span class="comment">// 判断 Map 中是否存在某个键</span></span><br><span class="line">map.containsValue(<span class="string">"four"</span>);  <span class="comment">// 判断 Map 中是否存在某个值</span></span><br></pre></td></tr></table></figure>



<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>Map 使用<strong>键值对</strong>来储存信息。</p>
<p>键值对信息通过键来标识，键不可重复。</p>
<p>如果 put 的时候键与之前的重复了，那么后面的键值对会覆盖掉前面的。</p>
<p>HashMap 类实现了 Map 接口。</p>
<p>HashMap 底层存储方式为<strong>数组 + 单向链表</strong></p>
<blockquote>
<p>链表的一个节点由四部分组成：<code>hash值</code> <code>键</code> <code>值</code> <code>next</code></p>
</blockquote>
<p>存储过程：</p>
<ol>
<li>得到一个键值对，获取键的 hashcode</li>
<li>通过散列算法得到 hashcode 的 hash 值（用于把键值对放到 HashMap 底层数组的指定位置）</li>
<li>把键值对的数据放到链表的一个节点中，然后追加到数组相应位置原有链表中</li>
</ol>
<p>特点：</p>
<ul>
<li>查询效率高，增删效率高</li>
<li>线程不安全</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自己实现一个简单的 HashMap</span></span><br><span class="line"><span class="comment"> * put, get, hash 三个方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;K, V&gt;[] table;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;  <span class="comment">// Map中键值对的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.table = <span class="keyword">new</span> Node[<span class="number">16</span>];  <span class="comment">// 数组大小为2的整数次幂</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加键值对</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新建一个节点对象，并初始化</span></span><br><span class="line">        Node&lt;K, V&gt; node = <span class="keyword">new</span> Node&lt;&gt;();</span><br><span class="line">        node.hash = myHash(key.hashCode(), table.length);</span><br><span class="line">        node.key = key;</span><br><span class="line">        node.value = value;</span><br><span class="line">        node.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        Node temp = table[node.hash];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            table[node.hash] = node;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 判断是否有重复的key，如果有，直接替换value，然后return</span></span><br><span class="line">                <span class="keyword">if</span>(temp.key.equals(node.key))&#123;</span><br><span class="line">                    temp.value = node.value;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 判断链表中是否有还有下一个节点，如果没有，就跳出循环</span></span><br><span class="line">                    <span class="keyword">if</span>(temp.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        temp = temp.next;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            temp.next = node;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据key查询value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">        V value = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> keyHash = myHash(key.hashCode(), table.length);</span><br><span class="line">        Node temp = table[keyHash];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.key.equals(key))&#123;</span><br><span class="line">                value = (V)temp.value;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据hashcode获取hash值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">myHash</span><span class="params">(<span class="keyword">int</span> hashcode, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hashcode % length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表的节点类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash;</span><br><span class="line">        K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K, V&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>TreeMap 底层是使用<strong>红黑二叉树</strong>实现的</p>
<p>TreeMap 和 HashMap 实现了同样的接口 Map</p>
<p><strong>在需要排序的 Map 时才选用 TreeMap</strong></p>
<p>自动按照 <strong>Key 递增</strong>的方向进行排序</p>
<blockquote>
<p>如果 Key 是自己定义的类，要怎么实现排序呢？</p>
<ol>
<li><p>实现 Comparable 接口</p>
</li>
<li><p>重写 CompareTo 方法（Comparable 接口中唯一的方法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Emp</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Emp</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Emp o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.salary &lt; o.salary) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;			<span class="comment">// 返回负数表示小于</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.salary &gt; o.salary) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;			<span class="comment">// 返回正数表示大于</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;			<span class="comment">// 返回 0 表示等于（等于的时候还可以定义其他排序规则，比如根据id排序）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
</blockquote>
<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p>HashTable 同样是 Map 的一个实现类。</p>
<p>HashTab 和 HashMap 用法几乎一样，区别在于：</p>
<ul>
<li>HashMap 效率高，线程不安全，允许 key 和 value 为 null</li>
<li>HashTable 效率低，线程安全（方法中添加了<strong>synchronized</strong>关键字确保线程同步检查），不允许 key 和 value 为 null</li>
</ul>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>Set 容器的特点：元素 <strong>无序</strong> &amp; <strong>不可重复</strong></p>
<p><strong>HashSet 底层采用 HashMap 实现</strong></p>
<p>Set 中所有的元素在 Map 中作为 key，map 中的 value 为事先定义好的一个对象</p>
<p>通过源码我们可以看出，HashSet 的底层是使用的 HashMap</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义了一个map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new了一个对象，用于放在map的value中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashSet的一个构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashSet的add方法，直接调用的HashMap的put方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove方法，直接调用HashMap的remove方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// size方法，直接调用HashMap的size方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p><strong>TreeSet 底层采用 TreeMap 实现</strong></p>
<p>TreeSet 会按照元素递增的方式实现排序</p>
<blockquote>
<p>如果 TreeSet 中是自己定义的类，那么这个类必须实现 Comparable 接口，从而实现排序</p>
</blockquote>
<h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><p>Iterator（迭代器）：使用统一的方式遍历集合</p>
<p><strong>Iterator 遍历 List：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Iterator&lt;String&gt; iter = list.iterator(); iter.hasNext();)&#123;</span><br><span class="line">    <span class="comment">// next() 方法返回当前元素，然后将 cursor 后移一位</span></span><br><span class="line">    String element = iter.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Iterator 遍历 Set：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Iterator&lt;String&gt; iter = set.iterator(); iter.hasNext();)&#123;</span><br><span class="line">    String element = iter.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Iterator 遍历 Map：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一：获取key的set，然后迭代(这种方法使用的多一些)</span></span><br><span class="line">Set&lt;Integer&gt; keySet = map.keySet();</span><br><span class="line"><span class="keyword">for</span> (Iterator&lt;Integer&gt; iter = keySet.iterator();iter.hasNext();)&#123;</span><br><span class="line">    Integer key = iter.next();</span><br><span class="line">    System.out.println(key+<span class="string">": "</span> + map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：获取entry的set，然后迭代</span></span><br><span class="line">Set&lt;Map.Entry&lt;Integer, String&gt;&gt; entries = map.entrySet();</span><br><span class="line"><span class="keyword">for</span>(Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iter = entries.iterator(); iter.hasNext();) &#123;</span><br><span class="line">    Map.Entry&lt;Integer, String&gt; entry = iter.next();</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">": "</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Collections-工具类"><a href="#Collections-工具类" class="headerlink" title="Collections 工具类"></a>Collections 工具类</h2><p>Collections 是 Java 官方提供的一个操作集合的工具类</p>
<p>常用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Collections.sort(list);		<span class="comment">// 把集合中元素排序（升序）</span></span><br><span class="line">Collections.shuffle(list);	<span class="comment">// 把集合中元素乱序</span></span><br><span class="line">Collections.reverse(list);	<span class="comment">// 把集合中元素逆序</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面试</title>
    <url>/2019/06/05/Java/Java%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<p>Java 面试题目整理</p>
<a id="more"></a>



<ol>
<li><p>Java 中的<strong>基本数据类型</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">四类八种：</span><br><span class="line"></span><br><span class="line">整数型</span><br><span class="line">byte(1字节)，short(2字节)，int(4字节)，long(8字节)</span><br><span class="line">浮点型</span><br><span class="line">float(4字节)，double(8字节)</span><br><span class="line">字符型</span><br><span class="line">char(1字节)</span><br><span class="line">布尔型</span><br><span class="line">boolean(无大小)</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>用什么数据类型存储金额</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用 BigDecimal,不会损失精度</span></span><br><span class="line">BigDecimal price1 = <span class="keyword">new</span> BigDecimal(<span class="string">"0.3"</span>);</span><br><span class="line">BigDecimal price2 = <span class="keyword">new</span> BigDecimal(<span class="string">"0.2"</span>);</span><br><span class="line"></span><br><span class="line">price1.subtract(price2);</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>WEB-INF 目录的作用</p>
<p><strong>基于 Servlet 的声明，WEB-INF 不作为 web 应用的公共文档树的一部分。</strong></p>
<p>因此，WEB-INF 目录下的资源不是为客户直接服务的，</p>
<p>所以，要想访问 WEB-INF 目录下的资源，必须<strong>走控制器</strong></p>
<p>WEB-INF 目录下的资源相对来说是<strong>安全的</strong></p>
</li>
</ol>
<ol start="4">
<li><p>Servlet 的执行流程</p>
<p>Servlet 是<strong>单实例、多线程</strong></p>
<p>第一次访问时，服务器创建 Servlet， 并调用 init 方法进行初始化，然后调用 service 方法</p>
<p>每当请求来到的时候，服务器创建一个线程，并调用 service 方法完成自己的业务逻辑</p>
<p>当 Servlet 被移除或服务器正常关闭时，服务器调用 Servlet 的 destory 方法执行收尾操作</p>
</li>
</ol>
<ol start="5">
<li><p>@Autowired 注解的使用</p>
<p>默认按照类型去容器中查找，</p>
<p>如果找到多个相同类型的组件，再将<strong>属性名</strong>作为<strong>组件的 id</strong> 去容器中查找</p>
</li>
</ol>
<ol start="6">
<li><p>JDK 和 JRE 的区别</p>
<p>JRE = JVM + Java 核心类库</p>
<p>JDK = JRE + Java 开发工具（JDK 11 及之后的版本中不再包括 JRE）</p>
</li>
</ol>
<ol start="7">
<li><p>final 关键字的作用</p>
<p>修饰类：类不能被继承</p>
<p>修饰成员方法：方法不能被重写</p>
<p>修饰成员变量：变量的值不能修改</p>
</li>
</ol>
<ol start="8">
<li><p><code>==</code> 和 <code>equals</code> 的区别</p>
<ul>
<li><p><code>==</code>：比较两个对象的地址值是否一样（也就是看两个对象实体是不是同一个），引用数据类型比较的是地址值，基础数据类型比较的是值</p>
</li>
<li><p><code>equals</code>：分为两种情况：</p>
<ol>
<li>如果没有重写继承自 Object 的 equals 方法，那么默认和 <code>==</code> 功能一样。</li>
<li>如果重写了，一般是重写成比较两个对象的内容</li>
</ol>
</li>
</ul>
</li>
</ol>
<ol start="9">
<li><p>Java 8 新特性：</p>
<ul>
<li>lambda 表达式</li>
<li>默认方法（接口中可以定义默认方法）</li>
<li>Stream API（<code>java.util.stream</code>，把真正的函数式编程风格引入到 Java 中）</li>
<li>方法引用 ？？？</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
      </tags>
  </entry>
  <entry>
    <title>AJAX</title>
    <url>/2019/05/30/Java/2.JavaWeb/AJAX/</url>
    <content><![CDATA[<p>AJAX：Asynchronous JavaScript and XML <code>异步的 JavaScript和XML</code></p>
<a id="more"></a>



<p>AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术</p>
<blockquote>
<p>浏览器和服务器通信中的<strong>同步和异步</strong>：</p>
<ul>
<li>同步：浏览器发出请求后必须等待服务器的响应，在等待期间不能做任何操作</li>
<li>异步： 浏览器不需要等待服务器的响应，在等待期间可以进行其他操作</li>
</ul>
</blockquote>
<p>AJAX 不是新的语言, 而是一种基于现有 Internet 标准的新方法, 并联合使用它们:</p>
<ul>
<li>XMLHttpRequest 对象(异步与服务器交换数据, 该对象为浏览器内置)</li>
<li>JavaScript / DOM</li>
<li>CSS</li>
<li>XML</li>
</ul>
<h3 id="使用-jQuery-实现-AJAX"><a href="#使用-jQuery-实现-AJAX" class="headerlink" title="使用 jQuery 实现 AJAX"></a>使用 jQuery 实现 AJAX</h3><ol>
<li>基础语法：<code>$.ajax({name:value, name:value, ...});</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url:<span class="string">"请求路径"</span>,</span><br><span class="line">    type:<span class="string">"POST"</span>, <span class="comment">// 请求方式，默认为GET</span></span><br><span class="line">    data:&#123;<span class="string">"username"</span>:<span class="string">"tom"</span>,<span class="string">"age"</span>:<span class="number">23</span>&#125;, <span class="comment">// 请求参数</span></span><br><span class="line">    success:<span class="function"><span class="keyword">function</span> (<span class="params">a</span>)</span>&#123; <span class="comment">// 响应成功后执行的回调函数，a 表示服务器响应的数据</span></span><br><span class="line">        alert(a);</span><br><span class="line">    &#125;,</span><br><span class="line">    error:<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"出错了"</span>); <span class="comment">// 请求响应出错时执行的回调函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<ol start="2">
<li><p><code>$.get()</code></p>
<p>语法：<code>$.get(url, [data], [callback], [type]);</code></p>
<ul>
<li>url：请求路径</li>
<li>data：请求参数</li>
<li>callback：回调函数</li>
<li>type：响应数据类型</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p><code>$.post()</code></p>
<p>语法：<code>$.get(url, [data], [callback], [type]);</code></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery高级</title>
    <url>/2019/05/30/Java/2.JavaWeb/jQuery-%E9%AB%98%E7%BA%A7/</url>
    <content><![CDATA[<p>jQuery</p>
<a id="more"></a>

<h1 id="jQuery高级"><a href="#jQuery高级" class="headerlink" title="jQuery高级"></a>jQuery高级</h1><h2 id="一-动画"><a href="#一-动画" class="headerlink" title="一. 动画"></a>一. 动画</h2><p>三种显示和隐藏元素的动画效果</p>
<ol>
<li><p><strong>默认</strong>效果    </p>
<ol>
<li><p>show([speed,[easing],[fn]])</p>
<pre><code>- speed：动画的速度。三个预定义的值(**&quot;slow&quot;,&quot;normal&quot;, &quot;fast&quot;**)或表示动画时长的毫秒数值(如：1000)</code></pre><ul>
<li>easing：用来指定切换动画效果，默认是”swing”，可用参数”linear”<ul>
<li>swing：非线性动画</li>
<li>linear：线性动画</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>fn：在动画完成时执行的函数，每个元素执行一次。</li>
</ul>
<ol start="2">
<li>hide([speed,[easing],[fn]])</li>
<li>toggle([speed],[easing],[fn])</li>
</ol>
</li>
<li><p><strong>滑动</strong>效果</p>
<ol>
<li>显示：slideDown([speed],[easing],[fn])</li>
<li>隐藏：slideUp([speed,[easing],[fn]])</li>
<li>切换：slideToggle([speed],[easing],[fn])</li>
</ol>
</li>
<li><p><strong>淡入淡出</strong>效果</p>
<ol>
<li>显示：fadeIn([speed],[easing],[fn])</li>
<li>隐藏：fadeOut([speed],[easing],[fn])</li>
<li>切换：fadeToggle([speed,[easing],[fn]])</li>
</ol>
</li>
</ol>
<h2 id="二-遍历"><a href="#二-遍历" class="headerlink" title="二. 遍历"></a>二. 遍历</h2><ol>
<li><p>js的遍历方式</p>
<pre><code>`for(初始化值;循环结束条件;步长)`</code></pre></li>
<li><p>jq的遍历方式</p>
<p>  <code>jq对象.each(callback)</code></p>
<ol start="3">
<li><p>语法：</p>
<p><code>jquery对象.each(function(index,element){});</code></p>
<ul>
<li>index:就是元素在集合中的索引</li>
<li>element：就是集合中的每一个元素对象</li>
<li>this：集合中的每一个元素对象</li>
</ul>
<ol start="2">
<li>回调函数返回值：</li>
</ol>
</li>
</ol>
<ul>
<li>true：如果当前function返回为false，则结束循环(break)。</li>
<li>false：如果当前function返回为true，则结束本次循环，继续下次循环(continue)</li>
</ul>
<ol start="2">
<li><p><code>$.each(object（可js，可jq）, [callback])</code></p>
</li>
<li><p><code>for .. of</code>: jquery 3.0 版本之后提供的方式</p>
<p><code>for(元素对象 of 容器对象)</code></p>
</li>
</ol>
</li>
</ol>
<h2 id="三-事件绑定"><a href="#三-事件绑定" class="headerlink" title="三. 事件绑定"></a>三. 事件绑定</h2><ol>
<li><p>jquery标准的绑定方式</p>
<pre><code>* `jq对象.事件方法(回调函数);`
* 注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。
    * 表单对象.submit();//让表单提交</code></pre></li>
<li><p>on绑定事件/off解除绑定</p>
<ul>
<li><code>jq对象.on(&quot;事件名称&quot;,回调函数)</code></li>
<li><code>jq对象.off(&quot;事件名称&quot;)</code><ul>
<li>如果off方法不传递任何参数，则将组件上的所有事件全部解绑</li>
</ul>
</li>
</ul>
</li>
<li><p>事件切换：toggle</p>
<ul>
<li><p><code>jq对象.toggle(fn1,fn2...)</code></p>
<ul>
<li>当单击jq对象对应的组件后，会执行fn1.第二次点击会执行fn2…..</li>
</ul>
</li>
<li><p>注意：1.9版本 .toggle() 方法删除,jQuery Migrate（迁移）插件可以恢复此功能。</p>
</li>
</ul>
</li>
</ol>
<h2 id="四-插件"><a href="#四-插件" class="headerlink" title="四. 插件"></a>四. 插件</h2><p>增强JQuery的功能<br>        1. $.fn.extend(object)<br>      * 增强通过Jquery获取的对象的功能  $(“#id”)<br>2. $.extend(object)</p>
<ul>
<li>增强JQeury对象自身的功能  $/jQuery</li>
</ul>
]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery基础</title>
    <url>/2019/05/28/Java/2.JavaWeb/jQuery-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>jQuery的选择器 &amp; DOM操作</p>
<a id="more"></a>

<h1 id="jQuery基础"><a href="#jQuery基础" class="headerlink" title="jQuery基础"></a>jQuery基础</h1><p>概念：jQuery是JavaScript的一个框架，可以简化js代码的书写</p>
<h2 id="jQuery-对象和-js-对象的区别和转换"><a href="#jQuery-对象和-js-对象的区别和转换" class="headerlink" title="jQuery 对象和 js 对象的区别和转换"></a>jQuery 对象和 js 对象的区别和转换</h2><ol>
<li><p>jQuery 对象在操作时，更加方便</p>
</li>
<li><p>jQuery 对象和 js 对象方法不通用</p>
</li>
<li><p>jQuery 对象和 js 对象的相互转换</p>
<ol>
<li>jQuery –&gt; js ：<code>jQuery对象[索引]</code>  /  <code>jQuery对象.get(索引)</code></li>
<li>js –&gt; jQuery ：<code>$(js对象)</code></li>
</ol>
</li>
</ol>
<h2 id="jQuery的选择器"><a href="#jQuery的选择器" class="headerlink" title="jQuery的选择器"></a>jQuery的选择器</h2><blockquote>
<ol>
<li>事件绑定<ol>
<li>规则：<code>$(&quot;#div1&quot;).click(function(){ alert(123) });</code></li>
</ol>
</li>
<li>入口函数<ol>
<li>规则：<code>$(function(){ 代码 });</code></li>
<li>与js 中<code>window.onload</code>的区别<ol>
<li><code>window.onload</code> 只能定义一次，如果定义多次，后面的会把前面的覆盖掉</li>
<li><code>$(function(){ 代码 });</code> 可以定义多次，</li>
</ol>
</li>
</ol>
</li>
<li>样式控制<ol>
<li><code>$(&quot;#div1&quot;).css(&quot;background-color&quot;, &quot;pink&quot;);</code></li>
<li><code>$(&quot;#div1&quot;).css(&quot;backgroundColor&quot;, &quot;pink&quot;);</code>：<em>推荐使用</em></li>
</ol>
</li>
</ol>
</blockquote>
<ol>
<li><p>基本选择器</p>
<pre><code>1. 标签选择器（元素选择器）
    * 语法：`$(&quot;标签&quot;)` 获得所有匹配标签名称的元素</code></pre><ol start="2">
<li>id选择器 <ul>
<li>语法：<code>$(&quot;#id&quot;)</code>获得与指定id属性值匹配的元素</li>
</ul>
</li>
<li>类选择器<ul>
<li>语法：<code>$(&quot;.class属性的值&quot;)</code>获得与指定的class属性值匹配的元素</li>
</ul>
</li>
<li>并集选择器：<ul>
<li>语法：<code>$(&quot;选择器1,选择器2....&quot;)</code> 获取多个选择器选中的所有元素</li>
</ul>
</li>
</ol>
</li>
<li><p>层级选择器</p>
<pre><code>1. 后代选择器
    * 语法：`$(&quot;A B&quot;)` 选择A元素内部的所有B元素        </code></pre><ol start="2">
<li>子选择器<ul>
<li>语法：<code>$(&quot;A &gt; B&quot;)</code> 选择A元素内部的所有B<strong>子元素</strong></li>
</ul>
</li>
</ol>
</li>
<li><p>属性选择器</p>
<pre><code>1. 属性名称选择器 
    * 语法：`$(&quot;A[属性名]&quot;)` 包含指定属性的选择器</code></pre><ol start="2">
<li>属性选择器<ul>
<li>语法：<code>$(&quot;A[属性名=&#39;值&#39;]&quot;)</code> 包含指定属性等于指定值的选择器</li>
<li><code>$(&quot;A[属性名!=&#39;值&#39;]&quot;)</code> ：属性不等于某些值，以及不包括该属性</li>
<li><code>$(&quot;A[属性名^=&#39;值&#39;]&quot;)</code> ：属性的值以 ** 开头</li>
<li><code>$(&quot;A[属性名$=&#39;值&#39;]&quot;)</code>：属性的值以 ** 结束</li>
<li><code>$(&quot;A[属性名*=&#39;值&#39;]&quot;)</code>  ：属性的值含有 **</li>
</ul>
</li>
<li>复合属性选择器<ul>
<li>语法：<code>$(&quot;A[属性名=&#39;值&#39;][]...&quot;)</code> 包含多个属性条件的选择器</li>
</ul>
</li>
</ol>
</li>
<li><p>过滤选择器</p>
<pre><code>1. 首元素选择器 
    * 语法： `$(&quot;A:first&quot;)`  获得选择的元素中的第一个元素</code></pre><ol start="2">
<li>尾元素选择器 <ul>
<li>语法： <code>$(&quot;A:last&quot;)</code>  获得选择的元素中的最后一个元素</li>
</ul>
</li>
<li>非元素选择器<ul>
<li>语法： <code>$(&quot;A:not(content)&quot;)</code> 不包括指定内容的元素</li>
<li>content：选择器表达式</li>
</ul>
</li>
<li>偶数选择器<ul>
<li>语法： <code>$(&quot;A:even&quot;)</code> 偶数，从 0 开始计数</li>
</ul>
</li>
<li>奇数选择器<ul>
<li>语法： <code>$(&quot;A:odd&quot;)</code> 奇数，从 0 开始计数</li>
</ul>
</li>
<li>等于索引选择器<ul>
<li>语法： <code>$(&quot;A:eq(index)&quot;)</code> 指定索引元素</li>
</ul>
</li>
<li>大于索引选择器 <ul>
<li>语法： <code>$(&quot;A:gt(index)&quot;)</code> 大于指定索引元素</li>
</ul>
</li>
<li>小于索引选择器 <ul>
<li>语法： <code>$(&quot;A:lt(index)&quot;)</code> 小于指定索引元素</li>
</ul>
</li>
<li>标题选择器<ul>
<li>语法： <code>$(&quot;:header&quot;)</code> 获得标题（h1~h6）元素，固定写法</li>
</ul>
</li>
</ol>
</li>
<li><p>表单过滤选择器</p>
<ol>
<li>可用元素选择器 <pre><code>* 语法： `:enabled`获得可用元素</code></pre></li>
<li>不可用元素选择器 <ul>
<li>语法：<code>:disabled</code> 获得不可用元素</li>
</ul>
</li>
<li>选中选择器 <ul>
<li>语法：<code>:checked</code> 获得<strong>单选/复选框</strong>选中的元素</li>
</ul>
</li>
<li>选中选择器 <ul>
<li>语法：<code>:selected</code> 获得<strong>下拉框</strong>选中的元素</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h2><h3 id="内容操作"><a href="#内容操作" class="headerlink" title="内容操作"></a>内容操作</h3><ol>
<li><code>html()</code> –&gt; 获取/设置元素的标签体内容</li>
<li><code>text()</code> –&gt; 获取元素的标签体纯文本内容，设置元素的标签体内容</li>
<li><code>val()</code> –&gt; 获取/设置元素的value属性值</li>
</ol>
<h3 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h3><ol>
<li><p>通用属性操作</p>
<ol>
<li>attr() –&gt;  获取/设置<strong>自定义元素</strong>的属性</li>
<li>removeAttr() –&gt; 删除属性</li>
<li>prop() –&gt; 获取/设置<strong>固有元素</strong>的属性</li>
<li>removeProp() –&gt; 删除属性</li>
</ol>
</li>
<li><p>对class属性的操作</p>
<ol>
<li>addClass() –&gt; 添加class属性的值</li>
<li>removeClass() –&gt; 删除class属性的值</li>
<li>toggleClass() –&gt; 切换class属性</li>
</ol>
</li>
</ol>
<h3 id="CRUD操作"><a href="#CRUD操作" class="headerlink" title="CRUD操作"></a>CRUD操作</h3><ol>
<li>append():父元素将子元素追加到末尾<pre><code>* 对象1.append(对象2): 将对象2添加到对象1元素内部，并且在末尾</code></pre></li>
<li>prepend():父元素将子元素追加到开头<ul>
<li>对象1.prepend(对象2):将对象2添加到对象1元素内部，并且在开头</li>
</ul>
</li>
<li>appendTo():<ul>
<li>对象1.appendTo(对象2):将对象1添加到对象2内部，并且在末尾</li>
</ul>
</li>
<li>prependTo()：<ul>
<li>对象1.prependTo(对象2):将对象1添加到对象2内部，并且在开头</li>
</ul>
</li>
</ol>
<hr>
<ol start="5">
<li><p>after():添加元素到元素后边</p>
<pre><code>* 对象1.after(对象2)： 将对象2添加到对象1后边。对象1和对象2是兄弟关系</code></pre></li>
<li><p>before():添加元素到元素前边</p>
<ul>
<li>对象1.before(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系</li>
</ul>
</li>
<li><p>insertAfter()</p>
<ul>
<li>对象1.insertAfter(对象2)：将对象1添加到对象2后边。对象1和对象2是兄弟关系</li>
</ul>
</li>
<li><p>insertBefore()</p>
<ul>
<li>对象1.insertBefore(对象2)： 将对象1添加到对象2前边。对象1和对象2是兄弟关系</li>
</ul>
</li>
</ol>
<hr>
<ol start="9">
<li><p>remove():移除元素</p>
<ul>
<li>对象.remove():将对象删除掉</li>
</ul>
</li>
<li><p>empty():清空元素的所有后代元素。</p>
<ul>
<li>对象.empty():将对象的后代元素全部清空，但是保留当前对象以及其属性节点</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>EL &amp; JSTL</title>
    <url>/2019/05/26/Java/2.JavaWeb/12.EL%20&amp;%20JSTL/</url>
    <content><![CDATA[<p>EL : Expression Language : 替换和简化 jsp 页面中 Java 代码的编写</p>
<p>JSTL : Java Server pages Tag Library : jsp 标签库</p>
<a id="more"></a>

<h1 id="EL-表达式"><a href="#EL-表达式" class="headerlink" title="EL 表达式"></a>EL 表达式</h1><p>概念：Expression Language  表达式语言</p>
<p>作用：替换和简化 jsp 页面中 Java 代码的编写</p>
<p>语法：<code>${表达式}</code></p>
<p>注意：在 jsp 页面中默认支持 EL 表达式，如果想忽略 EL 表达式，有两种方法</p>
<ul>
<li>在 <code>page</code> 指令中添加属性 <code>isElIgnored=&quot;true&quot;</code>，可以忽略当前页面中所有的EL表达式</li>
<li>在 EL 表达式前加 <code>\</code> ,即 <code>\${表达式}</code>，可以忽略这个表达式</li>
</ul>
<h3 id="EL-表达式的使用"><a href="#EL-表达式的使用" class="headerlink" title="EL 表达式的使用"></a>EL 表达式的使用</h3><p><strong>1、运算符</strong></p>
<p>在 EL 表达式中可以直接进行运算，可以使用的运算符有以下几种：</p>
<ul>
<li>算术运算符：+ - * / %</li>
<li>比较运算符：&gt;  &lt;  &gt;=  &lt;=  == !=</li>
<li>逻辑运算符：&amp;&amp;  ||  !</li>
<li>空运算符：empty<ul>
<li>作用：用于判断字符串、集合、数组对象 <strong>是否为 null</strong> 或者 <strong>长度是否为 0</strong>，返回 true 或 false</li>
<li>用法：<code>${empty list}</code> / <code>${not empty list}</code></li>
</ul>
</li>
</ul>
<hr>
<p><strong>2、获取值</strong></p>
<p>EL 表达式只能从<strong>域对象</strong>中获取值</p>
<p>语法：</p>
<ul>
<li><p><code>${域名称.键名}</code>：从指定域中获取指定键的值</p>
<table>
<thead>
<tr>
<th align="center">域名称（从小到大）</th>
<th align="center">对象名</th>
</tr>
</thead>
<tbody><tr>
<td align="center">pageScope</td>
<td align="center">pageContext</td>
</tr>
<tr>
<td align="center">requestScope</td>
<td align="center">request</td>
</tr>
<tr>
<td align="center">sessionScope</td>
<td align="center">session</td>
</tr>
<tr>
<td align="center">applicationScope</td>
<td align="center">application</td>
</tr>
</tbody></table>
</li>
<li><p><code>${键名}</code>：从最小的域开始往大的域查找是否有该键，直到找到为止</p>
</li>
</ul>
<p>获取对象、List 集合、Map 集合中的值：</p>
<ul>
<li><p>获取对象的值：<code>${域名称.键名.属性名}</code></p>
<ul>
<li>这种获取方法本质上会去调用对象的 getter 方法，</li>
<li>属性名其实是 getter 方法名去掉 getter 后剩余部分首字母变小写，通常情况下就和成员变量名一样</li>
</ul>
</li>
<li><p>获取 List 集合中的值：<code>${域名称.键名[索引]}</code></p>
</li>
<li><p>获取 Map 集合中的值：</p>
<ul>
<li><code>${域名称.键名.key}</code></li>
<li><code>${域名称.键名[&quot;key&quot;]}</code></li>
</ul>
</li>
</ul>
<h3 id="隐式对象"><a href="#隐式对象" class="headerlink" title="隐式对象"></a>隐式对象</h3><p>EL 表达式中共有 11 个隐式对象，类似于 jsp 的内置对象</p>
<ul>
<li>pageContext：最常用的隐式对象就这一个<ul>
<li>作用：获取 jsp 的其它 8 个内置对象</li>
<li>使用：<code>${pageContext.request.contextPath}</code>：动态获取虚拟目录 ☆</li>
</ul>
</li>
</ul>
<h1 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h1><p>概念：Java Server pages Tag Library ：jsp 标签库</p>
<p>作用：用于简化和替换 jsp 页面上的 Java 代码</p>
<p>使用：在使用之前需要先引入标签库</p>
<ul>
<li><code>&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</code></li>
</ul>
<hr>
<h3 id="常用的-JSTL-标签"><a href="#常用的-JSTL-标签" class="headerlink" title="常用的 JSTL 标签"></a>常用的 JSTL 标签</h3><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><p>相当于 Java 代码的 <strong>if 语句</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%-- test属性为必须的，当test中表达式为<span class="keyword">true</span>时，执行标签体中的代码 --%&gt;</span><br><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">"boolean表达式"</span>&gt;</span><br><span class="line">    &lt;h1&gt;jstl的if标签&lt;/h1&gt;</span><br><span class="line">&lt;/c:if&gt;</span><br></pre></td></tr></table></figure>



<h4 id="choose"><a href="#choose" class="headerlink" title="choose"></a>choose</h4><p>相当于 Java 代码的 <strong>switch 语句</strong></p>
<ul>
<li>choose –&gt; switch</li>
<li>when –&gt; case</li>
<li>otherwise –&gt; default</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">	request.setAttribute(<span class="string">"number"</span>,<span class="number">3</span>);</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:choose&gt;</span><br><span class="line">	&lt;c:when test="$&#123;number == 1&#125;"&gt;星期一&lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test="$&#123;number == 2&#125;"&gt;星期二&lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test="$&#123;number == 3&#125;"&gt;星期三&lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test="$&#123;number == 4&#125;"&gt;星期四&lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test="$&#123;number == 5&#125;"&gt;星期五&lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test="$&#123;number == 6&#125;"&gt;星期六&lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test="$&#123;number == 7&#125;"&gt;星期七&lt;/c:when&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;c:otherwise&gt;数据输入有误&lt;/c:otherwise&gt;</span><br><span class="line">&lt;/c:choose&gt;</span><br></pre></td></tr></table></figure>



<h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><p>相当于 Java 代码的 <strong>for 语句</strong></p>
<p>foreach 标签具有两个功能：</p>
<ul>
<li><p>完成重复的操作</p>
<ul>
<li>begin：开始值</li>
<li>end：结束值（也包括）</li>
<li>var：临时变量</li>
<li>step：步长</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;c:foreach begin=<span class="string">"0"</span> end=<span class="string">"9"</span> <span class="keyword">var</span>=<span class="string">"i"</span> step=<span class="string">"1"</span>&gt;</span><br><span class="line">	$&#123;i&#125;</span><br><span class="line">&lt;/c:foreach&gt;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>遍历容器</p>
<ul>
<li>items：容器对象</li>
<li>var：临时变量</li>
<li>varStatus：循环状态对象<ul>
<li>index：容器中元素的索引，从 0 开始</li>
<li>count：循环次数，从1开始</li>
</ul>
</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;c:foreach items=<span class="string">"list"</span> <span class="keyword">var</span>=<span class="string">"str"</span> varStatus=<span class="string">"s"</span>&gt;</span><br><span class="line">	$&#123;str&#125;</span><br><span class="line">&lt;/c:foreach&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>EL</tag>
        <tag>JSTL</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2019/05/26/Java/Redis/</url>
    <content><![CDATA[<p>Redis 是一款典型的内存数据库</p>
<a id="more"></a>

<h2 id="Redis-简介"><a href="#Redis-简介" class="headerlink" title="Redis 简介"></a>Redis 简介</h2><p>Redis（<strong>Re</strong>mote <strong>Di</strong>rectory <strong>S</strong>erver）：远程字典服务，由 C 语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库，属于非关系型数据库（NoSQL），可以作为<strong>数据库</strong>、<strong>缓存</strong>和<strong>消息中间件</strong>。</p>
<blockquote>
<p>NoSQL：Not Only SQL</p>
</blockquote>
<p>关系型数据库 和 非关系型数据库的区别:</p>
<ul>
<li>关系型数据库:<ul>
<li>数据之间有联系</li>
<li>数据存储在硬盘的文件上</li>
</ul>
</li>
<li>非关系型数据库<ul>
<li>数据之间没有关系</li>
<li>数据存储在内存中</li>
</ul>
</li>
</ul>
<blockquote>
<p>关系型数据库和非关系型数据库是一种互补的状态</p>
<p>一般将数据存储在关系型数据库中, 在非关系型数据库中备份存储关系型数据库中的数据</p>
</blockquote>
<h2 id="Redis-安装"><a href="#Redis-安装" class="headerlink" title="Redis 安装"></a>Redis 安装</h2><blockquote>
<p>Redis 官方推荐在 Linux 上使用，而且官方只提供了 Linux 的安装包。</p>
<p>Windows 版本的 Redis 一直是微软维护的，但是也好久没有更新了。</p>
</blockquote>
<p><strong>Redis 在 Linux 上的安装步骤：</strong></p>
<ol>
<li><p>官网下载 <code>.tar.gz</code> 压缩包</p>
</li>
<li><p>把解压缩后的文件夹放到 <code>/usr/local</code> 目录下</p>
</li>
<li><p>cd 到解压后的文件夹，执行 <code>make</code> 命令编译 Redis</p>
<blockquote>
<p>因为 Redis 是 C 语言编写的，所以编译需要 gcc，</p>
<p>安装 gcc：<code>yum install gcc-c++</code></p>
<blockquote>
<p>踩坑记录：</p>
<p>我下载的 Redis 是 6.2.1 版本的，而 yum 自动安装的 gcc 是 4.8.5 版本，此时 <code>make</code> 会报错，需要升级 gcc</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 依次执行下列命令升级 gcc 到 9.x.x 版本</span></span><br><span class="line">yum -y install centos-release-scl</span><br><span class="line"> </span><br><span class="line">yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils</span><br><span class="line"> </span><br><span class="line">scl <span class="built_in">enable</span> devtoolset-9 bash</span><br><span class="line"> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"source /opt/rh/devtoolset-9/enable"</span> &gt;&gt; /etc/profile</span><br><span class="line"> </span><br><span class="line">gcc -v	<span class="comment"># 查看 gcc 版本</span></span><br></pre></td></tr></table></figure>

<p>升级完 gcc 版本如果 <code>make</code> 还是报错，则执行下面命令清理一下就好了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make distclean</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
</li>
<li><p>编译完成后，执行下面命令安装 Redis</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置PREFIX可以让Redis相关的文件都存放在 usr/local/redis 相关目录下，方便以后操作</span></span><br><span class="line">make PREFIX=/usr/<span class="built_in">local</span>/redis install</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装完成，<code>redis-server</code> 和 <code>redis-cli</code> 都会放在 <code>/user/local/redis/bin</code> 目录下。</p>
<p><img src="/images/Redis/image-20210418183342979.png" alt="image-20210418183342979"></p>
</li>
<li><p>Redis 的配置文件 <code>redis.conf</code> 会放在 <code>/user/local/redis</code> 目录下。启动 Redis 服务前，需要修改配置文件： <code>daemonize yes</code>，意思是让 Redis 服务以守护线程的方式启动（也就是后台运行）</p>
</li>
<li><p>启动 Redis 服务：<code>./redis-server ../redis.conf</code></p>
<p><img src="/images/Redis/image-20210418184239104.png" alt="image-20210418184239104"></p>
<blockquote>
<p>查看 Redis 服务进程：<code>ps -ef | grep redis</code></p>
</blockquote>
</li>
<li><p>启动 Redis 客户端，操作 Redis：<code>./redis-cli</code></p>
<p><img src="/images/Redis/image-20210418184103343.png" alt="image-20210418184103343"></p>
</li>
</ol>
<h2 id="Redis-基本知识"><a href="#Redis-基本知识" class="headerlink" title="Redis 基本知识"></a>Redis 基本知识</h2><p>Redis 默认有 16 个数据库，可以在 <code>redis.conf</code> 配置文件中看到</p>
<p><img src="/images/Redis/image-20210419080132793.png" alt="image-20210419080132793"></p>
<p>切换数据库：<code>SELECT &lt;dbid&gt;</code></p>
<p><img src="/images/Redis/image-20210419080902336.png" alt="image-20210419080902336"></p>
<p>查看当前数据库大小：<code>DBSIZE</code></p>
<p><img src="/images/Redis/image-20210419080933127.png" alt="image-20210419080933127"></p>
<p>清除当前数据库数据：<code>FLUSHDB</code></p>
<p>清除所有数据库数据：<code>FLUSHALL</code></p>
<blockquote>
<p>Redis 是单线程的</p>
<p>因为多线程并不一定所有情况下都比单线程快，多线程时 CPU 上下文切换比较耗时。</p>
<p>Redis 的所有数据都是存在内存中的，与 CPU 交互使用单线程是效率最高的。</p>
<p>Redis 的瓶颈并不是 CPU，而是内存和网络带宽。</p>
</blockquote>
<h2 id="Redis-五大数据类型"><a href="#Redis-五大数据类型" class="headerlink" title="Redis 五大数据类型"></a>Redis 五大数据类型</h2><p>Redis 中 key 都是字符串, value 则有 5 种不同的数据类型</p>
<p>value 的数据类型:</p>
<ol>
<li>字符串类型 String</li>
<li>哈希类型 hash  (map格式)</li>
<li>列表类型 list  (linkedlist格式)</li>
<li>集合类型 set</li>
<li>有序集合类型 sortedset</li>
</ol>
<p><strong>通用操作</strong>:</p>
<ul>
<li><code>keys *</code>  查询所有键</li>
<li><code>exists key</code> 判断 key 是否存在</li>
<li><code>type key</code>  获取 <code>key</code> 对应的 <code>value</code> 的类型</li>
<li><code>expire key seconds</code>：设置 key 的过期时间</li>
<li><code>ttl key</code>：查看 key 的剩余过期时间</li>
<li><code>del key</code>  删除指定的 key value</li>
</ul>
<h3 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> name zhangsan			<span class="comment"># 设置值</span></span><br><span class="line">get name					<span class="comment"># 获取值</span></span><br><span class="line">del name					<span class="comment"># 删除</span></span><br><span class="line"></span><br><span class="line">append name good			<span class="comment"># 追加字符串，如果key不存在，相当于set，</span></span><br><span class="line">strlen name					<span class="comment"># 获取字符串的长度</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">incr views					<span class="comment"># 自增1，浏览量 +1</span></span><br><span class="line">decr views					<span class="comment"># 自减1，浏览量 -1</span></span><br><span class="line"></span><br><span class="line">incrby views 10				<span class="comment"># 自定义自增步长</span></span><br><span class="line">decrby views 10				<span class="comment"># 自定义自减步长</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">getrange tel 2 5			<span class="comment"># 截取字符串 [2,5]</span></span><br><span class="line">setrange tel 2 xx			<span class="comment"># 替换字符串，从第2个开始替换（包括第二个） </span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">setex cookie 100 azzzz		<span class="comment"># 设置值，同时设置失效时间（100秒后失效）</span></span><br><span class="line">setnx cookie axxxxx			<span class="comment"># 当 cookie 不存在时才能设置值</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">mset k1 v1 k2 v2 k3 v3		<span class="comment"># 同时设置多个值</span></span><br><span class="line">mget k1 k2 k3				<span class="comment"># 同时获取多个值</span></span><br><span class="line"></span><br><span class="line">msetnx k1 v1 k4 v4			<span class="comment"># 当多个值都不存在的时候才能设置成功，具有原子性</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="built_in">set</span> user:1:name zhangsan	<span class="comment"># key 可以设置为 user:&#123;id&#125;:&#123;field&#125; 的形式，保存对象常用</span></span><br><span class="line">get user:1:name				<span class="comment"># 获取值</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">getset name wangwu			<span class="comment"># 先获取值再设置值</span></span><br></pre></td></tr></table></figure>



<h3 id="List-类型"><a href="#List-类型" class="headerlink" title="List 类型"></a>List 类型</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># key为列表名,  列表中的元素都为String</span></span><br><span class="line"><span class="comment"># 写列表中的元素时不用加引号，Redis会把输入的内容自动转为String</span></span><br><span class="line">lpush key element				<span class="comment"># 从列表的左边添加元素（可以一次添加多个）</span></span><br><span class="line">rpush key element				<span class="comment"># 从列表的右边添加元素（可以一次添加多个）</span></span><br><span class="line"></span><br><span class="line">lrange key start end			<span class="comment"># 获取列表指定范围内的元素 [start, end]</span></span><br><span class="line"></span><br><span class="line">lpop key						<span class="comment"># 删除列表最左边的元素并返回</span></span><br><span class="line">rpop key						<span class="comment"># 删除列表最右边的元素并返回</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">lindex key index				<span class="comment"># 通过 index 下标获取值</span></span><br><span class="line">llen key						<span class="comment"># 获取列表的长度</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">lrem key count element			<span class="comment"># 从列表中移除 count 数量的指定 element（从左边移除）</span></span><br><span class="line"></span><br><span class="line">ltrim key start end				<span class="comment"># 截取指定区间的元素 [start, end]，列表就只剩截取后的元素</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">rpoplpush <span class="built_in">source</span> dest			<span class="comment"># 将列表中的最后一个元素移动到新列表第一个位置，如果新列表不存在则会创建</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">lset key 0 aa					<span class="comment"># 将列表中第 0 个元素替换为 aa，如果列表或下标不存在都会报错</span></span><br><span class="line">linsert key before element aa 	<span class="comment"># 将aa插入到指定element的前面</span></span><br><span class="line">linsert key after element bb 	<span class="comment"># 将bb插入到指定element的后面</span></span><br></pre></td></tr></table></figure>



<h3 id="Set-类型"><a href="#Set-类型" class="headerlink" title="Set 类型"></a>Set 类型</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># key为集合名, 集合中的元素都为String</span></span><br><span class="line">sadd key element			<span class="comment"># 向集合中添加元素（可以一次添加多个）</span></span><br><span class="line"></span><br><span class="line">smembers key  				<span class="comment"># 获取集合中所有元素</span></span><br><span class="line">sismember key element		<span class="comment"># 判断指定的element是否在集合中</span></span><br><span class="line"></span><br><span class="line">srem key element  			<span class="comment"># 删除集合中指定元素</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">scard key					<span class="comment"># 获取集合中元素的个数</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">srandmember key				<span class="comment"># 随机获取集合中的一个元素</span></span><br><span class="line">srandmember key count		<span class="comment"># 随机获取集合中的 count 个元素</span></span><br><span class="line"></span><br><span class="line">spop key					<span class="comment"># 随机删除集合中的一个元素</span></span><br><span class="line">spop key count				<span class="comment"># 随机删除集合中的 count 个元素</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">smove <span class="built_in">source</span> dest element	<span class="comment"># 将指定元素移动到另一个集合中，如果目标集合不存在则会创建</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">sdiff key1 key2				<span class="comment"># 差集，获取key1中不同于key2的元素			</span></span><br><span class="line">sinter key1 key2			<span class="comment"># 交集，可应用于 共同关注</span></span><br><span class="line">sunion key1 key2			<span class="comment"># 并集</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>应用：像交集，可以应用于 微博的共同关注</p>
</blockquote>
<h3 id="Hash-类型"><a href="#Hash-类型" class="headerlink" title="Hash 类型"></a>Hash 类型</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hset key field value		<span class="comment"># 向 map 中添加键值对（可以一次添加多个）</span></span><br><span class="line">hget key field  			<span class="comment"># 获取指定 field 对应的值（一次只能获取一个）</span></span><br><span class="line">hdel key field				<span class="comment"># 删除指定 field 的值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hmset key field1 value1 field2 value2	<span class="comment"># 向map中添加多个键值对，和 hset 用法一样</span></span><br><span class="line">hmget key field1 field2					<span class="comment"># 一次获取多个 field 的值</span></span><br><span class="line"></span><br><span class="line">hgetall key  				<span class="comment"># 获取 key 对应的所有的 field 和 value</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">hlen key					<span class="comment"># 获取 key 中键值对的数量</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">hexists key field			<span class="comment"># 判断指定 field 是否存在</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">hkeys key					<span class="comment"># 获取key中所有 field</span></span><br><span class="line">hvals key					<span class="comment"># 获取key中所有 value</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="comment"># map 中没有 decrby，使用负数就是减少</span></span><br><span class="line">hincrby key field 3			<span class="comment"># 指定 field 的值加 3</span></span><br><span class="line">hincrby key field -2		<span class="comment"># 指定 field 的值减 2</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">hsetnx key field value		<span class="comment"># 如果 field 不存在，则新增键值对；如果存在，则会报错</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>相较于 String 中使用 <code>user:1:name</code> 来存储对象信息来说，Hash 更适合存储对象信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hset user:1 name zhangsan</span><br><span class="line">hset user:1 age 24</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Zset（有序集合）-类型"><a href="#Zset（有序集合）-类型" class="headerlink" title="Zset（有序集合） 类型"></a>Zset（有序集合） 类型</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># key为集合名, 通过 score 来排序</span></span><br><span class="line">zadd key score member  			<span class="comment"># 向有序集合中添加元素，同时添加score，用于排序</span></span><br><span class="line">zrange key start end  			<span class="comment"># 获取指定范围内的元素[start, end]，升序排列，start，end为排序后元素下标</span></span><br><span class="line">zrem key member					<span class="comment"># 移除指定元素</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">zcard key						<span class="comment"># 获取有序集合中元素数量</span></span><br><span class="line">zcount key min max				<span class="comment"># 获取指定区间的元素数量，min和max为score</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">zrangebyscore key min max				<span class="comment"># 通过 score 排序（升序），获取区间中的所有值，min和max为score</span></span><br><span class="line">zrangebyscore key min max withscores	<span class="comment"># 通过 score 排序（升序），获取区间中的所有值和对应score，min和max为score</span></span><br><span class="line"></span><br><span class="line">zrevrangebyscore key max min			<span class="comment"># 通过 score 排序（降序），获取区间中的所有值，min和max为score</span></span><br><span class="line">zrevrangebyscore key max min withscores <span class="comment"># 通过 score 排序（降序），获取区间中的所有值和对应score，min和max为score</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>应用：可以用于实现排行榜</p>
</blockquote>
<h2 id="Redis-三种特殊的数据类型"><a href="#Redis-三种特殊的数据类型" class="headerlink" title="Redis 三种特殊的数据类型"></a>Redis 三种特殊的数据类型</h2><h3 id="Geospatial-地理位置"><a href="#Geospatial-地理位置" class="headerlink" title="Geospatial 地理位置"></a>Geospatial 地理位置</h3><blockquote>
<p>微信附近的人，地图中两点之间的距离，都可以使用 Geospatial 来实现</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># longitude 经度，latitude 纬度</span></span><br><span class="line">geoadd key longitude latitude member		<span class="comment"># 添加地理位置</span></span><br><span class="line"><span class="comment"># 例: </span></span><br><span class="line"><span class="comment"># geoadd city 104.46 31.25 mianyang</span></span><br><span class="line"><span class="comment"># geoadd city 116.36 35.42 jiaxiang</span></span><br><span class="line"></span><br><span class="line">geodist key member1 member2 km				<span class="comment"># 获取两点之间的直线距离，默认单位是 m，可以手动切换为 km</span></span><br><span class="line"><span class="comment"># 127.0.0.1:6379&gt; GEODIST city mianyang jiaxiang</span></span><br><span class="line"><span class="comment"># "1198081.4135"</span></span><br><span class="line"><span class="comment"># 127.0.0.1:6379&gt; GEODIST city mianyang jiaxiang km</span></span><br><span class="line"><span class="comment"># "1198.0814"</span></span><br><span class="line"></span><br><span class="line">geopos key member							<span class="comment"># 获取指定member的经纬度信息（可以一次获取多个）</span></span><br><span class="line"><span class="comment"># 127.0.0.1:6379&gt; GEOPOS city jiaxiang mianyang</span></span><br><span class="line"><span class="comment"># 1) 1) "116.36000186204910278"</span></span><br><span class="line"><span class="comment">#    2) "35.41999957443380964"</span></span><br><span class="line"><span class="comment"># 2) 1) "104.46000069379806519"</span></span><br><span class="line"><span class="comment">#    2) "31.25000052442617715"</span></span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">georadius key longitude latitude radius km	<span class="comment"># 从key中获取指定经纬度位置方圆radius km内的 member</span></span><br><span class="line"><span class="comment"># 例：在city中寻找 108.95 34.29（西安市）方圆1000km的城市</span></span><br><span class="line"><span class="comment"># 127.0.0.1:6379&gt; GEORADIUS city 108.95 34.29  1000 km</span></span><br><span class="line"><span class="comment"># 1) "mianyang"</span></span><br><span class="line"><span class="comment"># 2) "jiaxiang"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># withdist：显示距离信息, withcoord：显示坐标信息, count：查询的数量</span></span><br><span class="line">georadius key longitude latitude radius km withdist withcoord count 2</span><br><span class="line"></span><br><span class="line">georadiusbymember key member radius km 		<span class="comment"># 获取指定member方圆radius km内的member</span></span><br><span class="line"><span class="comment"># 127.0.0.1:6379&gt; GEORADIUSBYMEMBER city jiaxiang 2000 km</span></span><br><span class="line"><span class="comment"># 1) "mianyang"</span></span><br><span class="line"><span class="comment"># 2) "jiaxiang"</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>geospatial 并没有直接提供删除 member 的命令，我们可以使用其底层实现来操作。</p>
<p>geospatial 底层使用的是 Zset</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange city 0 -1		<span class="comment"># 查询city中所有member</span></span><br><span class="line">1) <span class="string">"mianyang"</span></span><br><span class="line">2) <span class="string">"jiaxiang"</span></span><br><span class="line">127.0.0.1:6379&gt; zrem city jiaxiang		<span class="comment"># 移除指定member</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange city 0 -1</span><br><span class="line">1) <span class="string">"mianyang"</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h3><blockquote>
<p>统计网站访问人数（同一个人多次访问只记一次），可以使用 hyperloglog 实现</p>
</blockquote>
<p>Hyperloglog 是基数统计算法</p>
<p>基数：简单来说就是一个集合中有多少个不同的元素</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pfadd key element				<span class="comment"># 向key中添加元素（可以一次添加多个）</span></span><br><span class="line"></span><br><span class="line">pfcount key						<span class="comment"># 统计key中元素的基数</span></span><br><span class="line"></span><br><span class="line">pfmerge dest source1 source2	<span class="comment"># 合并两个组到dest中</span></span><br></pre></td></tr></table></figure>



<p>只是计数的情况下，使用 Hyperloglog 是非常有优势的，因为它占用内存最大只有 12k。</p>
<p>在大量的数据下，Hyperloglog 的错误率约为 0.81% ，统计网站访问人数时，这个可以忽略。</p>
<p>但是如果不允许出错的情况下，就不能使用 Hyperloglog 了。</p>
<h3 id="Bitmap-位图"><a href="#Bitmap-位图" class="headerlink" title="Bitmap 位图"></a>Bitmap 位图</h3><blockquote>
<p>记录用户是否登录，活动是否打卡等只有两种状态（0, 1）的信息，就可以使用位图。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setbit key offset value			<span class="comment"># 将key中offset位置的值设为value（0/1）</span></span><br><span class="line"></span><br><span class="line">getbit key offset				<span class="comment"># 获取key中offset位置的值</span></span><br><span class="line"></span><br><span class="line">bitcount key					<span class="comment"># 统计key中value为1的数量</span></span><br></pre></td></tr></table></figure>





<h2 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h2><p>Redis 的事务与 MySQL 事务的区别：</p>
<ul>
<li>Redis 的事务不保证原子性</li>
<li>Redis 的事务没有隔离级别的概念</li>
</ul>
<p>如何使用 Redis 的事务：</p>
<ol>
<li>开启事务：<code>multi</code></li>
<li>命令入队</li>
<li>执行事务：<code>exec</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Redis执行一次事务</span></span><br><span class="line">127.0.0.1:6379&gt; multi			<span class="comment"># 开启事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED							<span class="comment"># QUEUED 表示这条命令已经入队</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span>		<span class="comment"># 执行事务，依次列出每条命令的执行结果</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) <span class="string">"v2"</span></span><br><span class="line">4) OK</span><br></pre></td></tr></table></figure>



<blockquote>
<p>取消事务：<code>discard</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi			<span class="comment"># 开启事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k4 v4</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; get k4</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; DISCARD		<span class="comment"># 取消事务，已经入队的命令都不会执行</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get k4			</span><br><span class="line">(nil)							<span class="comment"># 无法获取k4的值，说明上面入队的命令没有执行</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>Redis 事务中有命令出现问题，其他命令的执行分两种情况：</p>
<ol>
<li><p>有命令错误（编译时异常）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2				<span class="comment"># 命令写错，入队时就提示错误信息</span></span><br><span class="line">(error) ERR wrong number of arguments <span class="keyword">for</span> <span class="string">'set'</span> <span class="built_in">command</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; get k1				<span class="comment"># 后续的命令任然能够正常入队</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span>				<span class="comment"># 但是事务无法执行，事务中的所有命令也都不会执行</span></span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>命令没错，但执行时出错（运行时异常）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; incr k1			<span class="comment"># k1的值为String，无法使用incr，所以这条命令运行时会报错</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span>			<span class="comment"># 执行事务，只有第三条命令报错，但没有影响其他命令的执行</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) (error) ERR value is not an <span class="built_in">integer</span> or out of range</span><br><span class="line">4) <span class="string">"v2"</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<p><strong>Redis 中实现乐观锁：</strong></p>
<blockquote>
<p>悲观锁和乐观锁：</p>
<ul>
<li><p>悲观锁：很悲观，认为任何时候都会出问题，所以把所有操作都加锁</p>
</li>
<li><p>乐观锁：很乐观，认为什么时候都不会出问题，所以不会上锁。</p>
<p>会获取一个 Version，在更新数据的时候比较 Version。</p>
</li>
</ul>
</blockquote>
<p>在 Redis 中使用 <code>Watch</code> 可以实现乐观锁</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> mymoney 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> yourmoney 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch mymoney		<span class="comment"># 开启监控（可以一次监控多个）</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; decrby mymoney 20</span><br><span class="line">QUEUED												<span class="comment"># 在开启监控之后，事务执行之前，mymoney的值被另一个用户修改成200</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; incrby yourmoney 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span>			<span class="comment"># 执行事务时会对比监控的值，如果值没变化，事务执行成功。如果值变化了，事务就会执行失败</span></span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; unwatch				<span class="comment"># 事务执行失败后，需要先解除监控</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch mymoney		<span class="comment"># 重新监控</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; decrby mymoney 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; incrby yourmoney 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 180</span><br><span class="line">2) (<span class="built_in">integer</span>) 120</span><br></pre></td></tr></table></figure>





<h2 id="Java-操作-Redis"><a href="#Java-操作-Redis" class="headerlink" title="Java 操作 Redis"></a>Java 操作 Redis</h2><blockquote>
<p>Java 使用 <code>Jedis</code> 来操作 Redis</p>
</blockquote>
<p>导入 Jedis 的 jar 包：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>Jedis 的基本使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickGetStart</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建连接</span></span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 执行命令</span></span><br><span class="line">    jedis.set(<span class="string">"username"</span>, <span class="string">"zhangsan"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 关闭连接</span></span><br><span class="line">    jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Jedis 中执行命令的方法名称就是 Redis 的命令名称</p>
</blockquote>
<p><strong>Jedis 连接池</strong></p>
<blockquote>
<p>Jedis 自带连接池 <code>JedisPool</code></p>
</blockquote>
<p>创建连接池并从连接池中获取连接:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建连接池(调用空参构造)</span></span><br><span class="line">    JedisPool jedisPool = <span class="keyword">new</span> JedisPool(<span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    Jedis jedis = JedisPool.getResource();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 jedis</span></span><br><span class="line">    jedis.set(<span class="string">"hello"</span>, <span class="string">"你好"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 归还连接</span></span><br><span class="line">    jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以创建 JedisPoolConfig 对象对 JedisPool 进行配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建配置对象, 配置连接池</span></span><br><span class="line">    JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">    config.setMaxTotal(<span class="number">50</span>);  <span class="comment">// 配置最大连接数</span></span><br><span class="line">    <span class="comment">// 还有很多配置......</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建连接池对象(有参构造)</span></span><br><span class="line">    JedisPool jedisPool = <span class="keyword">new</span> JedisPool(config, <span class="string">"localhost"</span>, <span class="number">6379</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取连接, 使用连接, 归还连接 均同上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="Spring-Boot-集成-Redis"><a href="#Spring-Boot-集成-Redis" class="headerlink" title="Spring Boot 集成 Redis"></a>Spring Boot 集成 Redis</h2><h2 id="Redis-的持久化"><a href="#Redis-的持久化" class="headerlink" title="Redis 的持久化"></a>Redis 的持久化</h2><blockquote>
<p>Redis 有两种持久化模式：RDB 和 AOF</p>
</blockquote>
<h3 id="RDB-Redis-DataBase-–-默认"><a href="#RDB-Redis-DataBase-–-默认" class="headerlink" title="RDB(Redis DataBase) – 默认"></a>RDB(Redis DataBase) – 默认</h3><p>在一定间隔时间内，检测 key 的变化情况，然后持久化数据。默认具体规则如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Unless specified otherwise, by default Redis will save the DB:</span></span><br><span class="line"><span class="comment">#   * After 3600 seconds (an hour) if at least 1 key changed</span></span><br><span class="line"><span class="comment">#   * After 300 seconds (5 minutes) if at least 100 keys changed</span></span><br><span class="line"><span class="comment">#   * After 60 seconds if at least 10000 keys changed</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># save 3600 1</span></span><br><span class="line"><span class="comment"># save 300 100</span></span><br><span class="line"><span class="comment"># save 60 10000</span></span><br><span class="line"></span><br><span class="line">save 30 500			<span class="comment"># 如果自己写了save，默认配置就失效了（但是一般情况都是使用默认规则）</span></span><br></pre></td></tr></table></figure>



<p><strong>RDB 优点：</strong></p>
<ul>
<li>RDB 会单独 fork 一个子进程进行持久化，会先把数据写到一个临时文件中，写好之后再用临时文件替换上次持久化的文件。整个过程中主进程不进行任何的 IO 操作，这样就保证了极高的性能。</li>
</ul>
<p><strong>RDB 缺点：</strong></p>
<ul>
<li><p>最后一次持久化后的数据可能在宕机的情况下丢失。</p>
</li>
<li><p>fork 一个子进程会占用一定的内存。</p>
</li>
</ul>
<p><strong>RDB 文件：</strong></p>
<ul>
<li>文件名：<code>dump.rdb</code></li>
<li>文件位置：<code>redis-server</code> 文件所在目录（又叫 Redis 的启动目录）</li>
<li>从 RDB 恢复数据：Redis 启动的时候会自动加载 <code>dump.rdb</code> 文件并恢复其中的数据</li>
</ul>
<p><strong>什么情况下会激活 RDB 持久化？</strong></p>
<ol>
<li>Redis 的操作满足了 save 中定义的规则</li>
<li>执行 <code>flushall</code> 命令</li>
<li>正常关闭 Redis 服务</li>
</ol>
<p><strong>什么情况适合使用 RDB？</strong></p>
<ul>
<li>数据量较大</li>
<li>对数据的完整性要求不高</li>
</ul>
<h3 id="AOF-Append-Only-File"><a href="#AOF-Append-Only-File" class="headerlink" title="AOF (Append Only File)"></a>AOF (Append Only File)</h3><p>日志记录方式，把 Redis 所有的<strong>写指令</strong>记录到文件中，重启服务器时重新运行所有的写指令，以达到恢复数据的目的</p>
<p><strong>开启 AOF：</strong></p>
<ol>
<li>在 <code>redis.conf</code> 中配置： <code>appendonly yes</code> （默认是 <code>no</code>）</li>
<li>重启 Redis 服务，AOF 才会生效。</li>
</ol>
<p><strong>AOF 有 3 种模式：</strong>(只能选择一种使用，默认使用 <code>appendfsync everysec</code>)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># appendfsync always			# 每次有写指令就持久化</span></span><br><span class="line">appendfsync everysec			<span class="comment"># 每秒持久化，最多丢失一秒的数据</span></span><br><span class="line"><span class="comment"># appendfsync no				# 系统高兴的时候持久化</span></span><br></pre></td></tr></table></figure>



<p><strong>AOF 文件：</strong></p>
<ul>
<li><p>文件名称：<code>appendonly.aof</code></p>
</li>
<li><p>文件内容出现问题，会导致 Redis 启动失败，可以使用 Redis 提供的工具修复文件 <code>redis-check-aof --fix</code>，修复是把有问题的内容删除。</p>
</li>
</ul>
<p><strong>AOF 优点：</strong></p>
<ul>
<li>默认每秒同步一次，数据的完整性更好，最多丢失 1 秒的数据</li>
</ul>
<p><strong>AOF 缺点：</strong></p>
<ul>
<li>频繁的 IO 操作，性能较低</li>
<li>数据量大时，AOF 产生的持久化文件较大，恢复数据比较耗时</li>
</ul>
<h2 id="Redis-发布订阅"><a href="#Redis-发布订阅" class="headerlink" title="Redis 发布订阅"></a>Redis 发布订阅</h2><p>我们使用的微博，微信公众号，群聊，其实都存在发布订阅模式。即发布者发布信息到队列中，订阅者可以从队列中获取信息。</p>
<p><img src="/images/Redis/image-20210420223744148.png" alt="image-20210420223744148"></p>
<p>Redis 中可以实现上述流程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">subscribe channel			<span class="comment"># 订阅频道（channel）</span></span><br><span class="line"></span><br><span class="line">unsubscribe channel			<span class="comment"># 取消订阅频道</span></span><br><span class="line"></span><br><span class="line">publish channel <span class="string">"message"</span>	<span class="comment"># 向频道发布内容</span></span><br></pre></td></tr></table></figure>



<p>实例演示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 订阅者</span></span><br><span class="line">127.0.0.1:6379&gt; SUBSCRIBE chaping				<span class="comment"># 1.订阅 chaping</span></span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">"subscribe"</span></span><br><span class="line">2) <span class="string">"chaping"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1									<span class="comment"># 2.订阅了之后就会在这里等待接收消息</span></span><br><span class="line"></span><br><span class="line">1) <span class="string">"message"</span>									<span class="comment"># 4.订阅者收到信息</span></span><br><span class="line">2) <span class="string">"chaping"</span></span><br><span class="line">3) <span class="string">"hello world"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发布者</span></span><br><span class="line">127.0.0.1:6379&gt; PUBLISH chaping <span class="string">"hello world"</span>	<span class="comment"># 3.发布者往 chaping 上面发布了一条消息</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure>



<p><strong>Redis 发布订阅原理：</strong></p>
<p>Redis 中会维护一个字典，字典中键是频道，值是一个链表，链表中存放了所有的订阅者（<code>subscribe</code> 命令就是将订阅者添加到相应频道的链表中）。</p>
<p>发布者发布消息的时候，Redis 会以频道为键，去字典中查询出对应链表，然后遍历链表，把消息发送给所有订阅者。</p>
<p><strong>使用场景：</strong>实时消息系统，实时聊天系统，关注/订阅系统等</p>
<blockquote>
<p>简单的发布订阅可以使用 Redis 实现，如果比较复杂，可以使用<strong>消息队列</strong>实现</p>
</blockquote>
<h2 id="Redis-主从复制"><a href="#Redis-主从复制" class="headerlink" title="Redis 主从复制"></a>Redis 主从复制</h2><p><strong>概念：</strong>将一台 Redis 服务器的数据复制到其他的 Redis 服务器。前者称为主节点（Master），后者称为从节点（Slave）。</p>
<p><img src="/images/Redis/image-20210421110246270.png" alt="image-20210421110246270"></p>
<blockquote>
<p>Redis 主从复制的特点：</p>
<ul>
<li><p>每个 Redis 服务器默认都是主节点</p>
</li>
<li><p>数据只能从主节点到从节点</p>
</li>
<li><p>一个主节点可以有多个从节点，但一个从节点只能有一个主节点</p>
</li>
</ul>
<p>Redis 主从复制的作用：</p>
<ul>
<li>数据备份：主从复制是除了持久化之外另一种数据备份的方式</li>
<li>故障恢复：当主节点发生故障时，可以由从节点提供服务，实现快速的故障恢复</li>
<li>负载均衡：主节点只提供写操作，从节点只提供读操作，实现读写分离。在写少读多的业务场景下，通过配置多个从节点分担服务器的压力，可以大大提高 Redis 的并发量</li>
<li>高可用：通过主从复制实现集群和哨兵模式，可以大大提高 Redis 的可用性</li>
</ul>
</blockquote>
<h3 id="搭建-Redis-集群"><a href="#搭建-Redis-集群" class="headerlink" title="搭建 Redis 集群"></a>搭建 Redis 集群</h3><blockquote>
<p>因为没有多台服务器，这里搭建单机多服务模式。</p>
</blockquote>
<p>步骤：</p>
<ol>
<li><p>复制多个配置文件，每个服务使用一个配置文件</p>
<p><img src="/images/Redis/image-20210421103749221.png" alt="image-20210421103749221"></p>
</li>
</ol>
<ol start="2">
<li><p>修改每个配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">port 6380							<span class="comment"># 修改端口号</span></span><br><span class="line"></span><br><span class="line">pidfile /var/run/redis_6380.pid		<span class="comment"># </span></span><br><span class="line"></span><br><span class="line">logfile <span class="string">"redis-6380.log"</span>			<span class="comment"># 修改日志文件名称</span></span><br><span class="line"></span><br><span class="line">dbfilename dump-6380.rdb			<span class="comment"># 修改 RDB 文件名称</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>使用不同的配置文件启动多个服务</p>
<p><img src="/images/Redis/image-20210421103908185.png" alt="image-20210421103908185"></p>
<p><img src="/images/Redis/image-20210421104001570.png" alt="image-20210421104001570"></p>
<p><img src="/images/Redis/image-20210421104040770.png" alt="image-20210421104040770"></p>
</li>
</ol>
<ol start="4">
<li><p>检查服务启动情况</p>
<p><img src="/images/Redis/image-20210421104209874.png" alt="image-20210421104209874"></p>
</li>
</ol>
<h3 id="普通主从复制"><a href="#普通主从复制" class="headerlink" title="普通主从复制"></a>普通主从复制</h3><blockquote>
<p>选定 6379 为主节点，6380 和 6381 为从节点</p>
</blockquote>
<p>两种方式配置主从关系</p>
<ol>
<li><p>通过命令（临时）：</p>
<p>因为每个 Redis 服务默认就是主节点，所以不用配置，只配置从节点就可以</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">################# 6379服务默认的主从复制信息 #################</span></span><br><span class="line">127.0.0.1:6379&gt; info replication					<span class="comment"># 查看主从复制信息</span></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master											<span class="comment"># 显示当前服务器角色</span></span><br><span class="line">connected_slaves:0									<span class="comment"># 从机数量</span></span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:6b2779e2af148b3bfa9defc3b3bd7485dade7f21</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure>



</li>
</ol>
   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">################# 6380指定主节点（6381操作一样） #################</span></span><br><span class="line">127.0.0.1:6380&gt; SLAVEOF 127.0.0.1 6379		<span class="comment"># 指定主节点</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6380&gt; info replication			<span class="comment"># 指定主节点后，6380就变成了从节点</span></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1						<span class="comment"># 显示主节点的相关信息</span></span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:8</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:0</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:8fb95e2aca5e3c4e69caf54026a4a1fdc03cf752</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure>



   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">################# 6379现在的主从复制信息 #################</span></span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2												<span class="comment"># 从节点的详细信息</span></span><br><span class="line">slave0:ip=127.0.0.1,port=6380,state=online,offset=784,lag=0</span><br><span class="line">slave1:ip=127.0.0.1,port=6381,state=online,offset=784,lag=0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:8fb95e2aca5e3c4e69caf54026a4a1fdc03cf752</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:784</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:784</span><br></pre></td></tr></table></figure>





<ol start="2">
<li><p>通过配置文件（持久）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">################# 在 Redis 配置文件设置 #################</span></span><br><span class="line">replicaof &lt;masterip&gt; &lt;masterport&gt;		<span class="comment"># 配置主机的 ip 和 port</span></span><br><span class="line"></span><br><span class="line">masterauth &lt;master-password&gt;			<span class="comment"># 如果主机有密码，则配置密码</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>命令配置和配置文件配置的对比：</p>
<ul>
<li>命令配置是临时生效的，如果 Redis 服务重启，那么主从关系就会丢失</li>
<li>配置文件配置是持久生效的，重启服务后，会根据配置文件中的信息自动建立主从关系</li>
</ul>
<blockquote>
<p>主从复制中：主机可以写，从机只能读，不能写</p>
<p>尝试在从机写时，会报错：</p>
<p><img src="/images/Redis/image-20210421122559174.png" alt="image-20210421122559174"></p>
</blockquote>
<blockquote>
<p>主从复制的复制原理：</p>
<p>Slave 成功指定主机之后，会发送一个 Sync 命令给 Master</p>
<p>Master 接收到 Sync 命令后，会把自己的所有数据通过文件发送给 Slave，完成一次全量同步</p>
</blockquote>
<blockquote>
<p>Master 中的内容一定会在 Slave 中</p>
</blockquote>
<p><strong>主从复制的另一种形式：</strong></p>
<p>除了上面的一个 Master 有多个 Slave 的形式，还可以有一种层层链路的形式：</p>
<p><code>Master --&gt; Slave1 --&gt; Slave2</code></p>
<blockquote>
<p>如果 Master 宕机，我们可以手动的修改配置，让一个 Slave 变成新的 Master，另外的 Slave 从属于新的 Master。</p>
<p>上面的两种主从复制的形式我们实际工作中都不会去使用，因为如果主机出现故障，需要手动修改配置实现故障恢复，费时费力，对业务不友好。</p>
<p>实际工作中会使用哨兵模式（主从复制高级版）</p>
</blockquote>
<h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>概念：设置一个哨兵，哨兵会持续监控 Redis 服务器，如果监控到 Master 出现故障，哨兵会自动将某一个 Slave 变为 Master，然后通知其他的 Slave 切换 Master。</p>
<p><img src="/images/Redis/image-20210421120043623.png" alt="image-20210421120043623"></p>
<p>单哨兵模式可能会出现问题（比如哨兵自己的进程崩了），所以实际业务中使用多哨兵模式，就是设置多个哨兵监控 Redis 服务，多个哨兵之间相互监控。</p>
<p><img src="/images/Redis/image-20210421122912946.png" alt="image-20210421122912946"></p>
<p><strong>如何实现哨兵模式：</strong></p>
<ol>
<li><p>配置哨兵的配置文件 <code>sentinel.conf</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这是哨兵的配置文件中最核心的配置，还可以写很多其他的配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel monitor 自定义名称 host port 1</span></span><br><span class="line"><span class="comment"># 最后的数字 1 表示哨兵会在 Master 宕机的情况下自动选取一个新的 Master</span></span><br><span class="line">sentinel monitor myredis 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动哨兵：<code>redis-sentinel 哨兵配置文件</code></p>
<p><img src="/images/Redis/image-20210421121335359.png" alt="image-20210421121335359"></p>
</li>
</ol>
<blockquote>
<p>如果 Master 宕机后又恢复了，恢复后就会变成 Slave，归从在新的 Master 之下。</p>
</blockquote>
<p><strong>哨兵模式优缺点：</strong></p>
<p>优点：</p>
<ul>
<li><p>基于主从复制，具有主从复制的所有优点</p>
</li>
<li><p>可以自动转移故障，使系统可用性更高。</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>Redis 在线扩容不方便，如果集群容量达到上限，在线扩容非常麻烦</li>
<li>哨兵模式配置麻烦</li>
</ul>
<p>哨兵模式的所有配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Example sentinel.conf</span></span><br><span class="line"><span class="comment"># 哨兵sentinel实例运行的端口 默认26379</span></span><br><span class="line">port 26379</span><br><span class="line"></span><br><span class="line"><span class="comment"># 哨兵sentinel的工作目录</span></span><br><span class="line">dir /tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 哨兵sentinel监控的redis主节点的 ip port</span></span><br><span class="line"><span class="comment"># master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符".-_"组成。</span></span><br><span class="line"><span class="comment"># quorum 配置多少个sentinel哨兵统一认为master主节点失联 那么这时客观上认为主节点失联了</span></span><br><span class="line"><span class="comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span></span><br><span class="line"><span class="comment"># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span></span><br><span class="line"><span class="comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class="line">sentinel auth-pass mymaster MySUPER--secret-0123passw0rd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span></span><br><span class="line"><span class="comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，</span></span><br><span class="line">这个数字越小，完成failover所需的时间就越长，</span><br><span class="line">但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。</span><br><span class="line">可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span><br><span class="line"><span class="comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面：</span></span><br><span class="line"><span class="comment">#1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span></span><br><span class="line"><span class="comment">#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span></span><br><span class="line"><span class="comment">#3.当想要取消一个正在进行的failover所需要的时间。</span></span><br><span class="line"><span class="comment">#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span></span><br><span class="line"><span class="comment"># 默认三分钟</span></span><br><span class="line"><span class="comment"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"></span><br><span class="line"><span class="comment"># SCRIPTS EXECUTION</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span></span><br><span class="line"><span class="comment">#对于脚本的运行结果有以下规则：</span></span><br><span class="line"><span class="comment">#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span></span><br><span class="line"><span class="comment">#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span></span><br><span class="line"><span class="comment">#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span></span><br><span class="line"><span class="comment">#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span></span><br><span class="line"><span class="comment">#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span></span><br><span class="line"><span class="comment">#通知脚本</span></span><br><span class="line"><span class="comment"># shell编程</span></span><br><span class="line"><span class="comment"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">sentinel notification-script mymaster /var/redis/notify.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端重新配置主节点参数脚本</span></span><br><span class="line"><span class="comment"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span></span><br><span class="line"><span class="comment"># 以下参数将会在调用脚本时传给脚本:</span></span><br><span class="line"><span class="comment"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span></span><br><span class="line"><span class="comment"># 目前&lt;state&gt;总是“failover”,</span></span><br><span class="line"><span class="comment"># &lt;role&gt;是“leader”或者“observer”中的一个。</span></span><br><span class="line"><span class="comment"># 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通</span></span><br><span class="line">信的</span><br><span class="line"><span class="comment"># 这个脚本应该是通用的，能被多次调用，不是针对性的。</span></span><br><span class="line"><span class="comment"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">sentinel client-reconfig-script mymaster /var/redis/reconfig.sh <span class="comment"># 一般都是由运维来配置！</span></span><br></pre></td></tr></table></figure>





<h2 id="Redis-缓存穿透和雪崩"><a href="#Redis-缓存穿透和雪崩" class="headerlink" title="Redis 缓存穿透和雪崩"></a>Redis 缓存穿透和雪崩</h2>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>JSP</title>
    <url>/2019/05/26/Java/2.JavaWeb/11.JSP/</url>
    <content><![CDATA[<p>jsp 在目前前后端分离的大趋势下已经逐渐被抛弃了…</p>
<a id="more"></a>

<h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><ul>
<li>Java Server pages：Java 服务器端页面</li>
<li>JSP 是一个特殊的页面，既可以指定 HTML 代码，又可以定义 Java 代码</li>
</ul>
<h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>JSP 本质上是一个 Servlet</p>
<ul>
<li>浏览器访问 jsp 时，服务器会把 jsp 转化为一个 <code>.java</code> 文件，这个 <code>.java</code> 文件就是一个 Servlet</li>
</ul>
<h3 id="JSP-脚本"><a href="#JSP-脚本" class="headerlink" title="JSP 脚本"></a>JSP 脚本</h3><p>JSP 的脚本是书写 Java 代码的区域</p>
<ul>
<li><code>&lt;% 代码 %&gt;</code>：这个脚本中的 Java 代码会出现在 service 方法中，该脚本中可以书写方法中可以书写的内容</li>
<li><code>&lt;%! 代码 %&gt;</code>：可以定义成员变量和成员方法</li>
<li><code>&lt;%= 代码 %&gt;</code>：定义的 java 代码，可以直接输出到页面上</li>
</ul>
<h3 id="JSP-指令"><a href="#JSP-指令" class="headerlink" title="JSP 指令"></a>JSP 指令</h3><p>作用：用于配置 JSP 页面，导入资源文件</p>
<p>格式：<code>&lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2 ... %&gt;</code></p>
<p>指令种类：</p>
<ul>
<li><strong>page</strong>：用于配置 JSP 页面<ul>
<li><strong>contentType</strong>：等同于<code>response.setContentType()</code><ul>
<li>设置响应体的 <strong>mime 类型</strong>以及<strong>字符集</strong></li>
<li>在 IDE 中，会自动根据该属性的值，设置当前jsp页面的编码</li>
</ul>
</li>
<li><strong>import</strong>：导 java 包</li>
<li><strong>errorPage</strong>：当页面发生异常后，会自动跳转到指定的错误页面</li>
<li><strong>isErrorPage</strong>：标识当前页面是否是错误页面，如果标识为<code>true</code>，则可以使用内置对象<code>exception</code></li>
</ul>
</li>
<li><strong>taglib</strong>：用于导入资源<ul>
<li><code>&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</code></li>
<li>其中 prefix 为前缀，一般有一些约定俗成名称</li>
</ul>
</li>
<li><strong>include</strong>：用于导入其他的 jsp 文件</li>
</ul>
<h3 id="JSP-注释"><a href="#JSP-注释" class="headerlink" title="JSP 注释"></a>JSP 注释</h3><p>JSP 中有两种注释</p>
<ul>
<li>HTML 注释：<code>&lt;!-- 内容 --&gt;</code> ： 只能注释 HTML 内容</li>
<li>JSP 注释：<code>&lt;%-- 内容 --%&gt;</code>：可以注释 jsp 页面中的所有内容，<strong>推荐使用</strong></li>
</ul>
<h3 id="JSP-内置对象"><a href="#JSP-内置对象" class="headerlink" title="JSP 内置对象"></a>JSP 内置对象</h3><p>在 jsp 页面中不需要获取和创建，直接就可以使用的对象</p>
<p>JSP 有 9 个内置对象：</p>
<table>
<thead>
<tr>
<th align="center">变量名</th>
<th align="center">真实类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">pageContext</td>
<td align="center">PageContext</td>
</tr>
<tr>
<td align="center">request</td>
<td align="center">HttpServletRequest</td>
</tr>
<tr>
<td align="center">session</td>
<td align="center">HttpSession</td>
</tr>
<tr>
<td align="center">application</td>
<td align="center">ServletContext</td>
</tr>
<tr>
<td align="center">response</td>
<td align="center">HttpServletResponse</td>
</tr>
<tr>
<td align="center">page</td>
<td align="center">Object</td>
</tr>
<tr>
<td align="center">out</td>
<td align="center">JspWriter</td>
</tr>
<tr>
<td align="center">config</td>
<td align="center">ServletConfig</td>
</tr>
<tr>
<td align="center">exception</td>
<td align="center">Throwable</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JSP</tag>
      </tags>
  </entry>
  <entry>
    <title>Bootstrap</title>
    <url>/2019/05/26/Java/2.JavaWeb/5.Bootstrap/</url>
    <content><![CDATA[<p>BootStrap 是一个前端开发框架，来自 Twitter</p>
<a id="more"></a>



<p>概念：BootStrap 是一个前端开发框架，来自 Twitter，基于 HTML，CSS，JavaScript</p>
<p>优点：</p>
<ul>
<li>定义了很多 css 样式和 js 插件，可以直接使用这些样式和插件获得丰富的页面效果</li>
<li>响应式布局：同一套页面可以兼容不同分辨率的设备</li>
</ul>
<h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2><p>实现：基于栅格系统，将一行平均分为 12 个格子，可以指定元素占几个格子</p>
<p>步骤：</p>
<ol>
<li><p>定义容器</p>
<ul>
<li>容器分为两类：<ul>
<li>container：两边留白，比较常用</li>
<li>container-fluid： 每一种设备都是 100% 宽度</li>
</ul>
</li>
</ul>
</li>
<li><p>定义行</p>
<p>样式：row</p>
</li>
<li><p>定义元素</p>
<p>指定该元素在不同的设备上，所占格子的数目，<code>col-设备代号-格子数目</code></p>
<ul>
<li><p>设备代号：</p>
<ul>
<li><code>xs</code>：超小屏幕 手机（&lt;768px）</li>
<li><code>sm</code>：小屏幕 平板（≥768px）</li>
<li><code>md</code>：大屏幕 笔记本电脑 （≥992px）</li>
<li><code>lg</code>：超大屏幕 桌面显示器 （≥1200px）</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li>一行中如果格子数目超过 12，则会自动换行</li>
<li>栅格类的属性向上兼容</li>
<li>如果真实设备的宽度小于了设置栅格类属性的设备代码的最小值，会一个元素占满一行</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="css-样式和-js-插件"><a href="#css-样式和-js-插件" class="headerlink" title="css 样式和 js 插件"></a>css 样式和 js 插件</h2><p>用到的时候从官方文档里面找看着顺眼的样式，复制过来改改就好了</p>
]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>BootStrap</tag>
      </tags>
  </entry>
  <entry>
    <title>Git</title>
    <url>/2019/05/22/Java/Git/</url>
    <content><![CDATA[<p>Git 是目前世界上最先进的<strong>分布式版本控制系统</strong>（没有之一）</p>
<a id="more"></a>



<blockquote>
<p>SVN：集中式版本控制系统</p>
<p>Git：  分布式版本控制系统</p>
</blockquote>
<h3 id="使用-Git-的步骤："><a href="#使用-Git-的步骤：" class="headerlink" title="使用 Git 的步骤："></a>使用 Git 的步骤：</h3><p>1、安装 Git</p>
<p>2、设置用户名和邮箱</p>
<ul>
<li><code>$ git config --global user.name &quot;Your Name&quot;</code></li>
<li><code>$ git config --global user.email &quot;email@example.com&quot;</code></li>
</ul>
<p>3、创建版本库（仓库 repository）</p>
<ul>
<li><p>选择一个合适的地方，创建一个空目录</p>
</li>
<li><p>在 Git Bash 中，cd 到该目录（或者直接把 Git Bash 添加到右键菜单，然后在空目录直接右键打开 Git Bash）</p>
</li>
<li><p>运行<code>git init</code>命令，创建 repository 完成</p>
</li>
</ul>
<p>4、把文件添加到版本库</p>
<ul>
<li><p>使用<code>git add FileName</code>将指定文件添加到暂存区</p>
</li>
<li><p>使用<code>git commit -m &quot;commit explain&quot;</code>将暂存区文件提交到仓库</p>
<blockquote>
<p>注意事项：</p>
<p>版本控制工具只能跟踪<strong>文本文件</strong>（txt，程序代码等）的改动</p>
<p>使用 <code>git add</code> 的文件 <strong>必须在仓库目录下</strong></p>
<p><code>git commit</code> 的参数 <code>-m</code> 后面可以直接写<strong>本次提交的说明</strong>（如果不加 <code>-m</code>，在输入 <code>git commit</code> 回车后，会打开 <code>Vim</code> 让你输入提交说明）</p>
</blockquote>
</li>
</ul>
<h3 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h3><ul>
<li><code>git status</code> –&gt; 查看仓库当前的状态</li>
<li><code>git diff</code> –&gt; 查看修改的内容</li>
<li><code>git log</code> –&gt; 显示从最近到最远的提交日志</li>
<li><code>git reflog</code> –&gt; 查看命令历史，以便确定要回到未来的哪个版本</li>
<li><code>git reset --hard HEAD^</code> –&gt; 回退到上一个版本<ul>
<li><code>--hard HEAD^^</code> –&gt; 回退到上上个版本</li>
<li><code>--hard &lt;commit_id&gt;</code> –&gt; 回退到 commit_id 指定的版本</li>
</ul>
</li>
<li><code>git checkout -- filename</code> –&gt; 用版本库中的版本替换工作区的版本</li>
<li><code>git rm filename</code> –&gt; 删除工作区的一个文件</li>
</ul>
<h3 id="暂存区的概念"><a href="#暂存区的概念" class="headerlink" title="暂存区的概念"></a>暂存区的概念</h3><p>暂存区位于版本库（.git 文件夹）中，称为 stage</p>
<p>git add 操作就是<strong>将文件添加到暂存区</strong></p>
<p>git commit 操作就是<strong>将位于暂存区的所有文件提交到当前分支</strong></p>
<blockquote>
<p>git 是<strong>管理修改</strong>而非管理文件的</p>
</blockquote>
<h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><p>一般使用 GitHub 作为自己的远程仓库</p>
<ul>
<li><p>将本地仓库与远程仓库关联</p>
<p><code>git remote add origin https://github.com/PikachuHL/learngit.git</code></p>
</li>
<li><p>将本地仓库的内容推送到远程仓库</p>
<ul>
<li><p>第一次</p>
<p><code>git push -u origin master</code></p>
</li>
<li><p>以后</p>
<p><code>git push origin master</code></p>
</li>
</ul>
</li>
<li><p>从远程仓库克隆</p>
<p><code>git clone https://github.com/PikachuHL/learngit.git</code></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Git</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM整合</title>
    <url>/2019/05/17/Java/3.SSM%E6%A1%86%E6%9E%B6/SSM%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<p>SSM 整合起来, 实现前端页面可以对数据库进行增删改查</p>
<a id="more"></a>



<p>Spring / SpringMVC / MyBatis 整合的基本要求：</p>
<ul>
<li>由 Spring 框架整合其他两个框架</li>
<li>每个框架都需要可以独立运行</li>
</ul>
<h2 id="Spring-整合-SpringMVC"><a href="#Spring-整合-SpringMVC" class="headerlink" title="Spring 整合 SpringMVC"></a>Spring 整合 SpringMVC</h2><p>在web.xml 中设置监听器，当服务器启动时，由监听器完成加载spring 配置文件的动作。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置监听器，用于加载Spring的配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="Spring-整合-MyBatis"><a href="#Spring-整合-MyBatis" class="headerlink" title="Spring 整合 MyBatis"></a>Spring 整合 MyBatis</h2><p>在 Spring 的配置文件中配置 SqlSession 工厂，用于将代理 dao 放到 Spring 容器中</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring 整合 MyBatis --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置数据库连接池，用 c3p0 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql:///springtest"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置SqlSession工厂 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactoryBean"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置AccountDao接口所在的包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mapperScanner"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.pika.dao"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>另外，因为对数据库的增删改操作需要事务的支持，</p>
<p>所以需要在 Spring 的配置文件中设置事务</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置Spring的声明式事务 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置事务通知 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txadvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"find*"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置AOP增强 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txadvice"</span> <span class="attr">pointcut</span>=<span class="string">"execution(* com.pika.service.*.*(..))"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SSM整合</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC_响应</title>
    <url>/2019/05/16/Java/3.SSM%E6%A1%86%E6%9E%B6/SpringMVC_%E5%93%8D%E5%BA%94/</url>
    <content><![CDATA[<p>SpringMVC 可以向前端页面响应哪些种类的数据，以及如何向前端页面响应数据。</p>
<a id="more"></a>



<p>Spring的响应分为几种类型 (根据控制器中的方法返回值不同):</p>
<ul>
<li>返回 <code>String</code>，<ul>
<li>字符串名为页面名称，通过视图解析器来把字符串匹配到要响应的页面</li>
<li>字符串为<code>关键字+页面地址</code>，通过<code>forward</code>、<code>redirect</code> 两个关键字来实现转发和重定向</li>
</ul>
</li>
<li>返回 <code>void</code>，通过request、response来转发、重定向到指定页面</li>
<li>返回 <code>ModelAndView</code></li>
<li>返回<code>json</code>格式数据（实际返回的是javabean，通过<code>@ResponseBody</code>注解实现转换为json数据）</li>
</ul>
<blockquote>
<p>Model model</p>
<p>model.addAttribute(“username”, “zhangsan”);</p>
<p>model 的作用域为 request 作用域</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC_基础</title>
    <url>/2019/05/15/Java/3.SSM%E6%A1%86%E6%9E%B6/SpringMVC_%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>SpringMVC入门案例</p>
<a id="more"></a>



<p><strong>基本概念：</strong></p>
<ul>
<li><p><strong>MVC 模型（Model View Controller）：</strong></p>
<ul>
<li>Model：数据模型，JavaBean 的类，用来进行数据封装。</li>
<li>View：指 JSP、HTML 用来展示数据给用户</li>
<li>Controller：用来接收用户的请求，整个流程的控制器。用来进行数据校验等。 </li>
</ul>
</li>
<li><p><strong>SpringMVC：</strong>基于 MVC 设计模式的轻量级 web 框架</p>
</li>
<li><p><strong>SpringMVC 有清晰的角色划分：</strong></p>
<ul>
<li>前端控制器（DispatcherServlet）</li>
<li>处理器映射器（HandlerMapping）</li>
<li>处理器适配器（HandlerAdapter）</li>
<li>视图解析器（ViewResolver）</li>
<li>处理器或页面控制器（Controller）</li>
<li>验证器（Validator）</li>
<li>命令对象（Command 请求参数绑定到的对象就是命令对象）</li>
<li>表单对象（Form Object 提供给表单展示或提交到的对象就是表单对象）</li>
</ul>
</li>
</ul>
<h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h2><blockquote>
<p>入门案例需求:</p>
<p>​    在<code>index.jsp</code>中写一个超链接, 点击超链接, 跳转到 <code>success.jsp</code></p>
</blockquote>
<p>*<em>在<code>index.jsp</code>中写一个超链接标签: *</em></p>
<p><code>&lt;a href = &quot;hello&quot;&gt;入门案例&lt;/a&gt;</code></p>
<p><strong>创建<code>success.jsp</code>页面</strong></p>
<p>在<code>WEB-INF</code>文件夹下创建<code>pages</code>文件夹, 并在<code>pages</code>文件夹中创建<code>success.jsp</code></p>
<p><strong>创建一个 Controller 类, 并写一个方法, 在方法上添加<code>@RequestMapping</code>注解, 返回一个字符串:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(path = <span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HelloController"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>配置 SpringMVC 的各个组件：</strong></p>
<ul>
<li><p>前端控制器（DispatcherServlet）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在web.xml中进行配置 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置前端控制器DispatcherServlet，其实就是一个Servlet--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置全局初始化参数，用于加载Spring的配置文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationcontext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置服务器启动时就创建Servlet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>DispatcherServlet 中的url-pattern, 一定要配置 <code>/</code>, 而不能配置<code>/*</code></p>
<p>配置成 <code>/*</code> 会导致访问<code>.jsp</code> 时出现<code>404</code>的情况</p>
</blockquote>
</li>
<li><p>处理器映射器（HandlerMapping）&amp; 处理器适配器（HandlerAdapter）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启SpringMVC框架注解的支持</span></span><br><span class="line"><span class="comment">使用此标签会自动加载 处理器映射器（RequestMappingHandlerMapping） 和 </span></span><br><span class="line"><span class="comment">处理器适配器（RequestMappingHandlerAdapter）</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>视图解析器（ViewResolver）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在 SpringMVC 的配置文件中进行配置 --&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 配置视图解析器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"internalResourceViewResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/pages/"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<hr>
<p><strong>入门案例的流程总结:</strong></p>
<p><img src="/images/SpringMVC_%E5%9F%BA%E7%A1%80/springmvc%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%8E%9F%E7%90%86.jpg" alt="springmvc执行流程原理"></p>
<p><strong>@RequestMapping注解：</strong></p>
<p><strong>作用：</strong>用于建立 <strong>请求 URL</strong> 和 <strong>处理请求方法</strong> 之间的对应关系</p>
<p><strong>作用范围：类</strong> 和 <strong>方法</strong></p>
<p><strong>属性：</strong></p>
<ul>
<li><code>path</code> –&gt; 指定请求路径的 url</li>
<li><code>value</code> –&gt; 和 path 属性是一样的</li>
<li><code>method</code> –&gt; 指定该方法的请求方式( get / post /…)</li>
<li><code>params</code> –&gt; 指定限制请求参数的条件</li>
<li><code>headers</code> –&gt; 发送的请求中必须包含的请求头</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Template &amp; 事务</title>
    <url>/2019/05/12/Java/3.SSM%E6%A1%86%E6%9E%B6/Spring%20Template&amp;%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<p>JdbcTemplate：Spring 提供的一个对 JDBC 的简单封装</p>
<a id="more"></a>



<h2 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h2><p>JdbcTemplate：Spring 提供的一个对 JDBC 的简单封装</p>
<p>JdbcTemplate 的使用：</p>
<ul>
<li><p>导坐标（maven）</p>
<ul>
<li>spring-jdbc</li>
</ul>
</li>
<li><p>创建 JdbcTemplate 对象(<em>需要数据源，有参/无参创建</em>)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 有参创建	</span></span><br><span class="line">JdbcTemplate template = <span class="keyword">new</span> JdbcTemplate(DataSource ds);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 无参创建</span></span><br><span class="line"> JdbcTemplate template = <span class="keyword">new</span> JdbcTemplate();</span><br><span class="line"> template.setDataSource(ds);</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用 JdbcTemplate 中的方法完成 <strong>CRUD</strong> 操作</p>
<ul>
<li><code>update()</code> –&gt; 执行<strong>增、删、改</strong><ul>
<li><strong>增</strong>：<code>template.update(&quot;insert into account(name, money) values(?, ?)&quot;, &quot;aaa&quot;, 1000);</code></li>
<li><strong>改</strong>：<code>template.update(&quot;update account set name=?, money=? where id=?&quot;, &quot;bbb&quot;, 2000, 2);</code></li>
<li><strong>删</strong>：<code>template.update(&quot;delete from account where id = ?&quot;, 2);</code></li>
</ul>
</li>
<li><code>query()</code> –&gt; 查询结果，将结果自动封装为 JavaBean 对象<ul>
<li>查询所有：<code>List&lt;Account&gt; accounts = template.query(&quot;select * from account where money &gt; ?&quot;, new BeanPropertyRowMapper&lt;Account&gt;(Account.class), 1000);</code></li>
<li>query的<strong>参数</strong>：(1:<strong>sql查询语句</strong>, 2:<strong>BeanPropertyRowMapper&lt;封装类&gt;(封装类.class)</strong>, 3:<strong>可变参数</strong>)</li>
<li>一般我们使用 <strong>RowMapper</strong> 实现类 <strong>BeanPropertyRowMapper</strong>。可以完成 <strong>数据</strong> 到 <strong>JavaBean</strong> 的自动封装</li>
</ul>
</li>
<li><code>queryForMap()</code> –&gt; 查询一条记录，将查询结果封装为一个map集合<ul>
<li>注意：这个方法查询的结果集长度只能是1</li>
</ul>
</li>
<li><code>queryForList()</code> –&gt; 查询结果，将结果集封装为list集合<ul>
<li>注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中</li>
</ul>
</li>
<li><code>queryForObject()</code> –&gt; 查询结果，将结果封装为对象<ul>
<li>一般用于聚合函数的查询</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<p>Spring的内置数据库连接池：<code>DriveManagerDataSource</code></p>
</blockquote>
<h2 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h2><blockquote>
<p>在 JavaEE 开发中，事务处理位于<strong>业务层</strong></p>
<p>mavne项目坐标：spring-tx</p>
<p>Spring 的事务控制都是基于 AOP 的，可通过配置实现（常用），也可通过编程实现</p>
</blockquote>
<p>Spring的事务管理器：</p>
<ul>
<li>接口：<code>PlatformTransactionManager</code></li>
<li>实现类：<code>DataSourceTransactionManager</code>（真正管理事务的对象）</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring中基于XML的声明式事务控制的配置步骤 </span></span><br><span class="line"><span class="comment">	1.配置事务管理器</span></span><br><span class="line"><span class="comment">	2.配置事务的通知</span></span><br><span class="line"><span class="comment">		此时我们需要 tx 名称空间和约束</span></span><br><span class="line"><span class="comment">		使用 tx:advice 标签配置事务通知</span></span><br><span class="line"><span class="comment">			标签的属性：</span></span><br><span class="line"><span class="comment">				id：给事务通知起个名</span></span><br><span class="line"><span class="comment">				transaction-manager：给事务通知提供一个事务管理器引用</span></span><br><span class="line"><span class="comment">	3.配置AOP中的通用切入点表达式</span></span><br><span class="line"><span class="comment">	4.建立事务通知和切入点表达式的对应关系</span></span><br><span class="line"><span class="comment">	5.配置事务的属性</span></span><br><span class="line"><span class="comment">		在 tx:advice 标签的内部使用 tx:attributes 标签进行配置</span></span><br><span class="line"><span class="comment">		tx:attributes 标签的属性：</span></span><br><span class="line"><span class="comment">			isolation：用于指定事务的隔离级别，默认值为DEFAULT，表示使用数据库的默认隔离级别</span></span><br><span class="line"><span class="comment">			propagation：用于指定事务的传播行为，默认值为REQUIRED,表示一定有事务，增删改方法选择默认值。查询方法使用SUPPORTS</span></span><br><span class="line"><span class="comment">			read-only：用于指定方法是否只读，查询方法设置为true，增删改设置为false，表示读写</span></span><br><span class="line"><span class="comment">			time-out：用于指定事务的超时时间，默认值为-1，表示永不超时，时间单位为秒</span></span><br><span class="line"><span class="comment">			rollback-for：用于指定一个异常，当产生该异常时，事务回滚；当产生其他异常时，事务不回滚，不指定异常，表示任何异常都回滚</span></span><br><span class="line"><span class="comment">			no-rollback-for:用于指定一个异常，当产生该异常时，事务不回滚；当产生其他异常时，事务回滚，不指定异常，表示任何异常都回滚</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置事务的通知 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置事务的属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 为方法配置事务属性 --&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">read-only</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"find*"</span> <span class="attr">propagation</span>=<span class="string">"SUPPORTS"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置AOP --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 配置通用切入点表达式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pt1"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.pika.service.impl.*.*(..))"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:pointcut</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 建立事务通知和切入点表达式的对应关系 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JDBCTemplate</tag>
        <tag>Spring事务</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC_数据库连接池</title>
    <url>/2019/05/06/Java/1.Java%E5%9F%BA%E7%A1%80/JDBC_%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    <content><![CDATA[<p>C3P0 &amp; druid</p>
<a id="more"></a>

<h2 id="JDBC-数据库连接池"><a href="#JDBC-数据库连接池" class="headerlink" title="JDBC 数据库连接池"></a>JDBC 数据库连接池</h2><p>1、数据库连接池的<strong>概念</strong>：数据库连接池就是一个容器，里面存放的是数据库的连接对象</p>
<p>2、JDBC 中提供的接口：DataSource</p>
<ul>
<li>获取连接的方法：<code>getConnection()</code> </li>
</ul>
<blockquote>
<p>如果连接是从连接池中获取，当连接对象调用 close() 方法时，并不是关闭连接，而是归还连接</p>
</blockquote>
<p>3、学习两种数据库连接池：</p>
<ul>
<li>C3P0：一款比较老的数据库连接池（仅学习一下）</li>
<li>druid：阿里巴巴出品的一款效率很高的、使用很广的数据库连接池（以后就用这个）</li>
</ul>
<h3 id="一、C3P0"><a href="#一、C3P0" class="headerlink" title="一、C3P0"></a>一、C3P0</h3><p>使用步骤：</p>
<ul>
<li>导入 jar 包</li>
<li>定义配置文件<ul>
<li>名称：必须为：c3p0.properties 或者 c3p0-config.xml</li>
<li>路径：放在 src 目录下</li>
</ul>
</li>
<li>创建连接池对象<ul>
<li><code>DataSource ds = new ComboPooledDataSource();</code></li>
</ul>
</li>
<li>获取连接<ul>
<li><code>Connection conn = ds.getConnection();</code></li>
</ul>
</li>
</ul>
<h3 id="二、druid"><a href="#二、druid" class="headerlink" title="二、druid"></a>二、druid</h3><p>使用步骤：</p>
<ul>
<li>导入 jar 包</li>
<li>定义配置文件<ul>
<li>定义 properties 类型的配置文件</li>
<li>可以为任意名称，可以放在任意目录下</li>
</ul>
</li>
<li>加载配置文件<ul>
<li><code>Properries pro = new Properties();</code></li>
<li><code>pro.load(类名.class.getClassLoader().getResourceAsStream(&quot;配置文件名&quot;));</code></li>
</ul>
</li>
<li>获取连接池对象<ul>
<li><code>DataSource ds = DruidDataSourceFactory.createDataSource(pro);</code></li>
</ul>
</li>
<li>获取连接<ul>
<li><code>Connection conn = ds.getConnection();</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
        <tag>数据库连接池</tag>
      </tags>
  </entry>
  <entry>
    <title>继承&amp;多态&amp;内部类</title>
    <url>/2019/05/04/Java/1.Java%E5%9F%BA%E7%A1%80/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<p>继承是多态的前提</p>
<a id="more"></a>

<h1 id="继承与多态"><a href="#继承与多态" class="headerlink" title="继承与多态"></a>继承与多态</h1><h2 id="一、继承"><a href="#一、继承" class="headerlink" title="一、继承"></a>一、继承</h2><p>关键字：<strong>extends</strong></p>
<p>在继承关系中，“子类就是一个父类”  关系：<strong>is-a</strong></p>
<p>父类不知道子类，子类知道父类</p>
<hr>
<p>在父子类的继承关系中，如果<strong>成员变量重名</strong>，则访问成员变量有两种方式：</p>
<ul>
<li>直接通过对象名称访问成员变量：看<strong>等号左边是谁</strong>，则优先用谁，没有则向上找</li>
<li>间接通过成员方法访问成员变量：看<strong>该方法属于谁</strong>，则优先用谁，没有则向上找</li>
</ul>
<p>在继承关系中，成员方法的访问特性：</p>
<ul>
<li><strong>创建对象是谁</strong>，就优先用谁，如果没有则向上找</li>
</ul>
<hr>
<p>关于<strong>变量的定位</strong>（在子类方法中）：</p>
<ul>
<li>局部变量：直接写局部变量名</li>
<li>本类成员变量：this.成员变量名</li>
<li>父类成员变量：super.成员变量名</li>
</ul>
<hr>
<p>在子类构造方法中，通过 <code>super();</code> 调用父类的构造方法，</p>
<p>注意：<code>super();</code> 在子类的构造方法中如果存在，就必须是第一个语句</p>
<hr>
<p><strong>super &amp; this</strong></p>
<p>super 关键字的用法有三种：</p>
<ul>
<li><p>在子类的构造方法中，访问父类的构造方法。</p>
</li>
<li><p>在子类的成员方法中，访问父类的成员变量。</p>
</li>
<li><p>在子类的成员方法中，访问父类的成员方法。</p>
</li>
</ul>
<p>super 关键字用来访问父类内容，而 this 关键字用来访问本类内容。用法也有三种：</p>
<ul>
<li><p>在本类的成员方法中，访问本类的成员变量。</p>
</li>
<li><p>在本类的成员方法中，访问本类的另一个成员方法。</p>
</li>
<li><p>在本类的构造方法中，访问本类的另一个构造方法。</p>
<ul>
<li>在第三种用法当中要注意：<ul>
<li>this(…) 调用也必须是构造方法的第一个语句，唯一一个。</li>
<li>super 和 this 两种构造调用，不能同时使用。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>静态代码块，构造代码块，构造方法</strong> 的执行顺序：</p>
<ol>
<li>静态代码块：静态代码块属于类，在类载入内存时执行，只执行一次，优先级最高（高于 main 方法）。</li>
<li>构造代码块：在 new 对象时执行，在静态代码块之后，构造方法之前执行。</li>
<li>构造方法：在 new 对象时执行。</li>
</ol>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"Parent的构造方法"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">static</span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"Parent的静态代码块"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   &#123;</span><br><span class="line">       System.out.println(<span class="string">"Parent的构造代码块"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"Son的构造方法"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">"Son的静态代码块"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#123;</span><br><span class="line">	System.out.println(<span class="string">"Son的构造代码块"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"main方法"</span>);</span><br><span class="line">       Son son = <span class="keyword">new</span> Son();</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// 运行结果</span></span><br><span class="line">&gt;<span class="comment">// Parent的静态代码块</span></span><br><span class="line">&gt;<span class="comment">// Son的静态代码块</span></span><br><span class="line">&gt;<span class="comment">// main方法</span></span><br><span class="line">&gt;<span class="comment">// Parent的构造代码块</span></span><br><span class="line">&gt;<span class="comment">// Parent的构造方法</span></span><br><span class="line">&gt;<span class="comment">// Son的构造代码块</span></span><br><span class="line">&gt;<span class="comment">// Son的构造方法</span></span><br></pre></td></tr></table></figure>


</blockquote>
<h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>关键字：<strong>abstract</strong></p>
<p><strong>抽象方法</strong>和<strong>抽象类</strong>：</p>
<ul>
<li>抽象方法所在的类必须为抽象类</li>
<li>抽象类中不一定有抽象方法</li>
</ul>
<p>抽象类的特点：</p>
<ul>
<li>抽象类不能创建对象</li>
<li>继承了抽象类的子类必须<strong>实现</strong>抽象类中<strong>所有</strong>的<strong>抽象方法</strong></li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口是一种<strong>公共的规范标准</strong></p>
<p>关键字：</p>
<ul>
<li><strong>interface</strong>（定义接口）</li>
<li><strong>implements</strong>（实现接口）</li>
</ul>
<p><strong>接口中的内容：</strong></p>
<ol>
<li>成员变量其实是<strong>常量</strong>，格式：<br> <code>[public] [static] [final] 数据类型 常量名称 = 数据值;</code><br> 注意：<ul>
<li>常量必须进行赋值，而且一旦赋值不能改变。</li>
<li>常量名称完全大写，用下划线进行分隔。</li>
</ul>
</li>
<li>接口中最重要的就是<strong>抽象方法</strong>，格式：<br><code>[public] [abstract] 返回值类型 方法名称(参数列表);</code><br>注意：</li>
</ol>
<ul>
<li>实现类必须覆盖重写接口所有的抽象方法，除非实现类是抽象类。</li>
</ul>
<ol start="3">
<li>从 Java 8 开始，接口里允许定义<strong>默认方法</strong>，格式：<br> <code>[public] default 返回值类型 方法名称(参数列表) { 方法体 }</code><br> 注意：<ul>
<li>默认方法也可以被覆盖重写</li>
</ul>
</li>
<li>从 Java 8 开始，接口里允许定义<strong>静态方法</strong>，格式：<br> <code>[public] static 返回值类型 方法名称(参数列表) { 方法体 }</code><br> 注意：<ul>
<li>通过接口名称进行调用，不能通过实现类对象调用接口静态方法</li>
</ul>
</li>
<li>从 Java 9 开始，接口里允许定义<strong>私有方法</strong>，格式：<br> 普通私有方法：<code>private 返回值类型 方法名称(参数列表) { 方法体 }</code><br> 静态私有方法：<code>private static 返回值类型 方法名称(参数列表) { 方法体 }</code><br> 注意：<ul>
<li>private 的方法只有接口自己才能调用，不能被实现类或别人使用。</li>
</ul>
</li>
</ol>
<p>使用接口的注意事项：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 接口是没有静态代码块或者构造方法的。</span><br><span class="line"><span class="number">2</span>. 一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。</span><br><span class="line">格式：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterfaceImpl</span> <span class="keyword">implements</span> <span class="title">MyInterfaceA</span>, <span class="title">MyInterfaceB</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 覆盖重写所有抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3</span>. 如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可。</span><br><span class="line"><span class="number">4</span>. 如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类。</span><br><span class="line"><span class="number">5</span>. 如果实现类所实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。</span><br><span class="line"><span class="number">6</span>. 一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先用父类当中的方法。</span><br></pre></td></tr></table></figure>





<blockquote>
<ol>
<li>类与类之间是<strong>单继承</strong>的。直接父类只有一个。</li>
<li>类与接口之间是<strong>多实现</strong>的。一个类可以实现多个接口。</li>
<li><strong>接口与接口之间是多继承的</strong>。</li>
</ol>
<p>注意事项：</p>
<ol>
<li>多个父接口当中的抽象方法如果重复，没关系。</li>
<li>多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写，【而且带着default关键字】。</li>
</ol>
</blockquote>
<h2 id="二、多态"><a href="#二、多态" class="headerlink" title="二、多态"></a>二、多态</h2><blockquote>
<p>动物是父类，狗是子类，金毛是子类对象</p>
<p>金毛既有狗的形态，又有动物的形态</p>
<p>这就叫做<strong>对象</strong>的多态性</p>
<p>PS：多态性是针对于<strong>对象</strong>来说的</p>
</blockquote>
<p>简单一句话：<strong>父类引用</strong>指向<strong>子类对象</strong></p>
<p>定义格式：<code>Animal animal = new Dog();</code></p>
<hr>
<p><strong>多态</strong>中成员变量和成员方法的访问规则和<strong>继承</strong>中是一模一样的</p>
<p>在多态中访问规则口诀：</p>
<ul>
<li>成员变量：编译看左边，运行还看左边</li>
<li>成员方法：<strong>编译看左边，运行看右边</strong></li>
</ul>
<hr>
<p><strong>向上转型 ** 和 **向下转型</strong></p>
<p>向上转型：<code>Animal animal = new Dog();</code></p>
<p>向下转型：<code>Dog dog = (Dog)animal;</code></p>
<blockquote>
<p>向上转型一定是安全的，但有一个问题：</p>
<ul>
<li>向上转型后，便<strong>无法调用子类原本特有的方法</strong></li>
</ul>
<p>如果想要调用子类原本特有的方法就要 向下转型</p>
<p>但是向下转型一定要注意安全性问题（不要把 Cat 转为 Dog）</p>
</blockquote>
<p>向下转型时要进行判断，通过 关键字：<strong>instanceof</strong></p>
<p><code>变量名 instanceof 类名</code> –&gt; 判断该变量是不是属于该类</p>
<h2 id="三、final"><a href="#三、final" class="headerlink" title="三、final"></a>三、final</h2><p>final 关键字代表最终的、不可改变的</p>
<p>final 可以修饰：</p>
<ul>
<li>类<ul>
<li>final 修饰的类不能有子类，故其中的方法也不能被重写</li>
</ul>
</li>
<li>方法<ul>
<li>final 修饰的方法不能被重写（final 和 abstract 不能同时使用）</li>
</ul>
</li>
<li>局部变量<ul>
<li>final 修饰的局部变量，只能经过一次赋值，且其中的值不可变<ul>
<li>如果变量是基本数据类型，其中的<strong>数据</strong>不可变</li>
<li>如果变量是引用数据类型，其中的<strong>地址值</strong>不可变</li>
</ul>
</li>
</ul>
</li>
<li>成员变量<ul>
<li>final 修饰的成员变量必须进行赋值，<ul>
<li>在定义时赋值 或 在构造方法中赋值<ul>
<li>在构造方法中赋值的时候，必须所有重载的构造方法中都有赋值语句才可以</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="四、权限修饰符"><a href="#四、权限修饰符" class="headerlink" title="四、权限修饰符"></a>四、权限修饰符</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">public</th>
<th align="center">protected</th>
<th align="center">(default)</th>
<th align="center">private</th>
</tr>
</thead>
<tbody><tr>
<td align="center">同一个类（我自己）</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">同一个包（我邻居）</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">不同包的子类（我儿子）</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">不同包非子类（陌生人）</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<h2 id="五、内部类"><a href="#五、内部类" class="headerlink" title="五、内部类"></a>五、内部类</h2><p>内部类有哪几种：</p>
<ul>
<li>成员内部类</li>
<li>局部内部类（<strong>匿名内部类</strong>属于局部内部类）</li>
</ul>
<h3 id="1、成员内部类"><a href="#1、成员内部类" class="headerlink" title="1、成员内部类"></a>1、成员内部类</h3><p><strong>概念：</strong>定义在<strong>类内部</strong>的类</p>
<p><strong>定义：</strong>成员内部类和普通类的定义没有差别</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义成员内部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123; </span><br><span class="line">        <span class="comment">// Inner 类就是成员内部类</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>访问：</strong>内用外，随意访问；外用内，需要内部类对象。</p>
<p><strong>使用成员内部类有两种方式：</strong></p>
<ol>
<li>间接方式：在外部类的方法当中，使用内部类；然后 main 只是调用外部类的方法。</li>
<li>直接方式：</li>
<li><code>Inner inner = new Inner()</code></li>
<li>``Outer.Inner inner = new Outer().new Inner();`</li>
</ol>
<p>在内部类的方法中使用外部类的成员变量（重名）：</p>
<ul>
<li><code>外部类名称.this.外部类成员变量名;</code></li>
</ul>
<h3 id="2、局部内部类"><a href="#2、局部内部类" class="headerlink" title="2、局部内部类"></a>2、局部内部类</h3><p><strong>概念：</strong>定义在<strong>方法内部</strong>的类</p>
<p>“局部”：只能在当前方法内使用，出了方法就不能用了</p>
<p><strong>定义：</strong> class 的前面没有权限修饰符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OuterMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 定义局部内部类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>PS：定义类时，权限修饰符的使用规则</p>
<ul>
<li>外部类：<strong>public / (default)</strong></li>
<li>成员内部类：4种权限修饰符都可用</li>
<li>局部内部类：<strong>不用</strong> 权限修饰符</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是【有效final的】。</span><br><span class="line"></span><br><span class="line">备注：从 Java 8 开始，只要局部变量事实不变，那么 final 关键字可以省略。</span><br><span class="line"></span><br><span class="line">原因：</span><br><span class="line">1. new出来的对象在堆内存当中。</span><br><span class="line">2. 局部变量是跟着方法走的，在栈内存当中。</span><br><span class="line">3. 方法运行结束之后，立刻出栈，局部变量就会立刻消失。</span><br><span class="line">4. 但是 new 出来的对象会在堆当中持续存在，直到垃圾回收消失。</span><br></pre></td></tr></table></figure>



<h3 id="3、匿名内部类"><a href="#3、匿名内部类" class="headerlink" title="3、匿名内部类"></a>3、匿名内部类</h3><p><strong>概念：</strong></p>
<ul>
<li>如果接口的实现类（或者是父类的子类）<strong>只需要使用唯一的一次</strong>，<br>那么这种情况下就可以<strong>省略掉该类的定义</strong>，而改为使用【<strong>匿名内部类</strong>】。</li>
</ul>
<p><strong>定义：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">匿名内部类的定义格式：</span></span><br><span class="line"><span class="comment">接口名称 对象名 = new 接口名称() &#123;</span></span><br><span class="line"><span class="comment">    // 覆盖重写所有抽象方法</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">上述定义格式中，大括号内部的部分为 匿名内部类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个匿名内部类，实现了 MyInterface 接口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyInterface obj = <span class="keyword">new</span> MyInterface()&#123;</span><br><span class="line">      	<span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"实现了接口的方法"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对格式“new 接口名称() &#123;...&#125;”进行解析：</span><br><span class="line">1. new代表创建对象的动作</span><br><span class="line">2. 接口名称就是匿名内部类需要实现哪个接口</span><br><span class="line">3. &#123;...&#125;这才是匿名内部类的内容</span><br><span class="line"></span><br><span class="line">另外还要注意几点问题：</span><br><span class="line">1. 匿名内部类，在【创建对象】的时候，只能使用唯一一次。</span><br><span class="line">如果希望多次创建对象，而且类的内容一样的话，那么就需要使用单独定义的实现类了。</span><br><span class="line">2. 匿名对象，在【调用方法】的时候，只能调用唯一一次。</span><br><span class="line">如果希望同一个对象，调用多次方法，那么必须给对象起个名字。</span><br><span class="line">3. 匿名内部类是省略了【实现类&#x2F;子类名称】，但是匿名对象是省略了【对象名称】</span><br><span class="line">强调：匿名内部类和匿名对象不是一回事！！！</span><br></pre></td></tr></table></figure>





<h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p>Lambda 是 Java 8 的新特性，为了简化类（只使用一次的类）的书写。</p>
<blockquote>
<p>接口中只有一个方法时才能使用 Lambda 表达式</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Lambda 表达式的推导</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2.定义一个静态内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Student2</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"nice"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student1 student1 = <span class="keyword">new</span> Student1();</span><br><span class="line">        student1.speak();</span><br><span class="line"></span><br><span class="line">        Student2 student2 = <span class="keyword">new</span> Student2();</span><br><span class="line">        student2.speak();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.定义一个成员内部类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Student3</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"wonderful"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Student3 student3 = <span class="keyword">new</span> Student3();</span><br><span class="line">        student3.speak();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.定义匿名内部类</span></span><br><span class="line">        Person student4 = <span class="keyword">new</span> Person() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"perfect"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        student4.speak();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.使用Lambda表达式</span></span><br><span class="line">        Person student5 = ()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">"excellent"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        student5.speak();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口，只有一个方法</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.定义一个外部类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student1</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"good"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当接口中的方法有参数时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.原始 Lambda 表达式</span></span><br><span class="line"><span class="comment">//        Person student = (int a)-&gt;&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(a);</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line"><span class="comment">//        student.speak(10);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.参数的类型可以省略</span></span><br><span class="line"><span class="comment">//        Person student = (a)-&gt;&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(a);</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line"><span class="comment">//        student.speak(10);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.只有一个参数时，参数的括号可以省略</span></span><br><span class="line"><span class="comment">//        Person student = a-&gt;&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(a);</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line"><span class="comment">//        student.speak(10);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.方法中只有一行语句时，大括号可以省略</span></span><br><span class="line">        Person student = a-&gt;System.out.println(a);</span><br><span class="line">        student.speak(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>继承</tag>
        <tag>多态</tag>
        <tag>抽象</tag>
        <tag>接口</tag>
        <tag>final</tag>
        <tag>内部类 - Lambda表达式</tag>
        <tag>权限修饰符</tag>
      </tags>
  </entry>
  <entry>
    <title>Java常用类</title>
    <url>/2019/05/03/Java/1.Java%E5%9F%BA%E7%A1%80/Java%E5%B8%B8%E7%94%A8%E7%B1%BB/</url>
    <content><![CDATA[<p>常用类：Object、 Math、Random、Date、String、StringBuffer、StringBuilder、File、包装类</p>
<a id="more"></a>



<blockquote>
<p>引用类型一般使用步骤：</p>
<p>​    1、导包：除了 java.lang 包下的内容不需要导包，其他包下的内容都需要使用 import 导入</p>
<p>​    2、创建：类名 对象变量名 = new 类名();</p>
<p>​    3、使用：对象变量名.成员方法名();</p>
</blockquote>
<h2 id="System-类"><a href="#System-类" class="headerlink" title="System 类"></a>System 类</h2><p>System 类代表<strong>当前 Java 程序运行的平台</strong></p>
<p>System 中的变量和方法都为 static</p>
<ul>
<li><p>提供了代表<strong>标准输入（System.in）</strong>、<strong>标准输出（System.out）</strong>、<strong>错误输出（System.err）</strong>的类变量</p>
</li>
<li><p>提供了获取系统当前时间的方法：</p>
<ul>
<li><code>currentTimeMillis()</code> –&gt; 以毫秒为单位</li>
<li><code>nonaTime()</code> –&gt; 以纳秒为单位</li>
</ul>
</li>
<li><p>获取指定对象的精确 hashCode 值：<code>identityHashCode(object obj)</code></p>
<blockquote>
<p>如果某个类的 hashCode() 方法被重写后，该类实例的 hashCode() 方法就不能唯一的标识该对象；</p>
<p>但是只要两个对象的 identityHashCode 值相同，则两个对象绝对是同一个对象</p>
</blockquote>
</li>
</ul>
<h2 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h2><p>Scanner 用于获取用户输入，它可以从文件、输入流、字符串中解析数据（使用不同的构造器可以将不同类型的数据作为数据源）</p>
<p>导包：<code>import java.util.Scanner;</code></p>
<p><code>System.in</code> 表示<strong>从键盘获取输入</strong></p>
<ul>
<li><p><code>Scanner sc = new Scanner(System.in);</code></p>
</li>
<li><p>从键盘获取int：<code>int a = sc.nextInt();</code></p>
</li>
<li><p>从键盘获取String：<code>String str = sc.next();</code></p>
</li>
</ul>
<p>也可用于<strong>读取文件内容</strong>：<code>Scanner scanner = new Scanner(new File(&quot;ScannerFileTest.java&quot;))</code></p>
<p>Scanner 主要提供两个方法来扫描输入：</p>
<ul>
<li><code>hasNextXxx()</code>: 是否还有下一个输入项</li>
<li><code>nextXxx()</code>: 获取下一个输入项</li>
</ul>
<blockquote>
<p>Scanner 的读取操作可能被<strong>阻塞</strong>，因为Scanner要等待信息的输入</p>
</blockquote>
<blockquote>
<p><strong>匿名对象：</strong>没有对象名，只是使用 new 来创建对象。</p>
<p>特点：匿名对象<strong>只能使用一次</strong>。</p>
<p>例：如果只想获取一次键盘输入，使用 Scanner 的匿名对象</p>
<ul>
<li><code>int num = new Scanner(System.in).nextInt();</code></li>
</ul>
</blockquote>
<h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><p><code>inport java.util.Math;</code></p>
<p>常用方法：</p>
<ul>
<li><code>double abs(double num);</code> –&gt; 获取绝对值</li>
<li><code>double ceil(double num);</code> –&gt; 向上取整</li>
<li><code>double floor(double num);</code> –&gt; 向下取整</li>
<li><code>long round(double num);</code> –&gt; 四舍五入  </li>
</ul>
<h2 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h2><p>导包：<code>import java.util.Random;</code></p>
<p>创建：<code>Random r = new Random();</code></p>
<p>使用：</p>
<ul>
<li>（在整个 int 范围）获取一个随机的 int：<code>int a = r.nextInt();</code></li>
<li>在 <strong>[0~i)</strong> 中获取一个随机的 int：<code>int b = r.nextInt(int i);</code></li>
</ul>
<h2 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h2><p>静态成员属于类，所以在静态方法中<strong>不能使用 this</strong> </p>
<blockquote>
<p>静态不能直接访问非静态</p>
<p>因为：在内存中<strong>先</strong>有静态内容，<strong>后</strong>有非静态内容</p>
<p>正所谓：“先人不知道后人，后人知道先人”</p>
</blockquote>
<p><strong>静态的内存图：</strong></p>
<p><img src="/images/Java%E5%B8%B8%E7%94%A8%E7%B1%BB/%E9%9D%99%E6%80%81%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE.png" alt="静态的内存图"></p>
<p><img src="/images/Java%E5%B8%B8%E7%94%A8%E7%B1%BB/static_%E5%85%B3%E9%94%AE%E5%AD%97.JPG" alt="static_关键字"></p>
<p>静态代码块：</p>
<ul>
<li>特点：<ul>
<li>在第一次用的本类时，静态代码块执行唯一一次</li>
<li>静态总是优先于非静态，故创建对象时，静态代码块先于构造方法执行</li>
</ul>
</li>
<li>典型用途：<ul>
<li>用于一次性的对静态成员变量进行赋值</li>
</ul>
</li>
</ul>
<h2 id="main-方法的签名"><a href="#main-方法的签名" class="headerlink" title="main 方法的签名"></a>main 方法的签名</h2><p>main 方法的签名：<code>public static void main(String[] args){}</code></p>
<p>使用该签名的原因：</p>
<ul>
<li>public：程序运行的入口是 main 方法，为了让 JVM 可以自由的调用 main 方法，所以要将 main 方法暴露出来</li>
<li>static：JVM 调用 main 方法时，直接通过类来调用，所以使用 static 修饰</li>
<li>void：将值返回给 JVM 没有意义，故 main 方法返回值为 void</li>
</ul>
<h2 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h2><p>Integer 为 int 的包装类，可创建对象。</p>
<ul>
<li>Integer 与 int 类型的相互转换</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// int to Integer</span></span><br><span class="line">Integer a = <span class="number">1</span>; <span class="comment">// 自动装箱</span></span><br><span class="line">Integer b = <span class="keyword">new</span> Integer(<span class="number">2</span>);</span><br><span class="line">Integer c = Integer.valueOf(<span class="number">3</span>); <span class="comment">// 最基础方法，官方推荐</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Integer to int</span></span><br><span class="line"><span class="keyword">int</span> d = a; <span class="comment">// 自动拆箱</span></span><br><span class="line"><span class="keyword">int</span> e = b.intValue();</span><br></pre></td></tr></table></figure>


<ul>
<li>String 与 Integer之间的相互转换</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String to Integer</span></span><br><span class="line">Integer a = <span class="keyword">new</span> Integer(<span class="string">"123"</span>);</span><br><span class="line">Integer b = Integer.valueOf(<span class="string">"456"</span>);</span><br><span class="line">Integer c = Integer.parseInt(<span class="string">"789"</span>); <span class="comment">// 最基础方法</span></span><br></pre></td></tr></table></figure>

<p><code>String s = a.toString();  // Integer to String</code></p>
<blockquote>
<p>创建 Integer 对象的时候要注意缓存区的问题。[-128,127]</p>
</blockquote>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><blockquote>
<p>程序中出现的所有双引号字符串，都是 String 类的对象</p>
</blockquote>
<p>字符串的特点：</p>
<ul>
<li><p>字符串的内容永不变，所以字符串可以共享使用</p>
</li>
<li><p>String 对象是不可变的，因为 String 类底层是使用 final 字符数组存放字符串</p>
<p><code>private final char value[];</code></p>
<blockquote>
<p>JDK 8及之前使用的是字符数组，JDK 9之后使用的是字节数组</p>
</blockquote>
</li>
</ul>
<p>字符串的创建方式（1+3）：</p>
<ul>
<li><p>1种直接创建：</p>
<ul>
<li><code>String str = “Hello”；</code></li>
</ul>
</li>
<li><p>3种构造方法创建：</p>
<ul>
<li><code>public String();</code> –&gt; 创建一个空的字符串</li>
<li><code>public String(char[] array)</code> –&gt; 根据<strong>字符数组</strong>创建字符串</li>
<li><code>public String(byte[] array)</code> –&gt; 根据<strong>字节数组</strong>创建字符串</li>
</ul>
</li>
</ul>
<blockquote>
<p> 直接创建的字符串位于 堆内存中的<strong>常量池</strong> 中</p>
<p> new 出来的字符串直接位于 <strong>堆内存</strong> 中</p>
</blockquote>
<p><img src="/images/Java%E5%B8%B8%E7%94%A8%E7%B1%BB/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%B8%B8%E9%87%8F%E6%B1%A0.png" alt="字符串的常量池"></p>
<hr>
<p>字符串的比较：</p>
<blockquote>
<p>对于基本数据类型，<code>==</code> 是进行<strong>数值</strong>的比较</p>
<p>对于引用类型来说，<code>==</code> 是进行<strong>地址值</strong>的比较</p>
</blockquote>
<p>比较<strong>字符串内容</strong>的方法：</p>
<ul>
<li><code>public boolean equals(Object obj)</code><ul>
<li>如果比较双方一个常量一个变量，推荐使用 <code>&quot;abc&quot;.equals(str);</code> –&gt; 可预防空指针异常</li>
</ul>
</li>
<li><code>public boolean equalsIgnoreCase(String str)</code> –&gt; 忽略大小写比较字符串内容</li>
</ul>
<hr>
<ul>
<li><p>String 中与获取相关的方法：</p>
<ul>
<li><code>public int length();</code> –&gt; 获取字符串长度</li>
<li><code>public String concat(string str);</code> –&gt; 拼接字符串，返回一个新字符串</li>
<li><code>public char charAt(int index);</code> –&gt; 获取索引位置字符</li>
<li><code>public int indexOf(String str);</code> –&gt; 获取参数字符串在本字符串中首次出现的索引位置，没有返回 -1</li>
</ul>
</li>
<li><p>字符串的截取方法：</p>
<ul>
<li><code>public String substring(int index);</code> –&gt; 截取从 index 到字符串末尾，返回一个新字符串</li>
<li><code>public String substring(int begin, int end);</code> –&gt; 截取 <strong>[ begin, end )</strong> 之间的字符串，返回一个新字符串 </li>
</ul>
</li>
<li><p>与转换相关的方法：</p>
<ul>
<li><code>public char[] toCharArray();</code> –&gt; 将字符串转换成<strong>字符数组</strong>，并返回</li>
<li><code>public byte[] getBytes();</code> –&gt; 将字符串转换成<strong>字节数组</strong>，并返回（<em>IO流中常用</em>）</li>
<li><code>public String replace(charSequence oldString, charSequence newString);</code> –&gt; 将所有出现的老字符串替换成新字符串，并返回替换后的结果</li>
</ul>
</li>
<li><p>分割字符串的方法：</p>
<ul>
<li><code>public String[] split(String regex);</code> –&gt; 按照参数的规则，对字符串进行切分，返回一个字符串数组</li>
<li><strong>注意：</strong>正则表达式中有一些特殊字符需要转义后才能对字符串进行正常切分，如：<code>. --&gt; \\.</code></li>
</ul>
</li>
<li><p>把其他类型转换成字符串：</p>
<p><code>String.valueOf()</code> –&gt; 参数可以为基础数据类型（int，long，float，double，char，boolean）或 Object</p>
<p>为对象时想当于：<code>object.toString()</code>，</p>
<p><code>String.valueOf(Object obj)</code> 源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the string representation of the &#123;<span class="doctag">@code</span> Object&#125; argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   obj   an &#123;<span class="doctag">@code</span> Object&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  if the argument is &#123;<span class="doctag">@code</span> null&#125;, then a string equal to</span></span><br><span class="line"><span class="comment"> *          &#123;<span class="doctag">@code</span> "null"&#125;; otherwise, the value of</span></span><br><span class="line"><span class="comment"> *          &#123;<span class="doctag">@code</span> obj.toString()&#125; is returned.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.Object#toString()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (obj == <span class="keyword">null</span>) ? <span class="string">"null"</span> : obj.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><p>StringBuilder 对象是一个字符序列可变的字符串</p>
<p>特点：</p>
<ul>
<li>性能好</li>
<li>线程不安全</li>
</ul>
<p>StringBuilder 常用方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 StringBuilder</span></span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">sb.append(<span class="string">"aa"</span>);</span><br><span class="line">sb.setCharAt(<span class="number">1</span>,<span class="string">'bb'</span>);</span><br><span class="line">sb.insert(<span class="number">2</span>,<span class="string">'cc'</span>);</span><br><span class="line">sb.delete(<span class="number">1</span>,<span class="number">6</span>); <span class="comment">// 删除下标为1-5的元素</span></span><br><span class="line">sb.deleteCharAt(<span class="number">3</span>); <span class="comment">// 删除指定位置元素</span></span><br><span class="line">sb.reverse();  <span class="comment">// 逆序</span></span><br><span class="line">sb.length();</span><br><span class="line">sb.indexOf(<span class="string">"dd"</span>); <span class="comment">// 返回指定元素索引</span></span><br></pre></td></tr></table></figure>





<h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><p>StringBuffer 对象也是一个字符序列可变的字符串。</p>
<p>StringBuffer 中的方法和 StringBuilder 中的方法时一样的。</p>
<p>特点：</p>
<ul>
<li>性能不好（相较于 StringBuilder）</li>
<li>线程安全</li>
</ul>
<h2 id="File"><a href="#File" class="headerlink" title="File"></a>File</h2><h4 id="创建-File-对象："><a href="#创建-File-对象：" class="headerlink" title="创建 File 对象："></a>创建 File 对象：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据文件路径创建： File(String Path)</span></span><br><span class="line">File src = <span class="keyword">new</span> File(<span class="string">"C:/Users/pikachu/eclipse-workspace/sxt.Io/Java学习路线图.jpg"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据目录 + 文件名创建：File(String parent, String child)</span></span><br><span class="line">File src = <span class="keyword">new</span> File(<span class="string">"C:/Users/pikachu/eclipse-workspace/sxt.Io"</span>, <span class="string">"Java学习路线图.jpg"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据目录对象 + 文件名创建：File(File parent, String child)</span></span><br><span class="line">File src = <span class="keyword">new</span> File(<span class="keyword">new</span> File(<span class="string">"C:/Users/pikachu/eclipse-workspace/sxt.Io"</span>), <span class="string">"Java学习路线图.jpg"</span>);</span><br></pre></td></tr></table></figure>



<blockquote>
<p>无论路径对错都能创建 File 对象，因为 File 对象只是一个中间人，真正操作文件的是操作系统。</p>
</blockquote>
<h4 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h4><ol>
<li><p>基本信息：</p>
<ul>
<li><code>getName()</code> -&gt;  获得文件名</li>
<li><code>getPath()</code> -&gt;    获得传入的路径（相对路径或绝对路径）</li>
<li><code>getAbsolutePath()</code> -&gt; 获得绝对路径</li>
<li><code>getParent()</code> -&gt; 获得父路径（返回的是传入的文件名前面的一级路径，如果没有，则返回 null）</li>
</ul>
</li>
<li><p>文件状态：</p>
<ul>
<li><code>exists()</code> -&gt; 是否存在</li>
<li><code>isFile()</code> -&gt; 是否为文件</li>
<li><code>isDirectory()</code> -&gt; 是否为文件夹</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断文件状态的标准代码</span></span><br><span class="line">File src = <span class="keyword">new</span> File(<span class="string">"xxx"</span>);</span><br><span class="line"><span class="keyword">if</span>(src == <span class="keyword">null</span> || !src.exists()) &#123;</span><br><span class="line">	System.out.println(<span class="string">"文件不存在"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(src.isFile()) &#123;</span><br><span class="line">	System.out.println(<span class="string">"文件操作"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">"目录操作"</span>);</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li>文件长度：</li>
</ol>
<ul>
<li><code>length()</code> -&gt; 返回文件的长度（字节数），文件夹返回 0</li>
</ul>
<ol start="4">
<li><p>创建 &amp; 删除文件：</p>
<ul>
<li><code>createNewFile()</code> –&gt; 不存在创建成功，已存在创建失败</li>
<li><code>delete()</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建文件</span></span><br><span class="line">File src = <span class="keyword">new</span> File(<span class="string">"C:/Users/pikachu/eclipse-workspace/sxt.Io/Java学习路线图02.jpg"</span>);</span><br><span class="line"><span class="keyword">boolean</span> isCreate = src.createNewFile(); <span class="comment">// 返回是否创建成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除文件</span></span><br><span class="line"><span class="keyword">boolean</span> isDelete = src.delete(); <span class="comment">// 返回是否删除成功</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="5">
<li><p>创建目录（文件夹）：</p>
<ul>
<li><code>mkdir()</code> –&gt; 如果上级目录不存在，则会创建失败</li>
<li><code>mkdirs()</code> –&gt; 如果上级目录不存在，则一同创建（常用，不需要考虑上级目录是否存在，容错率高）</li>
</ul>
</li>
<li><p>列出下级目录：</p>
<ul>
<li><code>list()</code> –&gt; 列出下级文件及文件夹名称，返回一个 <code>String[]</code></li>
<li><code>listFiles()</code> –&gt; 列出下级文件及文件夹对象，返回一个 <code>File[]</code></li>
</ul>
</li>
<li><p>统计文件夹大小</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统计文件夹的大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pikachu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirCount</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span> Count;</span><br><span class="line">	<span class="keyword">private</span> String path;</span><br><span class="line">	<span class="keyword">private</span> File src;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DirCount</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.path = path;</span><br><span class="line">		<span class="keyword">this</span>.src = <span class="keyword">new</span> File(path);</span><br><span class="line">		count(<span class="keyword">this</span>.src);		<span class="comment">// 新建 File 对象的时候就计算文件夹的大小</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 统计文件夹大小</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">(File src)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">null</span> != src &amp;&amp; src.exists()) &#123;</span><br><span class="line">			<span class="keyword">if</span>(src.isFile()) &#123;</span><br><span class="line">				Count += src.length();</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">for</span>(File s:src.listFiles()) &#123;</span><br><span class="line">					count(s);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// get方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Count;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 测试</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		DirCount dc = <span class="keyword">new</span> DirCount(<span class="string">"C:\\Users\\pikachu\\eclipse-workspace\\sxt.Io"</span>);</span><br><span class="line">		System.out.println(dc.getCount());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ol>
<h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p>Date 是表示时间的类，其中的好多方法现在已经废弃不用了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date d = <span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(d); <span class="comment">// 获取计算机的当前时间</span></span><br><span class="line"></span><br><span class="line">System.out.println(d.getTime()) <span class="comment">// 获取当前时间的毫秒数</span></span><br></pre></td></tr></table></figure>

<h2 id="DateFormat"><a href="#DateFormat" class="headerlink" title="DateFormat"></a>DateFormat</h2><p>DateFormat 是用于时间格式化的抽象类，<strong>SimpleDateFormat</strong> 为其实现类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将时间按照指定格式转换为字符串</span></span><br><span class="line">DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd hh:mm:ss"</span>);</span><br><span class="line">String s = df.format(<span class="keyword">new</span> Date()); <span class="comment">// 将当前时间传入</span></span><br><span class="line">System.out.println(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串按照指定格式转换为时间</span></span><br><span class="line">DateFormat df2 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd hh:mm:ss"</span>);</span><br><span class="line">Date d = df2.parse(<span class="string">"2019-3-2 15:30:26"</span>);</span><br><span class="line">System.out.println(d);</span><br></pre></td></tr></table></figure>

<h2 id="Calendar、GregorianCalendar"><a href="#Calendar、GregorianCalendar" class="headerlink" title="Calendar、GregorianCalendar"></a>Calendar、GregorianCalendar</h2><p>Calendar 是表示日期的抽象类，GregorianCalendar 为其实现类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get方法</span></span><br><span class="line">Calendar c1 = <span class="keyword">new</span> GregorianCalendar(<span class="number">2019</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">19</span>,<span class="number">55</span>);</span><br><span class="line"><span class="keyword">int</span> year = c1.get(Calendar.YEAR);</span><br><span class="line"><span class="keyword">int</span> month = c1.get(Calendar.MONTH);</span><br><span class="line">System.out.println(year);</span><br><span class="line">System.out.println(month);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set方法</span></span><br><span class="line">Calendar c2 = <span class="keyword">new</span> GregorianCalendar();</span><br><span class="line">c2.set(Calendar.YEAR, <span class="number">2222</span>);</span><br><span class="line">System.out.println(c2);</span><br><span class="line">c2.add(Calendar.DAY_OF_MONTH,<span class="number">20</span> );</span><br><span class="line">System.out.println(c2);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Scanner</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis</title>
    <url>/2019/04/28/Java/3.SSM%E6%A1%86%E6%9E%B6/MyBatis/</url>
    <content><![CDATA[<p>MyBatis 是一款优秀的持久层框架</p>
<a id="more"></a>

<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><blockquote>
<p>三层架构的概念:</p>
<ul>
<li>表现层：<pre><code>用于展示数据</code></pre></li>
<li>业务层：<pre><code>处理业务需求</code></pre></li>
<li>持久层：<pre><code>与数据库交互</code></pre></li>
</ul>
</blockquote>
<h2 id="MyBatis-概述："><a href="#MyBatis-概述：" class="headerlink" title="MyBatis 概述："></a><strong>MyBatis 概述：</strong></h2><p><strong>1、基本概念：</strong></p>
<p><strong>MyBatis</strong> 是一款<strong>持久层</strong>框架，由 Java 编写</p>
<p>它封装了 JDBC 操作的很多细节，使开发者只需要关注 SQL 语句本身，而无需关注注册驱动，创建连接等繁杂过程</p>
<p>它使用了 <strong>ORM 思想</strong>实现了结果集的封装</p>
<blockquote>
<p><strong>ORM：</strong><br>        Object Relational Mappging 对象关系映射<br>        简单的说：<br>                就是把数据库表和实体类及实体类的属性对应起来<br>                让我们可以操作实体类就实现操作数据库表。</p>
<p><u>就是让类中的<strong>属性名</strong>称和数据库的<strong>列名</strong>相同</u></p>
</blockquote>
<p><strong>动态 SQL</strong></p>
<p>动态 SQL 的作用是：查询时不确定是否有查询条件，可以用相关的标签 跟在查询语句后面来实现动态的 SQL 语句</p>
<p>标签：</p>
<ul>
<li><strong>if</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">select * from user where 1=1</span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span> = <span class="string">"username != null"</span>&gt;</span></span><br><span class="line">    and username = #&#123;username&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>where</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">select * from user</span><br><span class="line"><span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span> = <span class="string">"username != null"</span>&gt;</span></span><br><span class="line">        and username = #&#123;username&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span> = <span class="string">"address != null"</span>&gt;</span></span><br><span class="line">        and address = #&#123;address&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>foreach</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--相当于：select * from user where id in () --&gt;</span></span><br><span class="line">select * from user</span><br><span class="line"><span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"ids != null and ids.size() &gt; 0"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"ids"</span> <span class="attr">open</span>=<span class="string">"id in ( "</span> <span class="attr">close</span>=<span class="string">")"</span> <span class="attr">item</span>=<span class="string">"uid"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">            #&#123;uid&#125;  <span class="comment">&lt;!--大括号中的值与item属性的值一致--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>如果在映射配置文件中有出现次数较多的 SQL 语句，可以使用 <code>&lt;sql&gt;&lt;/sql&gt;</code> 标签把它提取出来</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--定义在mapper标签中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"selectUser"</span>&gt;</span></span><br><span class="line">       select * from user <span class="comment">&lt;!--此处不要加分号，因为别的语句调用它的时候可能会进行拼接，有分号会出错--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure>


</blockquote>
<h2 id="MyBatis-的基础使用"><a href="#MyBatis-的基础使用" class="headerlink" title="MyBatis 的基础使用"></a>MyBatis 的基础使用</h2><p>介绍使用 maven 来构建项目时，MyBatis 该如何使用</p>
<p><strong>1、在 maven 的配置文件 pom.xml 中配置依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mybatis的依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- mysql的依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- log4j的依赖，用于打印日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- junit的依赖，用于单元测试 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>2、在 main/java 下，创建包：<code>com.pika.dao</code>，在包下创建 UserDao 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pika.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询所有</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>3、在 main/java 下，创建包：<code>com.pika.domain</code>，在包下创建 User 类（封装数据库表查询结果的类）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pika.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 属性（属性名与数据库表的列名相同）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// getter&amp;setter</span></span><br><span class="line">    <span class="comment">// toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>4、在 <strong>main/resource</strong> 目录下，新建 mybatis 的<strong>主配置文件</strong>，通常命名为 <strong>SqlMapConfig.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 环境配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 配置事务的类型 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 配置连接池 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql:///exam"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 映射文件的位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用xml配置文件时 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"com/pika/dao/UserDao.xml"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用注解时 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">"com.pika.dao.userDao"</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 使用别名的方式时，就不用配 mapper 了 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"cn.hellopika.dao"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>  MyBatis中DataSource 的分类</p>
<ul>
<li><p>POOLED        –&gt; 使用“池”的概念创建连接</p>
</li>
<li><p>UNPOOLED  –&gt;  每次都新创建一个连接</p>
</li>
<li><p>JNDI               –&gt; 采用服务器提供的JNDI技术实现，获取DataSource对象  </p>
</li>
</ul>
</blockquote>
<p>5、在 main/resource 下，创建包：<code>com.pika.dao</code>，在包下创建 <strong>UserDao.xml 映射配置文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- namespace: 这个映射配置文件对应的dao --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.pika.dao.UserDao"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 查询所有 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- resultType: 结果集封装的实体类的全限定类名，如果配了别名可以直接写别名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultType</span>=<span class="string">"com.pika.domain.User"</span>&gt;</span></span><br><span class="line">        select * from user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>6、在 test/Java 下，创建测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 1.加载配置文件</span></span><br><span class="line">    InputStream in = Resources.getResourceAsStream(<span class="string">"SqlMapConfig.xml"</span>);</span><br><span class="line">    <span class="comment">// 2.创建工厂</span></span><br><span class="line">    SqlSessionFactoryBuilder builder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">    SqlSessionFactory factory = builder.build(in);</span><br><span class="line">    <span class="comment">// 3.获取SqlSession对象</span></span><br><span class="line">    SqlSession session = factory.openSession();</span><br><span class="line">    <span class="comment">// 4.创建dao代理对象</span></span><br><span class="line">    UserDao userdao = session.getMapper(UserDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 5.执行sql语句</span></span><br><span class="line">    List&lt;User&gt; users = userdao.findAll();</span><br><span class="line">    <span class="keyword">for</span> (User user:users) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.释放资源</span></span><br><span class="line">    session.close();</span><br><span class="line">    in.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>OGNL表达式：<code>#{}</code> 或 <code>${}</code></p>
<p>​    Object Graphic Navigation Language</p>
<p>它可以通过对象的 getter 方法来获取数据，在写法上把 get 给省略了</p>
<p>类中：<code>user.getUsername</code></p>
<p>表达式写法：<code>user.username</code></p>
</blockquote>
<p><strong>实体类属性名和数据库列名不一致时解决方法：</strong></p>
<p>在映射配置文件的 <strong>mapper 中添加 resultMap 标签</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置实体类属性名和数据库列名的对应关系--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- id可以任取，type为实体类的全限定类名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"userMap"</span> <span class="attr">type</span>=<span class="string">"com.pika.domain.User"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 主键字段的对应 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">""</span> <span class="attr">column</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 非主键字段的对应 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">""</span> <span class="attr">column</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">""</span> <span class="attr">column</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="properties标签、typeAliases标签、package标签"><a href="#properties标签、typeAliases标签、package标签" class="headerlink" title="properties标签、typeAliases标签、package标签"></a>properties标签、typeAliases标签、package标签</h3><p><strong>properties标签</strong>：定义主配置文件的 configuration 标签中</p>
<ul>
<li><p>可以直接在标签内部写连接数据库的信息</p>
</li>
<li><p>也可用于加载外部配置文件中的连接数据库的信息</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--属性：resource：指定外部配置文件的位置，按照类路径的写法来写--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"jdbc.properties"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt;</span></span><br><span class="line"><span class="comment">    &lt;property name="url" value="jdbc:mysql:///exam"/&gt;</span></span><br><span class="line"><span class="comment">    &lt;property name="username" value="root"/&gt;</span></span><br><span class="line"><span class="comment">    &lt;property name="password" value="root"/&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>typeAliases标签</strong>：定义在主配置文件的 configuration 标签中，使用 typeAliases 只能配置 domain 中类的别名</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--type属性是实体类的全限定类名，alias是别名，指定了别名之后就不再区分大小写了--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">"com.pika.domain.User"</span> <span class="attr">alias</span>=<span class="string">"user"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--指定要配置别名的包，指定之后该包下的所有实体类都会注册别名，类名就是别名，不再区分大小写--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.pika.domain"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>package标签</strong>：可以配置在 typeAliases 标签中以及 mappers 标签中</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--package标签指定dao接口所在的包，指定了之后mappers就算写完了，不再需要mapper标签以及resource或class--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.pika.dao"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h2 id="Mybatis-对事务的管理"><a href="#Mybatis-对事务的管理" class="headerlink" title="Mybatis 对事务的管理"></a>Mybatis 对事务的管理</h2><blockquote>
<p>Mybatis 默认是开启事务的，也就是 Mybatis 中执行增删改操作时默认需要自己提交事务</p>
</blockquote>
<p>提交事务：SqlSession 对象的 commit() 方法</p>
<p>回滚事务：SqlSession 对象的 roolback() 方法</p>
<p>设置自动提交事务： SqlSession session = factory.openSession(true); // 在创建SQLSession对象时设置openSession的属性为true</p>
<h2 id="Mybatis的多表查询"><a href="#Mybatis的多表查询" class="headerlink" title="Mybatis的多表查询"></a>Mybatis的多表查询</h2><blockquote>
<p>mybatis 中把多对一的操作当成一对一</p>
</blockquote>
<h4 id="mybatis中一对一的查询"><a href="#mybatis中一对一的查询" class="headerlink" title="mybatis中一对一的查询:"></a>mybatis中一对一的查询:</h4><ol>
<li><p>在从表实体类中包含一个主表实体类 的对象引用</p>
</li>
<li><p>在从表的配置文件中配置 resultMap</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--type: 从表的实体类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"accountUser"</span> <span class="attr">type</span>=<span class="string">"com.pika.domain.Account"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"aid"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"uid"</span> <span class="attr">column</span>=<span class="string">"uid"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"money"</span> <span class="attr">column</span>=<span class="string">"money"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--property: 从表实体类中的主表引用对象, column: 从表外键列, javaType: 主表实体类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"user"</span> <span class="attr">column</span>=<span class="string">"uid"</span> <span class="attr">javaType</span>=<span class="string">"com.pika.domain.User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"birthday"</span> <span class="attr">column</span>=<span class="string">"birthday"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"sex"</span> <span class="attr">column</span>=<span class="string">"sex"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"address"</span> <span class="attr">column</span>=<span class="string">"address"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="mybatis-中一对多的查询"><a href="#mybatis-中一对多的查询" class="headerlink" title="mybatis 中一对多的查询:"></a>mybatis 中一对多的查询:</h4><ol>
<li>在主表实体类中新建从表实体类的集合（List）</li>
<li>在主表的配置文件中配置 resultMap</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"userAccountMap"</span> <span class="attr">type</span>=<span class="string">"com.pika.domain.User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"birthday"</span> <span class="attr">column</span>=<span class="string">"birthday"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"sex"</span> <span class="attr">column</span>=<span class="string">"sex"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"address"</span> <span class="attr">column</span>=<span class="string">"address"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- property: 从表的集合对象，ofType: 集合中的元素类型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"accounts"</span> <span class="attr">ofType</span>=<span class="string">"com.pika.domain.Account"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"aid"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"uid"</span> <span class="attr">column</span>=<span class="string">"uid"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"money"</span> <span class="attr">column</span>=<span class="string">"money"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="mybatis-中多对多的查询"><a href="#mybatis-中多对多的查询" class="headerlink" title="mybatis 中多对多的查询:"></a>mybatis 中多对多的查询:</h4><p>多对多查询  ==  双向一对多查询</p>
<h2 id="Mybatis-的延迟加载"><a href="#Mybatis-的延迟加载" class="headerlink" title="Mybatis 的延迟加载"></a>Mybatis 的延迟加载</h2><p>立即加载和延迟加载的概念</p>
<ul>
<li>立即加载：不管数据用不用，只要调用方法，马上发起查询<ul>
<li>一对一 、多对一（Mybatis中就是一对一）通常使用立即加载</li>
</ul>
</li>
<li>延迟加载：真正使用数据的时候才发起查询，按需加载（懒加载）<ul>
<li>一对多、多对多通常使用延迟加载</li>
</ul>
</li>
</ul>
<p>立即加载和延迟加载的实现方式：</p>
<ul>
<li><p>立即加载：多表查询时，直接在 SQL 语句中写内连接或外连接方式，就是立即加载</p>
</li>
<li><p>延迟加载：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--在主配置文件中开启延迟加载（默认就是开启的）--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 延迟加载的全局开关 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">&lt;!-- 开启后，任何方法的调用都会加载该对象的所有属性</span></span><br><span class="line"><span class="comment">          Mybatis 3.4.1 版本之后默认关闭 </span></span><br><span class="line"><span class="comment">      --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"aggressiveLazyLoading"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>一对一延迟加载的实现：查询所有账户，延迟加载账户的用户信息</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--在从表的resultMap中修改 association--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"accountUser"</span> <span class="attr">type</span>=<span class="string">"com.pika.domain.Account"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"aid"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"uid"</span> <span class="attr">column</span>=<span class="string">"uid"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"money"</span> <span class="attr">column</span>=<span class="string">"money"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--select:查询用户的唯一标识--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"user"</span> <span class="attr">column</span>=<span class="string">"uid"</span> <span class="attr">javaType</span>=<span class="string">"com.pika.domain.User"</span> <span class="attr">select</span>=<span class="string">"com.pika.dao.UserDao.findById"</span>&gt;</span><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultMap</span>=<span class="string">"accountUser"</span>&gt;</span></span><br><span class="line">    select * from account</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>一对多实现延迟加载</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--在主表的resultMap中修改 collection--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"userAccountMap"</span> <span class="attr">type</span>=<span class="string">"com.pika.domain.User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"birthday"</span> <span class="attr">column</span>=<span class="string">"birthday"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"sex"</span> <span class="attr">column</span>=<span class="string">"sex"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"address"</span> <span class="attr">column</span>=<span class="string">"address"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- property: 从表的集合对象，ofType: 集合中的元素类型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"accounts"</span> <span class="attr">ofType</span>=<span class="string">"com.pika.domain.Account"</span> <span class="attr">select</span>=<span class="string">"com.pika.dao.AccountDao.findByUid"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultMap</span>=<span class="string">"userAccountMap"</span>&gt;</span></span><br><span class="line">    select * from user;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>





</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Mybatis-中的缓存"><a href="#Mybatis-中的缓存" class="headerlink" title="Mybatis 中的缓存"></a>Mybatis 中的缓存</h2><p><strong>缓存的概念：</strong>存在于内存中的临时数据</p>
<p><strong>为什么使用缓存：</strong>减少和数据库的交互次数，提高执行效率</p>
<p><strong>什么样的数据能使用缓存：</strong>经常查询、不经常修改、数据的对错对最终结果影响不大</p>
<p><strong>Mybatis 中的一级缓存和二级缓存：</strong></p>
<ul>
<li><p>一级缓存：</p>
<ul>
<li><p>概念：</p>
<p>指的是 SQLSession 对象的缓存，执行查询之后，查询结果会同时存入一级缓存中，一级缓存的结构是一个 Map，再次查询同样的数据时，Mybatis 会先去一级缓存中找是否有，有的话直接拿来用。</p>
<p>SqlSession 对象消失时，Mybatis 的一级缓存也就消失了</p>
</li>
<li><p>一级缓存的清空：</p>
<p>当调用SQLSession的 修改、添加、删除、commit()、close()、clearCache() 等方法时，就会清空一级缓存。（当执行增删改操作时，一级缓存会自动同步）</p>
</li>
</ul>
</li>
<li><p>二级缓存：</p>
<ul>
<li><p>概念：</p>
<p>指的是 SQLSessionFactory 对象的缓存，由同一个 SQLSessionFactory 对象创建的 SQLSession 共享其缓存</p>
</li>
<li><p>二级缓存的使用步骤：</p>
<ol>
<li><p>让Mybatis 框架支持二级缓存</p>
<p>在 SqlMapConfig.xml 中配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"True"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ul>
</li>
</ul>
<pre><code>2. 让当前的映射文件支持二级缓存

   在 UserDao.xml 中配置：直接在 mapper 中添加`&lt;cache/&gt;`

3. 让当前的操作支持二级缓存

   在 select 标签中配置：在 select 标签中添加属性 `useCache=“true”`</code></pre><ul>
<li><blockquote>
<p>二级缓存中存放的是数据而不是对象</p>
</blockquote>
</li>
</ul>
<h2 id="Mybatis的注解开发"><a href="#Mybatis的注解开发" class="headerlink" title="Mybatis的注解开发"></a>Mybatis的注解开发</h2><blockquote>
<p> 使用注解代替 Dao 的映射配置文件，但是 Mybatis 的主配置文件是不动的</p>
</blockquote>
<p>增删改查对应的注解：<code>@insert, @delete, @update, @select</code></p>
<p><strong>注解的基本使用方式：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询所有</span></span><br><span class="line">    <span class="meta">@select</span>(<span class="string">"select * from user"</span>)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>使用注解配置实体类属性名和表的列名对应关系：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询所有用户(实体类属性名和表的列名不一致的情况)</span></span><br><span class="line">    <span class="meta">@select</span>(<span class="string">"select * from user"</span>)</span><br><span class="line">    <span class="meta">@Results</span>(id=<span class="string">"userMap"</span>, value=&#123;</span><br><span class="line">        	<span class="meta">@Result</span>(id=<span class="keyword">true</span>, property=<span class="string">"userId"</span>, column=<span class="string">"id"</span>),</span><br><span class="line">        	<span class="meta">@Result</span>(property=<span class="string">"userName"</span>, column=<span class="string">"username"</span>),</span><br><span class="line">        	<span class="meta">@Result</span>(property=<span class="string">"userAddress"</span>, column=<span class="string">"address"</span>),</span><br><span class="line">        	<span class="meta">@Result</span>(property=<span class="string">"userSex"</span>, column=<span class="string">"sex"</span>),</span><br><span class="line">        	<span class="meta">@Result</span>(property=<span class="string">"userBirthday"</span>, column=<span class="string">"birthday"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>注解开发一对一查询配置：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询所有账户(并查询每个账户所属的用户)</span></span><br><span class="line">    <span class="meta">@select</span>(<span class="string">"select * from account"</span>)</span><br><span class="line">    <span class="meta">@Results</span>(id=<span class="string">"accountMap"</span>, value=&#123;</span><br><span class="line">        <span class="meta">@Result</span>(id=<span class="keyword">true</span>, property=<span class="string">"id"</span>, column=<span class="string">"id"</span>),</span><br><span class="line">        <span class="meta">@Result</span>(property=<span class="string">"uid"</span>, column=<span class="string">"uid"</span>),</span><br><span class="line">        <span class="meta">@Result</span>(property=<span class="string">"money"</span>, column=<span class="string">"money"</span>),</span><br><span class="line">        <span class="meta">@Result</span>(property=<span class="string">"user"</span>, column=<span class="string">"uid"</span>, one=<span class="meta">@One</span>(select=<span class="string">"com.pika.dao.UserDao.findById"</span>, fetchType=FetchType.EAGER))</span><br><span class="line">    &#125;) <span class="comment">// fetchType：立即加载还是延迟加载</span></span><br><span class="line">    <span class="function">List&lt;Acount&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>注解开发一对多查询配置：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询所有(实体类属性名和表的列名不一致的情况)</span></span><br><span class="line">    <span class="meta">@select</span>(<span class="string">"select * from user"</span>)</span><br><span class="line">    <span class="meta">@Results</span>(id=<span class="string">"userMap"</span>, value=&#123;</span><br><span class="line">        <span class="meta">@Result</span>(id=<span class="keyword">true</span>, property=<span class="string">"userId"</span>, column=<span class="string">"id"</span>),</span><br><span class="line">        <span class="meta">@Result</span>(property=<span class="string">"userName"</span>, column=<span class="string">"username"</span>),</span><br><span class="line">        <span class="meta">@Result</span>(property=<span class="string">"userAddress"</span>, column=<span class="string">"address"</span>),</span><br><span class="line">        <span class="meta">@Result</span>(property=<span class="string">"userSex"</span>, column=<span class="string">"sex"</span>),</span><br><span class="line">        <span class="meta">@Result</span>(property=<span class="string">"userBirthday"</span>, column=<span class="string">"birthday"</span>),</span><br><span class="line">        <span class="meta">@Result</span>(property=<span class="string">"accounts"</span>, column=<span class="string">"id"</span>, many=<span class="meta">@Many</span>(select=<span class="string">"com.pika.dao.AccountDao.findAccountByUid"</span>, fetchType=FetchType.LAZY))</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven</title>
    <url>/2019/04/28/Java/Maven/</url>
    <content><![CDATA[<p>Maven 是一款 Java 项目的自动化构建工具</p>
<a id="more"></a>



<p><strong>maven 的功能</strong></p>
<ul>
<li>依赖管理</li>
<li>一键构建</li>
</ul>
<p>构建的概念：以 <code>Java 源文件</code> 、 <code>框架配置文件</code> 、<code>HTML</code> 、<code>图片</code> 等资源为 <code>原材料</code>，去 <code>生产</code> 一个可运行项目的过程</p>
<p><strong>构建过程中的各个环节：</strong></p>
<ul>
<li>清理：将以前编译得到的旧的 class 字节码文件删除，为下一次编译做准备</li>
<li>编译：将 Java 源程序编译成 class 字节码文件</li>
<li>测试：自动调用 <strong>Junit</strong> 程序进行测试</li>
<li>报告：返回测试程序执行的结果</li>
<li>打包：动态 Web 程序打 <code>.war</code> 包，Java 工程打 <code>.jar</code> 包</li>
<li>安装：Maven 特定的概念 –&gt; 将打包得到的文件复制到 <code>仓库</code> 中的指定位置</li>
<li>部署：将 <code>.war</code> 包复制到指定 Servlet 容器中，使其可以运行</li>
</ul>
<p><strong>Maven的常用命令：</strong></p>
<ul>
<li>mvn clean：清理</li>
<li>mvn compile：编译主程序</li>
<li>mvn test-compile：编译测试程序</li>
<li>mvn test：执行测试</li>
<li>mvn package：打包</li>
<li>mvn install：安装</li>
<li>mvn site：生成站点</li>
</ul>
<h2 id="Maven-的核心概念"><a href="#Maven-的核心概念" class="headerlink" title="Maven 的核心概念"></a>Maven 的核心概念</h2><p>1、<strong>约定的目录结构</strong></p>
<p>2、<strong>POM</strong></p>
<p>3、<strong>坐标</strong></p>
<p>4、<u><strong>依赖</strong></u></p>
<p>5、仓库</p>
<p>6、生命周期/插件/目标</p>
<p>7、继承</p>
<p>8、聚合</p>
<hr>
<p><strong>约定的目录结构：</strong></p>
<blockquote>
<ul>
<li>Hello –&gt; 项目名<ul>
<li>src –&gt; 源码<ul>
<li>main –&gt; 主程序<ul>
<li>java –&gt; 存放 Java 源文件</li>
<li>resources –&gt; 存放框架或其他工具的配置文件</li>
</ul>
</li>
<li>text –&gt; 测试程序<ul>
<li>java</li>
<li>resources</li>
</ul>
</li>
</ul>
</li>
<li>pom.xml –&gt; Maven 工程的核心配置文件</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>POM：</strong></p>
<p>Project Object Model –&gt; 项目对象模型</p>
<p>pom.xml 是 Maven 工程的核心配置文件，与构建过程相关的一切设置都在这个文件中进行配置</p>
<p><strong>坐标：</strong></p>
<p>使用三个向量在仓库中唯一定位一个 Maven 工程</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupid</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupid</span>&gt;</span> <span class="comment">&lt;!-- 公司或组织域名倒序 + 项目名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactid</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactid</span>&gt;</span> <span class="comment">&lt;!-- 模块名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile/provided/runtime/test/system/import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span><span class="comment">&lt;!--限定该依赖的作用范围--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">	上述坐标对应的文件路径：</span></span><br><span class="line"><span class="comment">	org/springframework/spring-core/4.0.0.RELEASE/spring-core-4.0.0.RELEASE.jar</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>依赖：</strong></p>
<p>在 pom.xml 中放置项目所依赖的 jar 包的坐标，便是依赖管理</p>
<p><strong>仓库：</strong></p>
<ul>
<li><p>仓库的分类：</p>
<ul>
<li>本地仓库</li>
<li>远程仓库<ul>
<li>私服：位于局域网中的仓库</li>
<li>中央仓库：位于互联网上的仓库</li>
<li>中央仓库镜像：为了分担中央仓库流量</li>
</ul>
</li>
</ul>
</li>
<li><p>仓库中存储的内容：Maven 工程</p>
<ul>
<li>Maven 自身所需的插件</li>
<li>第三方框架或工具的 jar 包</li>
<li>自己开发的 Maven 工程</li>
</ul>
</li>
</ul>
<p><strong>生命周期：</strong>（在执行后面的明亮的时候会把前面的命令执行一遍）</p>
<ul>
<li>清理生命周期<ul>
<li>clean 命令单独的就是一个生命周期</li>
</ul>
</li>
<li>默认生命周期<ul>
<li>编译</li>
<li>测试</li>
<li>打包</li>
<li>安装</li>
<li>发布</li>
</ul>
</li>
<li>站点生命周期<ul>
<li>实际开发中不常用</li>
</ul>
</li>
</ul>
<h2 id="maven-高级"><a href="#maven-高级" class="headerlink" title="maven 高级"></a>maven 高级</h2><h3 id="1、jar-包冲突"><a href="#1、jar-包冲突" class="headerlink" title="1、jar 包冲突"></a>1、jar 包冲突</h3><p>maven 在导入 jar 包坐标时，如果导入的 jar 包与其他导入的 jar 包的依赖包相同但版本号不同，就会产生 jar 包冲突的问题</p>
<p><strong>解决jar包冲突的方式有三种：</strong></p>
<ul>
<li><p>方式一：</p>
<p>  ​    <strong>第一声明优先原则</strong>：哪个 jar 包的坐标在靠上的位置，这个 jar 包就是先声明的。</p>
<p>  ​    先声明的 jar 包坐标下的依赖包，可以优先进入项目中。</p>
</li>
<li><p>方式二：</p>
<p><strong>路径近者优先原则</strong>。直接依赖路径比传递依赖路径近，那么最终项目进入的 jar 包会是路径近的直接依赖包。</p>
<ul>
<li>直接依赖与传递依赖的概念：<pre><code>- 直接依赖：项目中直接导入的 jar 包，就是该项目的直接依赖包。
- 传递依赖：项目中没有直接导入的 jar 包，可以通过项目直接依赖 jar 包传递到项目中去。</code></pre></li>
</ul>
</li>
<li><p>方式三【<strong>推荐使用</strong>】：</p>
<p>  <strong>直接排除法</strong>（<strong>使用 exclusions 标签</strong>）</p>
<p>  当我们要排除某个 jar 包下依赖包，在配置 exclusions 标签的时候，内部可以不写版本号</p>
<p>  因为此时依赖包使用的版本和默认和本 jar 包一样。</p>
</li>
</ul>
<h3 id="2、pom-xml-中的相关标签"><a href="#2、pom-xml-中的相关标签" class="headerlink" title="2、pom.xml 中的相关标签"></a>2、pom.xml 中的相关标签</h3><p><code>&lt;properties&gt;</code>：里面定义一些键值对，可用于统一管理 jar 包版本</p>
<p><code>&lt;dependencyManagement&gt;</code>：用于锁定 jar 包版本</p>
<ul>
<li>注意：该标签中所写的jar包仅用于锁定 jar 包版本，不能导入 jar 包</li>
</ul>
<blockquote>
<p>锁定 jar 包版本的作用：</p>
<p>当 jar 包版本被锁定后，如有其它从 Maven 工程依赖当前 Maven 工程，那么即使其它的工程中的 jar 包与当前工程冲突，当前工程被锁定的 jar 包也不会被覆盖</p>
</blockquote>
<blockquote>
<p>idea 创建 maven 项目时解决创建速度慢的一个小技巧：</p>
<p>添加一对 key-value</p>
<ul>
<li>key:  archetypeCatalog</li>
<li>value:  internal</li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/2019/04/25/Java/3.SSM%E6%A1%86%E6%9E%B6/Spring/</url>
    <content><![CDATA[<p>Spring 的核心：IOC &amp; AOP</p>
<a id="more"></a>



<p><strong>Spring 核心功能：</strong></p>
<ul>
<li><strong>IoC</strong> (Inversion of Control)：控制反转</li>
<li><strong>AOP</strong> (Aspect Oriented Programming)：面向切面编程</li>
</ul>
<blockquote>
<p>耦合：程序间的依赖关系</p>
<ul>
<li>类之间的依赖关系</li>
<li>方法之间的依赖关系</li>
</ul>
<p>解耦：降低程序间的依赖关系</p>
<p>实际开发中应该：编译时不依赖，运行时依赖</p>
<p>解耦的思路</p>
<ul>
<li>第一步：使用反射创建对象，而避免使用 new 关键字</li>
<li>第二步：通过读配置文件来获取要创建对象的全限定类名</li>
</ul>
</blockquote>
<h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><p>控制反转：</p>
<ul>
<li>控制：控制对象</li>
<li>反转：转交给 Spring 负责</li>
</ul>
<p>IoC 的作用：创建和管理对象</p>
<p>IoC 的最大优点：解耦（解<strong>程序员</strong>与<strong>对象管理</strong>之间的耦合）</p>
<h4 id="怎么使用IOC"><a href="#怎么使用IOC" class="headerlink" title="怎么使用IOC"></a>怎么使用IOC</h4><ol>
<li><p>创建对象</p>
<p> maven 工程中，在<code>resource</code>目录下创建<code>applicationContext.xml</code>配置文件</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">     https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 通过bean标签来创建对象，默认在配置文件被加载时创建对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"peo1"</span> <span class="attr">class</span>=<span class="string">"com.pika.sxt.People"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用对象</p>
<ul>
<li><p>通过依赖注入使用对象</p>
</li>
<li><p>从容器中获取对象</p>
<ul>
<li><p>Spring 的核心容器：ApplicationContext  –&gt;  它是一个接口，有三个常用实现类</p>
<ul>
<li>ClassPathXmlApplicationContext：加载<strong>类路径</strong>下的配置文件</li>
<li>FileSystemXmlApplicationContext：加载<strong>磁盘任意路径</strong>的配置文件</li>
<li>AnnotationConfigApplicationContext：读取<strong>注解</strong>创建容器</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="创建对象的三种方式："><a href="#创建对象的三种方式：" class="headerlink" title="创建对象的三种方式："></a>创建对象的三种方式：</h4><p><strong>1、通过构造方法创建</strong></p>
<ul>
<li><p>无参构造方法创建：为默认情况</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"peo1"</span> <span class="attr">class</span>=<span class="string">"com.pika.sxt.People"</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>有参构造方法创建：需要明确配置</p>
<p>使用有参构造方法创建对象，只需要在配置文件中新建<code>&lt;bean&gt;&lt;/bean&gt;</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"peo1"</span> <span class="attr">class</span>=<span class="string">"com.pika.sxt.People"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  </span></span><br><span class="line"><span class="comment">		index：	参数的索引，从0开始</span></span><br><span class="line"><span class="comment">		name：	参数名</span></span><br><span class="line"><span class="comment">		type：	参数类型（要区分基本数据类型和包裹数据类型）		</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">type</span>=<span class="string">"int"</span> <span class="attr">value</span>=<span class="string">"8"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"pika"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<p><strong>2、实例工厂创建</strong></p>
<p>特点：需要先创建工厂，才能生产对象</p>
<ul>
<li><p>第一步：创建一个实例工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeopleFactory</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> People <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> People();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二步：在配置文件中配置工厂对象和需要创建的对象</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"factory"</span> <span class="attr">class</span>=<span class="string">"com.pika.sxt.PeopleFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"peo2"</span> <span class="attr">factory-bean</span>=<span class="string">"factory"</span> <span class="attr">factory-method</span>=<span class="string">"newInstance"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<p><strong>3、静态工厂创建</strong></p>
<p>特点：不需要创建工厂 bean，快速创建对象</p>
<ul>
<li><p>第一步：创建一个静态工厂(在实例工厂的方法前面加上 static )</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeopleFactory</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> People <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> People();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二步：在配置文件中创建对象</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"peo2"</span> <span class="attr">class</span>=<span class="string">"com.pika.sxt.PeopleFactory"</span> <span class="attr">factory-method</span>=<span class="string">"newInstance"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h4 id="Bean-的作用范围："><a href="#Bean-的作用范围：" class="headerlink" title="Bean 的作用范围："></a>Bean 的作用范围：</h4><p>使用 bean 标签中的 <strong>scope属性</strong> 调整 bean 的作用范围</p>
<p>scope 属性的取值：</p>
<ul>
<li><strong>singleton</strong> –&gt; 单例的（默认）</li>
<li><strong>prototype</strong> –&gt; 多例的</li>
<li><strong>request</strong> –&gt; 作用于web应用的请求范围</li>
<li><strong>session</strong> –&gt; 作用于web应用的会话范围</li>
<li><strong>global-session</strong> –&gt; 作用于集群环境的会话范围（全局会话范围）</li>
</ul>
<hr>
<h4 id="Bean-的生命周期："><a href="#Bean-的生命周期：" class="headerlink" title="Bean 的生命周期："></a>Bean 的生命周期：</h4><ul>
<li>单例对象<ul>
<li>随着容器的创建而创建，随着容器的销毁而销毁</li>
</ul>
</li>
<li>多例对象<ul>
<li>当我们使用对象时创建，当对象长时间不用时，由GC自动回收销毁</li>
</ul>
</li>
</ul>
<hr>
<h4 id="DI"><a href="#DI" class="headerlink" title="DI"></a><strong>DI</strong></h4><p><strong>DI：</strong>(Dependency Injection)：<strong>依赖注入</strong></p>
<p><strong>概念：</strong>当 A 类中需要依赖 B 类的对象时，将 B 的对象赋值给 A 的属性的过程称为依赖注入。</p>
<hr>
<p><strong>能注入的数据有三类：</strong></p>
<ul>
<li>基本类型和 String</li>
<li>其他 bean 类型</li>
<li>集合类型/复杂类型</li>
</ul>
<hr>
<h4 id="注入的方式有三种："><a href="#注入的方式有三种：" class="headerlink" title="注入的方式有三种："></a>注入的方式有三种：</h4><ul>
<li><p>通过<strong>构造方法</strong>注入</p>
<ul>
<li>在 bean 标签内部使用 <strong>constructor-arg</strong> 标签</li>
<li>constructor-arg 标签的<strong>属性</strong>：<ul>
<li>type：用于指定要注入的<strong>数据类型</strong>，该数据类型也是构造函数中某个或某些参数的类型</li>
<li>index：用于指定要注入的数据给构造函数中<strong>指定索引位置</strong>的参数赋值，索引从 0 开始</li>
<li>name：用于指定构造函数中要赋值的参数名称    <strong>—- 常用方式 —-</strong></li>
<li>value：用于提供基本类型和String类型的数据</li>
<li>ref：用于指定其他的bean类型数据，它指的是核心容器中出现过的bean</li>
</ul>
</li>
<li><strong>优势：</strong>在获取 bean 对象时，必须传入数据，否则无法创建成功</li>
<li><strong>劣势：</strong>即使用不到某些数据，也必须传入</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"now"</span> <span class="attr">class</span>=<span class="string">"java.util.Date"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"peo1"</span> <span class="attr">class</span>=<span class="string">"com.pika.sxt.People"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"8"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"pika"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor</span> <span class="attr">name</span>=<span class="string">"date"</span> <span class="attr">ref</span>=<span class="string">"now"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>通过 <strong>set 方法</strong>注入</p>
<ul>
<li><p>在 bean 标签内部使用 <strong>property</strong> 标签</p>
</li>
<li><p>property 标签的属性：</p>
<ul>
<li>name：用于指定注入时所调用的 set 方法的名称（setName –&gt; name）</li>
<li>value：用于提供基本类型和 String 类型的数据</li>
<li>ref： 用于指定其他的bean类型数据，它指的是核心容器中出现过的bean</li>
</ul>
</li>
<li><p>优势：创建对象时没有明确限制，可以直接使用默认构造函数</p>
</li>
<li><p>劣势：如果有某个成员必须有值，则 set 方法无法保证一定注入值</p>
<ul>
<li><p>属性是基本数据类型或 String 等简单的引用类型</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"peo1"</span> <span class="attr">class</span>=<span class="string">"com.pika.sxt.People"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"23"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"张三三"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 下面这种赋值的效果等同于上面 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>18<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>李四四<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果属性是其他 bean 类型</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- People 类依赖SmartPhone类，将SmartPhone类的对象注入到People类中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"peo"</span> <span class="attr">class</span>=<span class="string">"com.pika.sxt.People"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sp"</span> <span class="attr">ref</span>=<span class="string">"phone"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>   </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"phone"</span> <span class="attr">class</span>=<span class="string">"com.pika.sxt.SmartPhone"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"size"</span> <span class="attr">value</span>=<span class="string">"5.5"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"price"</span> <span class="attr">value</span>=<span class="string">"6399"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果属性是集合 set&lt;?&gt;</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"set1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>a<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>b<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>c<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>d<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果属性是 List&lt;?&gt;</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"list1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>aa<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>bb<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>cc<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>dd<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- 如果list中只有一个值 (重要)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"list1"</span> <span class="attr">value</span>=<span class="string">"aa"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果属性是数组</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"strs"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>ddd<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果属性是 <code>Map&lt;?,?&gt;</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"map1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"a"</span> <span class="attr">value</span>=<span class="string">"aa"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"b"</span> <span class="attr">value</span>=<span class="string">"bb"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"c"</span> <span class="attr">value</span>=<span class="string">"cc"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果属性是 properties</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"demo"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"key1"</span>&gt;</span>value1<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"key2"</span>&gt;</span>value2<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>用于给 List 结构的集合类型注入的标签：list，array，set<br>用于给 Map 结构的集合类型注入的标签：map，props</p>
</blockquote>
<hr>
<h3 id="IOC-基于注解配置："><a href="#IOC-基于注解配置：" class="headerlink" title="IOC 基于注解配置："></a>IOC 基于注解配置：</h3><p>IOC 常用注解：</p>
<ul>
<li><p>用于<u>创建对象</u>的</p>
<ul>
<li><code>@Component</code><ul>
<li>默认创建出的 bean 的 id 为：类名首字母改小写。</li>
<li>可使用 value 属性自定义名称：<code>@Component(value=&quot;自定义名称&quot;)</code>，value 可省略</li>
</ul>
</li>
<li><em>以下三个注解和 Component 作用完全一样，他们是 Spring 为我们提供三层架构的注解</em></li>
<li><code>@Controller</code>：一般用在表现层</li>
<li><code>@Service</code>：一般用在业务层</li>
<li><code>@Repository</code>：一般用在持久层</li>
</ul>
</li>
<li><p>用于<u>注入数据</u>的</p>
<ul>
<li><p><code>@AutoWired</code>：自动<strong>按照类型</strong>注入</p>
</li>
<li><p><code>@Qualifier</code>：在按照类型注入的基础上再<strong>按照名称</strong>注入</p>
<ul>
<li>在给类成员注入时<strong>无法单独使用</strong>（需配合 AutoWired 使用），但在给方法参数注入时可以单独使用</li>
</ul>
</li>
<li><p><code>@Resource</code>：直接按照 bean 的 id 注入，可以单独使用</p>
<ul>
<li>属性：name，用于指定 bean 的 id</li>
</ul>
<blockquote>
<p>以上三个注解都只能注入其他 bean 类型的数据，无法注入基本数据类型和 String 类型，且集合类型的注入只能通过 XML 来实现</p>
</blockquote>
</li>
<li><p><code>@Value</code>：用于注入基本数据类型和String类型</p>
<ul>
<li>属性：value –&gt; 用于指定属性的值，可以使用 SpEl 表达式（Spring中的el表达式）<ul>
<li>SpEl 的写法：${表达式}</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>用于<u>改变作用范围</u>的</p>
<ul>
<li><code>@Scope</code>：用于指定 bean 的作用范围<ul>
<li>属性：value –&gt; 常用取值：singleton，prototype</li>
</ul>
</li>
</ul>
</li>
<li><p>和<u>生命周期相关</u>的</p>
<ul>
<li><code>@PostConstruct</code>：用于指定初始化方法</li>
<li><code>@PreDestory</code>：用于指定销毁方法</li>
</ul>
</li>
</ul>
<p><strong>在有配置文件的情况下如何使用注解：</strong></p>
<ul>
<li><p>先在相应位置添加注解，然后在配置文件中告诉 Spring 在创建容器时要扫描的包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">&lt;!-- 使用该标签配置要扫描的包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"cn.hellopika"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>





</li>
</ul>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>面向切面编程的概念：</p>
<p>​        在程序原有纵向执行流程中，针对某一个或某一些方法添加通知，形成横切面的过程就叫做面向切面编程。</p>
<p><strong>常用概念：</strong></p>
<ul>
<li>原有功能（方法）：切点，pointcut</li>
<li>前置通知：在切点之前执行的功能，before advice</li>
<li>后置通知：在切点之后执行的功能，after advice</li>
<li>异常通知：切点执行过程中出现异常，会触发异常通知，throw advice</li>
<li>切面：前置通知 + 切点 + 后置通知</li>
<li>织入：把切面嵌入到原有功能的过程</li>
</ul>
<h3 id="AOP-的实现"><a href="#AOP-的实现" class="headerlink" title="AOP 的实现"></a>AOP 的实现</h3><p>实现前置、后置、异常、最终通知</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在java类中配置相应的通知</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Aspect</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"前置通知"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myAfterReturning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"后置通知"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"异常通知"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myAfter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"最终通知"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置切面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"Aspect"</span> <span class="attr">class</span>=<span class="string">"com.pika.aspect.Aspect"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置AOP --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"Aspect"</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(* com.pika.sxt.Demo.demo01())"</span> <span class="attr">id</span>=<span class="string">"mypointcut"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"myBefore"</span> <span class="attr">pointcut-ref</span>=<span class="string">"mypointcut"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">"myAfterReturning"</span> <span class="attr">pointcut-ref</span>=<span class="string">"mypointcut"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">"myException"</span> <span class="attr">pointcut-ref</span>=<span class="string">"mypointcut"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"myAfter"</span> <span class="attr">pointcut-ref</span>=<span class="string">"mypointcut"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="使用注解配置AOP"><a href="#使用注解配置AOP" class="headerlink" title="使用注解配置AOP"></a>使用注解配置AOP</h3><p>几种常用注解：</p>
<ul>
<li><code>@Component</code><ul>
<li>相当于<code>&lt;bean/&gt;</code></li>
<li>如果注解中没有参数，会把类名的首字母变成小写后，作为 bean 的 id</li>
<li>自定义名称方式：<code>@Component(&quot;自定义名称&quot;)</code></li>
</ul>
</li>
<li><code>@Aspect</code><ul>
<li>相当于<code>&lt;aop:aspect&gt;&lt;/aop:aspect&gt;</code>标签</li>
</ul>
</li>
<li><code>@Pointcut</code><ul>
<li>用法：<code>@Pointcut(&quot;execution(* com.pika.sxt.Demo.demo01())&quot;)</code></li>
</ul>
</li>
<li><code>@Before</code><ul>
<li>用法：<code>@Before(&quot;com.pika.sxt.Demo.demo01()&quot;)</code>, <strong>下同</strong></li>
</ul>
</li>
<li><code>@AfterReturning</code></li>
<li><code>@AfterThrowing</code></li>
<li><code>@After</code></li>
</ul>
<p>配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">                http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">                http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"myadvice, com.pika.sxt"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment"> 		proxy-target-class</span></span><br><span class="line"><span class="comment">		true:使用 cglib 动态代理</span></span><br><span class="line"><span class="comment">		false:使用 jdk 动态代理</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"demo"</span> <span class="attr">class</span>=<span class="string">"com.pika.sxt.Demo"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>Demo类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Pointcut</span>(<span class="string">"execution(* com.pika.sxt.Demo.demo01())"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"demo01"</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>通知类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAdvice</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"com.pika.sxt.Demo.demo01()"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"前置通知"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="meta">@AfterReturning</span>(<span class="string">"com.pika.sxt.Demo.demo01()"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myAfter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"后置通知"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="meta">@AfterThrowing</span>(<span class="string">"com.pika.sxt.Demo.demo01()"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"异常通知"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"com.pika.sxt.Demo.demo01()"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"最终通知"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="自动注入的配置"><a href="#自动注入的配置" class="headerlink" title="自动注入的配置"></a>自动注入的配置</h3><p>两种配置方法：</p>
<ul>
<li>在<code>&lt;bean&gt;</code>中通过<code>autowire=&quot;&quot;</code>进行配置，只对当前<code>&lt;bean&gt;</code>生效</li>
<li>在<code>&lt;beans&gt;</code>中通过<code>default-autowire=&quot;&quot;</code>配置，对配置文件中的所有<code>&lt;bean&gt;</code>都生效</li>
</ul>
<p><code>autowire=&quot;&quot;</code>的取值：</p>
<ul>
<li><p>default：默认值，在<code>&lt;bean&gt;</code>中配置的默认值为全局<code>default-autowire=&quot;&quot;</code>的值，如果在全局和局部都没有配置的情况下，相当于no</p>
</li>
<li><p>no：不自动注入</p>
</li>
<li><p>byName：根据名称匹配进行自动注入</p>
</li>
<li><p>byType：根据类型匹配自动注入</p>
<blockquote>
<p>使用 byType 时在 Spring 容器中不能出现两个相同类型的<code>&lt;bean&gt;</code></p>
</blockquote>
</li>
</ul>
<ul>
<li>constructor：根据构造方法进行自动注入<ul>
<li>提供对应参数的构造方法</li>
<li>底层使用的时 byName，匹配的是构造方法的参数名</li>
</ul>
</li>
</ul>
<h2 id="Spring-新注解"><a href="#Spring-新注解" class="headerlink" title="Spring-新注解"></a>Spring-新注解</h2><p>如果想要完全使用注解配置 Spring 的 IOC，就需要使用一些其他的注解</p>
<blockquote>
<p>完全使用注解配置 Spring 的 IOC 的步骤：</p>
<p>1、首先，需要新建一个配置类，把需要配置的内容都放到配置类中</p>
<p>2、创建容器时，使用 <code>AnnotationConfigApplicationContext(配置类名.class)</code> 实现类</p>
</blockquote>
<ul>
<li><code>@Configuration</code><ul>
<li>作用：指定当前类为一个配置类</li>
<li>细节：当配置类作为 AnnotationConfigApplicationContext 的参数时，该注解可以不写</li>
</ul>
</li>
<li><code>@ComponentScan(“包名”)</code><ul>
<li>作用：用于通过注解指定Spring在创建容器时要扫描的包</li>
<li>属性：value，basePackages， 两个属性其实是一样的。</li>
</ul>
</li>
<li><code>@Bean</code><ul>
<li>作用：用于把当前<strong>方法的返回值</strong>作为 bean 对象，存入 Spring 的 IOC 容器中</li>
<li>属性：name –&gt; 用于指定 bean 的 id，如果不写，<strong>默认是方法的名称</strong></li>
<li>细节：使用注解配置时，如果方法有参数，Spring 会去容器中查找有没有可用的 bean 对象，查找的方式和 Autowired 注解一样</li>
</ul>
</li>
<li><code>@Import(配置类名.class)</code><ul>
<li>作用：如果有多个配置类时，<strong>将其他的配置类导入主配置类</strong>中使用该注解</li>
<li>细节：被导入的配置类不需要使用 @configuration 注解</li>
</ul>
</li>
<li><code>@propertySource(配置文件路径及名称 例 &quot;classpath:jdbcConfig.properties&quot;)</code><ul>
<li>作用：用于指定 properties 文件的位置</li>
<li>classpath：表示在类路径下</li>
</ul>
</li>
</ul>
<blockquote>
<p>PS：注解和 xml 配置方式的选择：</p>
<p>使用注解和 xml 相结合的方式是最优选择</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC</title>
    <url>/2019/04/18/Java/1.Java%E5%9F%BA%E7%A1%80/JDBC/</url>
    <content><![CDATA[<p>Java 数据库连接器</p>
<a id="more"></a>



<p>JDBC：Java DataBase Connectivity</p>
<ul>
<li>JDBC 是 Java 官方编写的一套接口，用于操作所有的关系型数据库</li>
<li>每个数据库厂商都为自己的数据库实现了该接口，提供了数据库驱动 jar 包</li>
<li>我们使用这套接口编程，真正执行的是厂商提供的 jar 包中的实现类</li>
</ul>
<blockquote>
<p><strong>JDBC 中常用的接口及其方法</strong></p>
<ul>
<li>DriverManager<ul>
<li><code>static void registerDriver(Driver driver)</code> –&gt; 注册驱动</li>
<li><code>static Connection getConnection(String url, String user, String password)</code> –&gt; 获取 Connection 对象</li>
</ul>
</li>
<li>Connection<ul>
<li><code>Statement createStatement()</code> –&gt; 获取 Statement 对象</li>
<li><code>PreparedStatement prepareStatement(String sql)</code> –&gt; 获取 PreparedStatement 对象</li>
<li><strong>事务相关方法</strong><ul>
<li>开启事务：<code>setAutoCommit(boolean autoCommit)</code> –&gt; 参数为 false，开启事务</li>
<li>回滚事务：<code>roolback()</code></li>
<li>提交事务：<code>commit()</code></li>
</ul>
</li>
</ul>
</li>
<li>Statement<ul>
<li><code>int executeUpdate(String sql)</code> –&gt; 执行 DML 和 DDL（基本不用）语句，返回被修改行数，可以通过返回值判断 DML 语句是否执行成功，返回值 &lt; 0,则表示执行失败</li>
<li><code>ResultSet executeQuery(String sql)</code> –&gt; 执行 DQL 语句，返回 ResultSet</li>
</ul>
</li>
<li>PreparedStatement<ul>
<li><code>setXxx(参数1，参数2)</code><ul>
<li>参数1：? 的位置</li>
<li>参数2：给 ? 赋的值</li>
</ul>
</li>
</ul>
</li>
<li>ResultSet<ul>
<li><code>boolean next()</code> –&gt; 将<strong>行光标</strong>向下移动一行，并判断该行是否有数据，返回boolean</li>
<li>getXxx(列编号/列名称) –&gt; 获取该行中某一列的属性值，Xxx为类型名称</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>一、使用 Java 操作数据库的基础三步：</strong></p>
<p>1、导 jar 包</p>
<p>2、注册驱动</p>
<ul>
<li><p>使用<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code>注册驱动</p>
<ul>
<li><p><strong>注册驱动底层原理：</strong></p>
<p>使用反射加载 Driver 驱动类之后，自动调用 Driver 类的静态初始化块，</p>
<p>其中调用了<code>DriverManager.registerDriver(Driver driver)</code>方法</p>
<p>这个方法为注册驱动的核心方法</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>在 mysql-1.5 jar 包版本之后，可以省略注册驱动的步骤 </p>
</blockquote>
<p>3、给出 url、username、password 得到连接对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);<span class="comment">// 加载驱动类</span></span><br><span class="line"></span><br><span class="line">String url = <span class="string">"jdbc:mysql://localhost:3306/exam"</span>;</span><br><span class="line">String username = <span class="string">"root"</span>;</span><br><span class="line">String password = <span class="string">"root"</span>;</span><br><span class="line"><span class="comment">// 得到连接对象</span></span><br><span class="line">Connection conn = DriverManager.getConnection(url,username,password);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果是连接本机的MySQL，且端口为默认的3306，那么url可以简写为：<code>jdbc:mysql:///exam</code></p>
</blockquote>
<p><strong>二、对数据库进行增、删、改</strong></p>
<ol>
<li>通过 Connection 对象创建 Statement（语句发送器，向数据库发送sql语句）</li>
<li>调用 Statement 的 executeUpdate(String sql) ，可以发送 DDL、DML</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对数据进行增 删 改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 Connection 对象创建 Statement</span></span><br><span class="line">Statement stmt = conn.createStatement();</span><br><span class="line">String sql =  <span class="string">"create table jdbctable(name varchar(30), age int)"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用Statement的 executeUpdate(String sql),返回一个int，代表所修改的行数</span></span><br><span class="line"><span class="keyword">int</span> count = stmt.executeUpdate(sql);</span><br></pre></td></tr></table></figure>



<p><strong>三、对数据进行查询操作</strong></p>
<ol>
<li>通过 Connection 对象创建 Statement</li>
<li>调用 Statement 的 ResultSet rs = stmt.executeQuery(String querysql)，发送DQL</li>
<li>解析 ResultSet <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 Statement </span></span><br><span class="line">Statement stmt = conn.createStatement();</span><br><span class="line"><span class="comment">// 调用 executeQuery()方法</span></span><br><span class="line">ResultSet rs = stmt.executeQuery(<span class="string">"select * from emp"</span>);</span><br><span class="line"><span class="comment">// 解析 ResultSet</span></span><br><span class="line"><span class="keyword">while</span>(rs.next())&#123; <span class="comment">// 将行光标移动到下一行，并判断下一行是否存在，返回boolean</span></span><br><span class="line">    <span class="keyword">int</span> empno = rs.getInt(<span class="number">1</span>);<span class="comment">// 通过编号来获取该列的值</span></span><br><span class="line">    String ename = rs.getString(<span class="string">"ename"</span>);<span class="comment">// 通过列名来获取该列的值</span></span><br><span class="line">    <span class="keyword">double</span> sal = rs.getDouble(<span class="string">"sal"</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(empno + <span class="string">","</span> + ename +<span class="string">","</span> + sal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rs.close();</span><br><span class="line">stmt.close();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure>




</li>
</ol>
<h2 id="JDBC-中相关接口及类的介绍"><a href="#JDBC-中相关接口及类的介绍" class="headerlink" title="JDBC 中相关接口及类的介绍"></a>JDBC 中相关接口及类的介绍</h2><p><strong>ResultSet</strong><br>ResultSet 表示结果集，它是一个二维的表格，其内部有一个<strong>行光标</strong>    </p>
<ul>
<li><strong>previous()</strong> –&gt; 把光标向上移动一行</li>
<li><strong>next()</strong> –&gt; 把光标向下移动一行</li>
<li><strong>getRow()</strong> –&gt; 返回当前光标所在行<br>获取结果集<strong>元数据</strong>：</li>
<li>得到元数据 <strong>rs.getMetaData()</strong> ,返回值为 <strong>ResultSetMetaData</strong></li>
<li>获取结果集列数：<strong>getColumnCount()</strong></li>
<li>获取指定列名：<strong>getColumnName(int index)</strong></li>
</ul>
<p><strong>preparedStatement</strong><br>PreparedStatement 是 Statement 接口的子接口<br>PreparedStatement 的<strong>优点</strong>：</p>
<ul>
<li>防止 SQL 攻击</li>
<li>提高代码的可读性、可维护性</li>
<li>提高效率</li>
</ul>
<p>PreparedStatement 的<strong>使用步骤</strong>：</p>
<ol>
<li>新建 sql 模板，用 <code>?</code> 代替参数</li>
<li>使用 Connection 的 PreparedStatement(String sql) 创建，创建时就与 sql 模板绑定</li>
<li>使用 setXxxx 方法为模板中的 <code>?</code> 赋值</li>
<li>调用 executeUpdate() 或 executeQuery() 方法，调用的方法时<strong>没有参数</strong>的</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PreparedStatement 的使用步骤：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.新建 sql模板</span></span><br><span class="line">String sql = <span class="string">"select * from tab_stu where username=? password=?"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建PreparedStatement对象</span></span><br><span class="line">PreparedStatement pstmt = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.使用setXxxx 方法为参数赋值</span></span><br><span class="line">pstmt.setString(<span class="number">1</span>,username);</span><br><span class="line">pstmt.setString(<span class="number">2</span>,password);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.调用executeQuery() 方法</span></span><br><span class="line">ResultSet rs = pstmt.executeQuery();</span><br></pre></td></tr></table></figure>
<p><strong>预处理：</strong></p>
<ul>
<li>数据库服务器的工作<ul>
<li>校验：校验 sql 语句的语法</li>
<li>编译：将 sql 语句编译成一个与函数类似的东西</li>
<li>执行：调用函数</li>
</ul>
</li>
<li>PreparedStatement 预处理过程：<ul>
<li>每个 pstmt 都与一个 sql 模板绑定，第一次调用时，先把 sql 模板给数据库，数据库先进行校验，再进行编译，执行时只是把参数传递过去。</li>
<li>以后执行时，就不用再进行校验和编译。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>PS：使用 properties 集合类加载配置文件的方式：</strong></p>
<p>1、创建 Properties 集合类</p>
<p><code>Properties pro = new Properties();</code></p>
<p>2、加载配置文件</p>
<p><code>pro.load(类名.class.getClassLoader().getResourceAsStream(&quot;配置文件名&quot;));</code></p>
<p>3、获取配置文件中的数据</p>
<p><code>pro.getProperty(&quot;key&quot;);</code></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL</title>
    <url>/2019/04/16/Java/SQL/</url>
    <content><![CDATA[<p>SQL 是关系型数据库的通用语言标准</p>
<a id="more"></a>



<p><strong>SQL</strong>（Structured Query language）：结构化查询语句</p>
<p><strong>使用：</strong></p>
<ul>
<li><p>客户端使用 SQL 来操作数据库，</p>
</li>
<li><p>后期会使用 Java 程序连接服务器，然后使用 SQL 操作数据库</p>
</li>
</ul>
<p><strong>SQL 基础语法：</strong></p>
<ul>
<li>SQL 语句可以在单行或多行进行书写，以分号结尾</li>
<li>可使用空格和缩进来增强语句的可读性</li>
<li>MySQL 中不区分 SQL 语句的大小写，关键字建议使用<strong>大写</strong></li>
</ul>
<p><strong>SQL语句分类：</strong></p>
<ul>
<li>DDL(Data Difinition Language)：数据库定义语言，对数据库或<strong>表的结构</strong>进行操作</li>
<li>DML(Data Manipulation Language)：数据库操作语言，对表进行<strong>增删改</strong></li>
<li>DQL(Data Query language)：数据库查询语言，对表进行<strong>查询</strong></li>
<li>DCL(Data Control Language)：数据库控制语言，创建用户及<strong>授权</strong></li>
</ul>
<h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><p><strong>数据库相关操作：</strong></p>
<ul>
<li>查看所有数据库：<code>SHOW DATABASES;</code></li>
<li>切换（选择要操作的）数据库：<code>USE 数据库名;</code></li>
<li>新建数据库：<code>CREATE DATABASE [IF NOT EXISTS] 数据库名 [CHATSET=UTF8];</code></li>
<li>删除数据库：<code>DROP DATABASE [IF EXISTS] 数据库名;</code></li>
<li>修改数据库编码：<code>ALTER DATABASE 数据库名 CHARACTER SET UTF8;</code></li>
</ul>
<p><strong>表相关操作：</strong></p>
<ul>
<li><p>创建表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 (</span><br><span class="line">列名 列类型,</span><br><span class="line">列名 列类型,</span><br><span class="line">....</span><br><span class="line">列名 列类型</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看数据库中所有的表：<code>SHOW TABLES;</code></p>
</li>
<li><p>查看表的结构：<code>DESC 表名;</code></p>
</li>
<li><p>删除表：<code>DROP TABLE 表名;</code></p>
</li>
<li><p>修改表：<strong>前缀：ALTER TABLE 表名</strong></p>
<ul>
<li>添加列：<code>ADD(列名 列类型,列名 列类型, ... 列名 列类型);</code></li>
<li>修改列类型：<code>MODIFY 列名 列类型;</code></li>
<li>修改列名：<code>CHANGE 原列名 新列名 新列类型;</code></li>
<li>删除列：<code>DROP COLUMN 列名;</code></li>
<li>修改表名：<code>RENAME TO 新表名;</code></li>
</ul>
</li>
</ul>
<h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><ol>
<li><p><strong>插入数据（增）</strong></p>
<p><code>INSERT INTO 表名 (列名1, 列名2, ... ) VALUES (值1, 值2, ...)</code></p>
</li>
<li><p><strong>修改数据（改）</strong></p>
<p><code>UPDATE 表名 SET 列名1 = 列值1,列名2 = 列值2, ...[WHERE 条件]</code></p>
<p>条件必须是一个Boolean类型，</p>
<p>运算符：=、!=、&gt;、&lt;、&gt;=、&lt;=、BETWEEN….AND、IN(…)、IS NULL、NOT、OR、AND</p>
</li>
<li><p><strong>删除数据（删）</strong></p>
<p><code>DELECT FROM 表名 [WHERE 条件]</code></p>
<p><em>不加 where就会把整个表都清空</em></p>
</li>
</ol>
<h3 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h3><p><strong>SELECT * FROM 表名：</strong>查询表记录</p>
<p><strong>1、基础查询：列控制</strong></p>
<ul>
<li><p><strong>查询所有列</strong></p>
<p><code>SELECT * FROM 表名;</code></p>
</li>
<li><p><strong>查询指定列</strong></p>
<p><code>SELECT 列名1 [,列名2...] FROM 表名;</code></p>
</li>
<li><p><strong>查询时去重</strong></p>
<p><code>SELECT DISTINCT  列名1 [,列名2...] FROM 表名;</code></p>
</li>
<li><p><strong>列运算</strong></p>
<ul>
<li><p><strong>数量</strong>类型的列可以做数字<strong>运算</strong></p>
<p><code>SELECT 列名*1.5 FROM 表名;</code></p>
</li>
<li><p><strong>字符串</strong>类型可以做<strong>连接</strong>运算</p>
<p><code>SELECT CONCAT(&#39;我是&#39;, 列名) FROM 表名;</code></p>
</li>
<li><p><strong>转换NULL</strong>值</p>
<p><code>SELECT IFNULL(列名, 0) FROM 表名;</code></p>
<p>如果列里面存在 NULL 就转换为 0</p>
</li>
<li><p>给列起<strong>别名</strong></p>
<p><code>SELECT 列名 AS 别名 FROM 表名;</code> （AS 可省略）</p>
</li>
</ul>
</li>
</ul>
<p><strong>2、条件查询</strong></p>
<p><code>SELECT * FROM 表名 WHERE 条件;</code></p>
<p>运算符：</p>
<ul>
<li><code>=、!=、&gt;、&lt;、&gt;=、&lt;=</code></li>
<li><code>BETWEEN...AND...</code></li>
<li><code>IN(...)</code></li>
<li><code>IS NULL</code></li>
<li><code>NOT、OR、AND</code></li>
</ul>
<p><strong>3、模糊查询</strong></p>
<p>关键字：<code>LIKE</code></p>
<p>符号：</p>
<ul>
<li><code>_</code> ：表示一个字符</li>
<li><code>%</code>：表示 0 ~ N 个字符</li>
</ul>
<p><code>SELECT * FROM 表名 WHERE 列名 LIKE &#39;张_&#39;;</code></p>
<p><code>SELECT * FROM 表名 WHERE 列名 LIKE &#39;%小%&#39;;</code></p>
<p><strong>4、排序</strong></p>
<p>关键字：</p>
<ul>
<li>ORDER BY</li>
<li>ASC：升序排列（默认）</li>
<li>DESC：降序排列</li>
</ul>
<p><code>SELECT * FROM 表名 ORDER BY 列名 关键字，列名 关键字，列名 关键字;</code></p>
<p><strong>5、聚合函数：将一列数据作为一个整体，进行纵向的计算</strong></p>
<ul>
<li><code>count()</code> –&gt; 计数<ul>
<li><code>count(*)</code> –&gt; 查询的表中记录总数</li>
<li><code>count(sal)</code> –&gt; sal 列非 null 记录数</li>
</ul>
</li>
<li><code>sum(sal)</code> –&gt; 求和</li>
<li><code>max(sal)</code> –&gt; 最大值</li>
<li><code>min(sal)</code> –&gt; 最小值</li>
<li><code>avg(sal)</code> –&gt; 平均值</li>
</ul>
<blockquote>
<p>聚合函数使用时，自动排除了 null 值</p>
</blockquote>
<p><strong>6、分组查询</strong></p>
<p><code>SELECT 列名，聚合函数  FROM 表名 WHERE 条件 GROUP BY 列名 HAVING 条件 ORDER BY 列名 关键字;</code></p>
<p><code>SELECT deptno,count(*) FROM emp WHERE  sal &gt;= 15000 GROUP BY deptno HAVING count(*)&gt;1;</code></p>
<blockquote>
<p>分组查询时 WHERE 和 HAVING 的区别：</p>
<ul>
<li>WHERE：在分组之前限定条件，如果不满足条件，则不参与分组； 后面不可以跟聚合函数</li>
<li>HAVING：在分组之后限定条件，如果不满足条件，则不会被查询出来； 后面可以跟聚合函数</li>
</ul>
</blockquote>
<blockquote>
<p>SQL 关键字书写顺序：</p>
<p>​    SELECT –&gt; FROM –&gt; WHERE –&gt; GROUP BY –&gt; HAVING –&gt; ORDER BY </p>
</blockquote>
<p><strong>7、limit子句 – 分页查询（MySQL 方言）</strong></p>
<p><code>SELECT * FROM 表名 LIMIT 3,5;</code></p>
<p>上面的表达式代表：</p>
<ul>
<li><p>从<em>标号为3的行</em>（<strong>第四行</strong>）开始查，共查询5行。</p>
</li>
<li><p>3为每页开始的索引，5为每页显示的条数</p>
</li>
</ul>
<p>LIMIT 适用于<strong>分页查询</strong></p>
<p><strong>查询公式:</strong></p>
<p>一页记录数：m</p>
<p>查询第 n 页</p>
<p>查询开始的索引 =（n-1）* m</p>
<p>SELECT * FROM 表名 LIMIT <strong>(n-1)*m,m</strong>;</p>
<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><blockquote>
<p>概念：对表中的数据进行限定，保证数据的正确性、有效性和完整性</p>
</blockquote>
<p>约束的分类：</p>
<ul>
<li>主键约束：primary key</li>
<li>非空约束：not null</li>
<li>唯一约束：unique</li>
<li>外键约束：foreign key</li>
</ul>
<ol>
<li><p><strong>主键约束（唯一标识）</strong></p>
<p><strong>三个特性：</strong></p>
<ul>
<li>非空</li>
<li>唯一</li>
<li>可被引用</li>
</ul>
<p><strong>指定方式：</strong></p>
<ul>
<li><p>创建表时指定主键</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tab_stu(</span><br><span class="line"><span class="keyword">id</span>  <span class="built_in">INT</span> **PRIMARY <span class="keyword">KEY</span>**,</span><br><span class="line"><span class="keyword">name</span>  <span class="built_in">VARCHAR</span>(<span class="number">30</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tab_stu(</span><br><span class="line"><span class="keyword">id</span>  <span class="built_in">INT</span>,</span><br><span class="line"><span class="keyword">name</span>  <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">**PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)**</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改表时指定主键 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tab_stu <span class="keyword">ADD</span> PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<p><strong>删除主键：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tab_stu <span class="keyword">DROP</span> PRIMARY <span class="keyword">KEY</span>;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li><p><strong>主键自增长</strong></p>
<p>关键字：AUTO_INCREMENT</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tab_stu(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	name VARCHAR(30)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>主键自增长在集群环境下会失效 </p>
</blockquote>
<ol start="3">
<li><p><strong>非空和唯一约束</strong></p>
<p>关键字：</p>
<ul>
<li>非空：NOT NULL</li>
<li>唯一：UNIQUE</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tab_stu(</span><br><span class="line">  id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  name VARCHAR(30) NOT NULL UNIQUE</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>非空和唯一可以组合使用</p>
</blockquote>
<ol start="4">
<li><strong>外键约束</strong><ul>
<li>外键必须是另一表的主键的值</li>
<li>外键可以重复</li>
<li>外键可以为空</li>
<li>一张表中可以有多个外键</li>
</ul>
</li>
</ol>
<p>外键的作用：让表和表之间产生关系，从而保证数据的正确性。</p>
<blockquote>
<p>概念模型：?</p>
<p>对象模型：可以双向关联，而且引用的是对象，而不是一个主键。</p>
<p>关系模型：只能多方（从表）引用一方（主表），而且引用的只是主键，而不是一行记录。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*创建表时添加外键*&#x2F;</span><br><span class="line">CREATE TABLE dept(</span><br><span class="line">  deptno INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  dname VARCHAR(50)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">CREATE TABLE emp(</span><br><span class="line">  empno INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  ename VARCHAR(50),</span><br><span class="line">  deptno INT, &#x2F;*一对多的关系*&#x2F;</span><br><span class="line">  CONSTRAINT fk_emp_dept FOREIGN KEY(deptno) REFERENCES dept(deptno)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;*修改表时添加外键*&#x2F;</span><br><span class="line">ALTER TABLE emp</span><br><span class="line">ADD CONSTRAINT fk_emp_dept FOREIGN KEY(deptno) REFERENCES dept(deptno)</span><br><span class="line"></span><br><span class="line">&#x2F;*删除外键*&#x2F;</span><br><span class="line">ALTER TABLE emp DROP FOREIGN KEY fk_emp_dept</span><br><span class="line"></span><br><span class="line">&#x2F;*一对一的关系*&#x2F;</span><br><span class="line">CREATE TABLE hasband(</span><br><span class="line">  hid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  hname VARCHAR(50)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE wife(</span><br><span class="line">  wid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  wname VARCHAR(50),</span><br><span class="line">  CONSTRAINT fk_wife_hasband FOREIGN KEY(wid) REFERENCES hasband(hid)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&#x2F;*多对多的关系*&#x2F;</span><br><span class="line">CREATE TABLE student(</span><br><span class="line">  sid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  sname VARCHAR(50)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE teacher(</span><br><span class="line">  tid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  tname VARCHAR(50)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE stu_tea(</span><br><span class="line">  sid INT,</span><br><span class="line">  tid INT,</span><br><span class="line">  CONSTRAINT fk_stu FOREIGN KEY(sid) REFERENCES student(sid),</span><br><span class="line">  CONSTRAINT fk_tea FOREIGN KEY(tid) REFERENCES teacher(tid)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<p>外键约束_级联操作：</p>
<ul>
<li>级联更新：ON UPDATE CASCADE</li>
<li>级联删除：ON DELETE CASCADE</li>
</ul>
<blockquote>
<p>级联操作可以使通过外键链接的字段在一个字段更新时相关字段自动更新，有其方便之处，但也有危险，尤其是级联删除</p>
</blockquote>
<h3 id="多表操作"><a href="#多表操作" class="headerlink" title="多表操作"></a>多表操作</h3><p><strong>多表之间的关系：</strong></p>
<ul>
<li>一对一：了解即可，在程序开发中很少会有一对一的关系</li>
<li>一对多（多对一）：用的最多</li>
<li>多对多</li>
</ul>
<p><strong>实现多表之间的关系：</strong></p>
<ul>
<li><p>一对多：在多的一方建立外键，指向一的一方的主键。</p>
</li>
<li><p>多对多： 需要借助第三张中间表，中间表至少包含两个字段，这两个字段作为中间表的两个外键外键，分别指向两张表的主键。</p>
</li>
<li><p>一对一：可以在任意一方添加<strong>唯一</strong>外键指向另一方的主键</p>
</li>
</ul>
<p><strong>多表查询：</strong></p>
<ul>
<li><p>合并结果集</p>
<p>要求被合并的结果集中，列的类型和列数完全相同。</p>
<p>UNION：去除重复行</p>
<p>UNION ALL：不去除重复行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM 表一；</span><br><span class="line">UNION ALL;</span><br><span class="line">SELECT * FROM 表二；</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>内连接 &amp; 外连接</p>
<ul>
<li><p>内连接</p>
<ul>
<li><p>隐式内连接：MySQL 方言写法</p>
<p><code>SELECT 字段 FROM 表名1,表名2 WHERE 条件</code></p>
</li>
<li><p>显式内连接：SQL 标准写法</p>
<p><code>SELECT 字段 FROM 表名1 [INNER] JOIN 表名2 ON 条件</code></p>
</li>
</ul>
</li>
<li><p>外连接</p>
<ul>
<li><p>左外连接：将左表所有行都显示，不符合条件的右表使用 NULL</p>
<p><code>SELECT 字段 FROM 表名1 LEFT [OUTER] JOIN 表名2 ON 条件</code></p>
</li>
<li><p>右外连接：将右表所有行都显示，不符合条件的左表使用NULL</p>
<p><code>SELECT 字段 FROM 表名1 RIGHT [OUTER] JOIN 表名2 ON 条件</code></p>
</li>
<li><p>全外连接（MySQL不支持）</p>
<p>使用<code>UNION</code>连接左外和右外，在 MySQL 中实现全外连接</p>
</li>
</ul>
</li>
<li><p>自然连接</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>七种 join</p>
<p><img src="/images/SQL/%E4%B8%83%E7%A7%8Djoin.png" alt="七种join"></p>
<p>最下面的两种使用到了 全外连接，但是 MySQL 不支持全外连接，可以使用下面 SQL 实现同样的效果</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 实现查询 A B 表的全部</span></span><br><span class="line"><span class="comment">-- 等同于：SELECT * FROM TableA A FULL OUTER JOIN TableB B ON A.key = B.key</span></span><br><span class="line"><span class="comment">-- UNION 自带去重功能</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> TableA A <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> TableB B <span class="keyword">ON</span> A.key = B.key</span><br><span class="line"><span class="keyword">UNION</span> </span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> TableA A <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> TableB B <span class="keyword">ON</span> A.key = B.key</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 实现查询 A B 表单独的部分</span></span><br><span class="line"><span class="comment">-- 等同于：SELECT * FROM TableA A FULL OUTER JOIN TableB B ON A.key = B.key WHERE A.key IS NULL OR B.key IS NULL</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> TableA A <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> TableB B <span class="keyword">ON</span> A.key = B.key <span class="keyword">WHERE</span> B.key <span class="keyword">IS</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> TableA A <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> TableB B <span class="keyword">ON</span> A.key = B.key <span class="keyword">WHERE</span> A.key <span class="keyword">IS</span> <span class="literal">NULL</span></span><br></pre></td></tr></table></figure>


</blockquote>
<ul>
<li><p>子查询</p>
<p><strong>概念：</strong>查询中有查询（查询中有多个 SELECT 关键字）</p>
<p><strong>出现的位置：</strong></p>
<ul>
<li>FROM 后作为表存在（多行多列）</li>
<li>WHERE 后作为条件存在（单行单列、多行单列、单行多列）</li>
</ul>
<p><strong>子查询的三种情况：</strong></p>
<ul>
<li>子查询的结果是<strong>单行单列</strong>的：子查询可以作为条件，使用运算符（&gt;,&lt;…）做判断</li>
<li>子查询的结果是<strong>多行单列</strong>的：子查询可以作为条件，使用运算符（in）做判断</li>
<li>子查询的结果是<strong>多行多列</strong>的：子查询可以作为一张虚拟表参与查询</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基础</title>
    <url>/2019/04/16/Java/MySQL%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>MySQL 数据库是最受欢迎的关系型数据库</p>
<a id="more"></a>

<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p><strong>DB</strong>（<strong>D</strong>ata<strong>B</strong>ase）：数据库</p>
<ul>
<li>通过一个个的表(table)来保存数据</li>
</ul>
<p><strong>DBMS</strong>（<strong>D</strong>ata<strong>B</strong>ase <strong>M</strong>anagement <strong>S</strong>ystem）：数据库管理系统</p>
<ul>
<li>用来管理数据库（一个 DBMS 下可以由多个 DB）</li>
</ul>
<blockquote>
<p>通常我们所说的数据库包含了<strong>数据库</strong>和<strong>数据库管理系统</strong></p>
</blockquote>
<p><strong>RDBMS</strong>：关系型数据库管理系统 = 管理员（manager）+仓库（database）</p>
<p><strong>database：</strong>N 个 table</p>
<p><strong>table：</strong></p>
<ul>
<li>表结构：定义表的列名和列类型</li>
<li>表记录：一行一行的记录</li>
</ul>
<h2 id="MySQL-数据库"><a href="#MySQL-数据库" class="headerlink" title="MySQL 数据库"></a>MySQL 数据库</h2><p><strong>简介:</strong></p>
<p>​    MySQL 是一个数据库管理系统，现在属于 Oracle 公司，版本号5.5及以下不收费，以上收费。</p>
<p><strong>安装 MySQL：</strong></p>
<blockquote>
<p>安装方式:命令行安装的方式</p>
</blockquote>
<ol>
<li><p>把下载的压缩包解压到一个文件夹(<code>D:\develop\MySQL</code>)里面, 此时文件夹中没有<code>data目录</code>和<code>ini文件</code></p>
</li>
<li><p>在MySQL目录下新建 <code>my.ini</code> 文件, 并复制以下内容</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#设置3306端</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">port</span> = <span class="number">3306</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 设置mysql的安装目录</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">basedir</span>=D:\develop\MySQL</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 设置mysql数据库的数据的存放目录</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">datadir</span>=D:\develop\MySQL\data</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 允许最大连接数</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">max_connections</span>=<span class="number">200</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 服务端使用的字符集默认为8比特编码的latin1字符集</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">character-set-server</span>=utf8</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建新表时将使用的默认存储引擎</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">default-storage-engine</span>=INNODB</span><br><span class="line"> </span><br><span class="line"><span class="attr">sql_mode</span>=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</span><br><span class="line"> </span><br><span class="line"><span class="section">[mysql]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 设置mysql客户端默认字符集</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">default-character-set</span>=utf8</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置MySQL的环境变量</p>
<ul>
<li>在系统变量中新建:<ul>
<li>变量名: <code>MySQL_HOME</code> </li>
<li>变量值: <code>D:\develop\MySQL</code></li>
</ul>
</li>
<li>在系统变量 –&gt; Path 中新建: <code>D:\develop\MySQL\bin</code></li>
</ul>
</li>
<li><p>以管理员身份打开cmd</p>
<ol>
<li>cd 到 <code>D:\develop\MySQL\bin</code></li>
<li>运行 <code>mysqld --install</code> , 提示 <code>Services successfully installed</code> 说明安装成功, 如果提示已存在, 先运行 <code>mysqld --remove</code>, 再运行 <code>mysqld --install</code></li>
<li>运行 <code>mysqld --initialize</code>, 生成 <code>data</code> 目录</li>
<li>运行 <code>net start mysql</code> 启动服务</li>
</ol>
</li>
<li><p>修改MySQL密码</p>
<ol>
<li>运行 <code>net stop mysql</code> 停止服务</li>
<li>运行 <code>mysqld --skip-grant-tables</code> 开启无密码的mysql</li>
<li>以管理员身份打开另一个cmd窗口, 运行 <code>mysql -u root -p</code> 回车, 不用输入密码, 直接回车</li>
<li>运行 <code>update mysql.user set authentication_string=password(&quot;root&quot;) where user=&quot;root&quot;;</code> 更新root账户的密码为root</li>
<li>运行 <code>flush privileges;</code> 执行刷新权限</li>
<li>运行 <code>quit;</code> 结束本次操作</li>
</ol>
</li>
<li><p>在密码的情况下修改密码</p>
<ol>
<li>运行 <code>mysql -u root -p</code>, 输入密码 root, 进入mysql操作界面</li>
<li>依次运行下面命令, 就把密码更新成了 123456<ol>
<li><code>SET PASSWORD = PASSWORD(&#39;123456&#39;);</code></li>
<li><code>ALTER USER &#39;root&#39;@&#39;localhost&#39; PASSWORD EXPIRE NEVER;</code></li>
<li><code>flush privileges;</code></li>
</ol>
</li>
<li>运行 <code>quit;</code> 退出, 大功告成!</li>
</ol>
</li>
</ol>
<blockquote>
<p><strong>安装过程中遇到的问题及解决方案:</strong></p>
<p>运行 <code>mysqld --install</code> 时弹窗提示</p>
<ul>
<li>“无法启动此程序，因为计算机丢失<code>MSVCP120.dll</code>“;  </li>
<li>“无法启动此程序，因为计算机丢失<code>MSVCR120.dll</code>“;</li>
</ul>
<p>解决方案:</p>
<ul>
<li>这种错误是由于未安装<code>vcredist</code>引起的（而且版本是 2013版，32位/64位）；</li>
<li>从微软官网下载 <code>vcredist 2013</code>: <a href="https://www.microsoft.com/zh-CN/download/details.aspx?id=40784" target="_blank" rel="noopener">https://www.microsoft.com/zh-CN/download/details.aspx?id=40784</a></li>
<li>根据电脑选择 32 or 64 位进行安装</li>
<li>然后重新运行<code>mysqld --install</code>，成功解决.</li>
</ul>
</blockquote>
<p><strong>启动 MySQL 服务：</strong></p>
<ol>
<li>我的电脑(右键) –&gt; 管理 –&gt; 服务和应用程序 –&gt; 服务 –&gt; MySQL（右键启动）</li>
<li>cmd –&gt; services.msc –&gt; 服务和应用程序 –&gt; 服务 –&gt; MySQL（右键启动）</li>
<li>cmd(<strong>以管理员模式打开</strong>) –&gt; <code>net start mysql</code> 【关闭服务：<code>net stop mysql</code>】</li>
<li></li>
</ol>
<p><strong>登录MySQL服务器：</strong></p>
<ul>
<li>（本地）cmd  –&gt; <u>mysql -uroot -proot</u></li>
<li>（网络）cmd  –&gt; <u>mysql -uroot -proot <strong>-h192.168.137.4</strong> <strong>-P3306</strong></u></li>
</ul>
<p><strong>在cmd窗口退出mysql：</strong></p>
<ul>
<li><p>exit</p>
</li>
<li><p>quit</p>
</li>
</ul>
<p>数据库的备份与还原：</p>
<ul>
<li>备份：<ul>
<li>命令行形式：<code>mysqldump  -u用户名  -p密码  数据库名 &gt; 保存路径</code></li>
</ul>
</li>
<li>还原：<ul>
<li>登录数据库 –&gt; 创建数据库 –&gt; 使用数据库 –&gt; 执行文件：<code>source 文件路径</code></li>
</ul>
</li>
</ul>
<h3 id="MySQL-的数据类型"><a href="#MySQL-的数据类型" class="headerlink" title="MySQL 的数据类型"></a>MySQL 的数据类型</h3><p>MySQL有以下几种数据类型：</p>
<ul>
<li>int：整型</li>
<li>double：浮点型；例如 double(5,2) 表示数字最长5位，且必须有2位小数，最大值999.99</li>
<li>decimal：浮点型；在表示钱的时候用该类型，不会出现精度缺失的问题</li>
<li>char：固定长度字符串类型；char(255) 数据长度不足指定长度时会自动补足</li>
<li>varchar：可变长度字符串类型；varchar(65535)</li>
<li>text(clob)：字符串类型，text为MySQL的方言，clob为SQL语句的标准语法<ul>
<li>很小 –&gt; tinytext</li>
<li>小 –&gt; text</li>
<li>中 –&gt; mediumtext</li>
<li>大 –&gt; longtext</li>
</ul>
</li>
<li>blob：字节类型<ul>
<li>很小 –&gt; tinyblob</li>
<li>小 –&gt; blob</li>
<li>中 –&gt; mediumblob</li>
<li>大 –&gt; longblob</li>
</ul>
</li>
<li>date：日期类型；YYYY-MM-DD</li>
<li>time：时间类型；hh:mm:ss</li>
<li>timestamp：时间戳类型；既有日期，又有时间</li>
</ul>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p><strong>概念：</strong>如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败</p>
<p><strong>操作：</strong></p>
<ul>
<li>开启事务：<code>start transaction;</code></li>
<li>回滚事务：<code>rollback;</code></li>
<li>提交事务：<code>commit;</code></li>
</ul>
<p><strong>事务的提交方式：</strong></p>
<ul>
<li>自动提交：<ul>
<li>执行一次 DML 语句就会自动提交一次事务</li>
<li>MySQL 数据库中的事务是默认自动提交的</li>
</ul>
</li>
<li>手动提交：<ul>
<li>需要先开启事务，再 commit 手动提交事务</li>
<li>Oracle 数据库中的事务是默认手动提交的</li>
</ul>
</li>
<li>修改事务的提交方式：<ul>
<li>查询事务的默认提交方式：<code>select @@autocommit;</code><ul>
<li>0 –&gt; 手动提交 </li>
<li>1 –&gt; 自动提交</li>
</ul>
</li>
<li>修改事务的默认提交方式：<code>select @@autocommit = 0;</code></li>
</ul>
</li>
</ul>
<p><strong>☆事务的四大特征☆</strong></p>
<ul>
<li>原子性（<strong>A</strong>tomicity）：事务是不可分割的最小操作单位，要么同时成功，要么同时失败。</li>
<li>一致性（<strong>C</strong>onsistency）：事务操作前后，数据库的完整性没有被破坏。</li>
<li>隔离性（<strong>I</strong>solation）：多个事务之间相互独立。</li>
<li>持久性（<strong>D</strong>urability）：事务操作后，数据库会持久化的保存数据，即使是故障也会保存。</li>
</ul>
<p><strong>并发操作可能出现的问题</strong>：</p>
<ol start="0">
<li><p><strong>更新丢失</strong>：两个事务更新同一个数据，一个事务对数据的更新把另一个事务对数据的更新覆盖了。</p>
</li>
<li><p><strong>脏读</strong>：一个事务读取到另一个事务未提交的数据。</p>
</li>
<li><p><strong>不可重复读</strong>：一个事务中两次读取同一个数据得到不一样的结果。</p>
</li>
<li><p><strong>幻读</strong>：一个事务中执行了两次查询，第二次查询结果相比较第一次查询结果多了/少了数据。</p>
</li>
</ol>
<p><strong>☆事务的隔离级别☆</strong></p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">读未提交（Read Uncommitted）</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">读已提交（Read Committed）</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">可重复读（Repeatable Read）</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">串行化（Serializable）</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<p>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。</p>
<p>四种隔离级别都不会出现更新丢失。</p>
<p>MySQL 默认的隔离级别为<strong>可重复读（Repeatable Read）</strong></p>
<h3 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h3><p>数据库范式：设计关系型数据库时，需要遵循的规范要求</p>
<blockquote>
<p>目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）</p>
</blockquote>
<p>一般只要遵循前三个范式即可</p>
<ul>
<li>第一范式：数据库表的每一列都是不可分割的原子数据项</li>
<li>第二范式：在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）</li>
<li>第三范式：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）</li>
</ul>
<p>对三大范式的简单理解：</p>
<ul>
<li>第一范式：每一列都要不可分割，也就是一个字段只存储一项信息</li>
<li>第二范式：在存在多个主键（联合主键）的情况下才会发生不符合第二范式的情况，比如存在两个主键，如果有一个属性只依赖于一个主键而不依赖于另一个，这就是不符合第二范式</li>
<li>第三范式：一张表中所有的非主键属性只能依赖主键属性</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat服务器</title>
    <url>/2019/04/15/Java/2.JavaWeb/7.Tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>Tomcat 服务器是一款免费、开源的轻量级 Web 应用服务器</p>
<a id="more"></a>

<h2 id="Tomcat-服务器"><a href="#Tomcat-服务器" class="headerlink" title="Tomcat 服务器"></a>Tomcat 服务器</h2><p><strong>什么是服务器？</strong></p>
<p>​    服务器其实就是一个代码编写的可以根据用户请求实时的调用执行对应逻辑代码的一个容器。</p>
<p><strong>Tomcat 服务器各文件夹作用：</strong></p>
<ul>
<li>\bin –&gt; 存放 Tomcat 的可执行文件</li>
<li>\conf –&gt; 存 Tomcat 的配置文件</li>
<li>\lib –&gt; 存放 Tomcat 运行依赖的 jar 包</li>
<li>\logs  –&gt; 存放日志文件</li>
<li>\temp –&gt; 存放临时文件</li>
<li>\webapps –&gt; 存放 web 应用</li>
<li>work –&gt; 存放 JSP 转换后的 Servlet 文件</li>
</ul>
<blockquote>
<p>双击 startup.bat 启动 Tomcat 服务器时黑窗口一闪而过：</p>
<ul>
<li>原因：JAVA_HOME 环境变量配置的问题</li>
<li>解决：正确配置 JAVA_HOME 环境变量</li>
</ul>
</blockquote>
<blockquote>
<p> Tomcat 默认端口号为 8080，可在 <code>conf/server.xml</code> 配置文件中修改端口</p>
<p>后期常用的端口号为 80，因为这是 HTTP 协议的默认端口号，访问时 ip 后面可以不输端口号</p>
</blockquote>
<p><strong>在 Tomcat 服务器上部署项目的方式：</strong></p>
<ol>
<li><p>直接将项目放到<code>webapps</code>目录下</p>
<ul>
<li>直接将项目文件夹放到 <code>webapps</code> 目录下（/项目文件夹名：项目的访问路径 &lt; 虚拟目录&gt;）</li>
<li>将项目打成 <code>war</code> 包，放到 <code>webapps</code> 目录下，此时 war 包会自动解压缩</li>
</ul>
</li>
<li><p>配置 <code>conf/server.xml</code> 文件</p>
<p>在 <code>&lt;host&gt;</code> 标签中配置：<code>&lt;Context docBase = &quot;项目路径&quot; path = &quot;虚拟目录&quot;/&gt;</code></p>
</li>
<li><p>在<code>conf/Catalina/localhost</code> 目录下创建任意名称的xml文件</p>
<p>在文件中编写：<code>&lt;Context docBase=&quot;项目路径&quot;/&gt;</code></p>
<p>此时<u>虚拟目录为xml文件的名称</u></p>
</li>
</ol>
<p><strong>webapps 中 java 动态项目的目录结构：</strong></p>
<ul>
<li>项目根目录<ul>
<li>WEB-INF 目录<ul>
<li>web.xml：web 项目的核心配置文件</li>
<li>classes 目录：放置字节码文件</li>
<li>lib 目录：放置依赖的 jar 包</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Tomcat 线程池概述：</strong></p>
<p>Tomcat 自带线程池机制，线程都是由线程池进行管理。</p>
<h2 id="web-开发中的常见问题"><a href="#web-开发中的常见问题" class="headerlink" title="web 开发中的常见问题"></a>web 开发中的常见问题</h2><h3 id="服务器启动报错，如何进行错误排查"><a href="#服务器启动报错，如何进行错误排查" class="headerlink" title="服务器启动报错，如何进行错误排查"></a>服务器启动报错，如何进行错误排查</h3><p><strong>两种情况：</strong></p>
<ul>
<li>服务器中没有项目，服务器启动时报错，二话不说，删掉原来的服务器，重新解压一份新的。</li>
<li>服务器中有项目，服务器启动报错，则一定是项目中 web.xml 中的配置出现了错误<ul>
<li>url-pattern 前面没有加 / </li>
<li>servlet-name 没有匹配项</li>
</ul>
</li>
<li>servlet-class 配置错误，不会影响服务器的启动，但是在访问的时候会报 500 错误</li>
</ul>
<h3 id="修改哪些文件，需要重新启动服务器"><a href="#修改哪些文件，需要重新启动服务器" class="headerlink" title="修改哪些文件，需要重新启动服务器"></a>修改哪些文件，需要重新启动服务器</h3><p><strong>不需要</strong>重新启动的两种情况：</p>
<ul>
<li>修改了前端资源，不需要重新启动服务器</li>
<li>修改 servlet，不用重新启动服务器，但是需要等待 Java 文件重新编译成 .class 文件后，才能访问到新的内容</li>
</ul>
<p><strong>需要</strong>重新启动的情况：</p>
<ul>
<li>修改了 web.xml 文件，必须重新启动服务器</li>
</ul>
<blockquote>
<p>在未来的工作中，会大量的在服务器中部署或移除项目，在部署和移除之前，必须关闭服务器</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Tomcat 服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2019/04/15/Java/1.Java%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>深入理解设计模式能够帮助自己更好的体会编程的思想</p>
<a id="more"></a>



<p><strong>设计模式</strong>（Design Pattern）是一套被反复使用、多人知晓的经过分类的代码设计经验的总结</p>
<p>使用设计模式的目的：为了代码的可重用性、可维护性</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式，是最常用的一种软件设计模式，在它的核心结构中只包含一个被称为单例的特殊类，通过过单例模式可以保证系统中：应用该模式的一个类只有一个实例。</p>
<p><strong>单例由两种实现形式：</strong></p>
<ul>
<li>饿汉式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接创建好对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义私有的构造方法</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Person p = <span class="keyword">new</span> Person();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Person <span class="title">getPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>懒汉式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等待有需求时创建对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义私有的构造方法</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Person p = <span class="keyword">null</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Person <span class="title">getPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span>)&#123;</span><br><span class="line">            p = <span class="keyword">new</span> Person();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>在实际开发中一般用的都时饿汉式，因为懒汉式存在<strong>线程安全</strong>的问题</p>
</blockquote>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>作用：实现了<strong>创建者</strong>和<strong>调用者</strong>的分离</p>
<p>分类：</p>
<ul>
<li><p>简单工厂模式</p>
<p>虽然某种程度不符合设计原则，但实际使用最多</p>
</li>
<li><p>工厂方法模式</p>
<p>不修改已有类的前提下，通过增加新的工厂实现拓展</p>
</li>
<li><p>抽象工厂模式</p>
<p>不可以增加产品，可以增加产品族</p>
</li>
</ul>
<p>核心本质：</p>
<ul>
<li>实例化对象，用工厂方法代替 new 进行操作</li>
<li>将选择实现类、创建对象统一管理和控制，从而将调用者与实现类解耦</li>
</ul>
<blockquote>
<p>面向对象设计的基本原则：</p>
<ul>
<li>OCP（开闭原则，Open-closed Principle）：一个软件的实体应当对扩展开放，对修改关闭</li>
<li>DIP（依赖倒转原则，Dependence Inversion Principle）：要针对接口编程，不要针对实现编程</li>
<li>LoD（迪米特法则，Law of Demeter）：只与直接朋友通信，而避免和陌生人通信</li>
</ul>
</blockquote>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet</title>
    <url>/2019/04/14/Java/2.JavaWeb/8.Servlet/</url>
    <content><![CDATA[<p>Servlet = Server Applet –&gt; 服务器上的小程序</p>
<a id="more"></a>

<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><blockquote>
<p><strong>Servlet：</strong>是指任何实现了 Servlet 接口的类<br><strong>作用：</strong>接收并处理浏览器发出的请求</p>
</blockquote>
<h3 id="Servlet-基础及其生命周期"><a href="#Servlet-基础及其生命周期" class="headerlink" title="Servlet 基础及其生命周期"></a>Servlet 基础及其生命周期</h3><p><strong>自定义一个 Servlet：</strong></p>
<ol>
<li><p>创建普通的 Java 类，并实现 Servlet 接口</p>
</li>
<li><p>实现接口中的抽象方法</p>
<ol>
<li><strong>init</strong> –&gt; 初始化方法</li>
<li><strong>service</strong> –&gt; 判断请求方式，并分配请求</li>
<li><strong>destroy</strong> –&gt; 销毁方法</li>
<li>getServletConfig</li>
<li>getServletInfo</li>
</ol>
</li>
<li><p>在 web.xml 文件中配置 Servlet</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>myservlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>cn.hellopika.servlet.MyServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>myservlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/myservleturl<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<blockquote>
<p>Servlet 也可以使用注解配置（Servlet 3.0 之后才有）：</p>
<p>在类上添加注解：<code>@WebServlet(&quot;url-pattern&quot;)</code></p>
</blockquote>
<blockquote>
<p>JavaWeb 项目中 <strong>src 目录下</strong>的文件部署到服务器后会被放在<strong>WEB-INF 下的 classes 目录下</strong></p>
</blockquote>
<p><strong>Servlet继承结构：</strong></p>
<p>​    <code>Servlet(接口)</code> –实现–&gt; <code>GenericServlet</code> –继承–&gt; <code>HttpServlet</code> –继承–&gt;<code>MyServlet(自己写的)</code></p>
<blockquote>
<p>一般情况下我们自己的 Servlet 不会直接实现 Servlet 接口，而是继承 HttpServlet 类，然后重写 <code>doGet()</code> 和 <code>doPost()</code> 方法，从而可以处理 get 和 post 请求。</p>
</blockquote>
<p><strong>Servlet的生命周期（以及 load-on-startup 的用法）：</strong></p>
<p>Servlet 的生命周期是指 Servle t对象从创建到销毁的全过程</p>
<ol>
<li>启动服务器，没有创建 Servlet 对象</li>
<li>当浏览器发出请求，用到了指定的 Servlet 来处理请求的时候，Servlet 对象创建</li>
<li>Servlet 对象创建后，立刻调用 <strong>init</strong> 方法执行初始化操作</li>
<li>Servlet 对象创建后，始终以<strong>单例</strong>的形式存储在服务器上</li>
<li>Servlet 以 doGet 和 doPost 方法来处理浏览器发出的请求</li>
<li>关闭服务器，Servlet 对象销毁</li>
<li>如果是正常关闭服务器，在 Servlet 对象销毁前会调用 <strong>destory</strong> 方法执行最后的处理工作</li>
</ol>
<blockquote>
<p>加入 load-on-startup ，可以更改 Servlet 对象的创建时机，在服务器启动期间创建对象</p>
<p>load-on-startup 标签放在 servlet-class 标签下面，其中的数字越小，越优先创建</p>
</blockquote>
<h3 id="Servlet-处理-HTTP-请求"><a href="#Servlet-处理-HTTP-请求" class="headerlink" title="Servlet 处理 HTTP 请求"></a>Servlet 处理 HTTP 请求</h3><blockquote>
<p>在继承了<code>HttpServlet</code> 之后, 自己的 Servlet 便可以处理 get 和 post 请求</p>
</blockquote>
<p>处理 get 请求: <code>doGet()</code>方法</p>
<blockquote>
<p>下列请求为 get 请求：</p>
<ul>
<li>直接在浏览器地址栏输入 url</li>
<li>点击超链接（HTML 的 a标签）</li>
<li>提交表单，如果不设置 form 标签中 method 属性的值，默认为 get 提交</li>
</ul>
</blockquote>
<p>处理 post 请求: <code>dopost()</code>方法 </p>
<blockquote>
<p>下列请求为 post 请求：</p>
<ul>
<li>提交表单，设置 form 标签中 method 属性的值为 post</li>
</ul>
</blockquote>
<h3 id="对于-Servlet-代码结构的处理"><a href="#对于-Servlet-代码结构的处理" class="headerlink" title="对于 Servlet 代码结构的处理"></a>对于 Servlet 代码结构的处理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"调用了doGet方法"</span>);</span><br><span class="line">    <span class="comment">// 参数的接收</span></span><br><span class="line">    String str1 = request.getParameter(<span class="string">"str1"</span>);</span><br><span class="line">    String str2 = request.getParameter(<span class="string">"str2"</span>);</span><br><span class="line">    System.out.println(str1);</span><br><span class="line">    System.out.println(str2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 在doPost中直接调用doGet</span></span><br><span class="line">    <span class="keyword">this</span>.doGet(request,response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="url-pattern"><a href="#url-pattern" class="headerlink" title="url-pattern"></a>url-pattern</h3><blockquote>
<p>在 <code>web.xml</code> 中配置 <code>&lt;servlet-mapping&gt;</code> 时, 需要注意 <code>url-pattern</code> 的配置</p>
</blockquote>
<ol>
<li><p>url-pattern 的<strong>配置方式</strong></p>
<ul>
<li>精确路径匹配 –&gt; <code>/abc/MyServlet</code></li>
<li>部分路径匹配 –&gt; <code>/abc/*</code></li>
<li>通配符匹配 –&gt; <code>/*</code></li>
<li>后缀名匹配 –&gt; <code>*.do</code></li>
</ul>
</li>
<li><p>url-pattern 的<strong>优先级</strong></p>
<p>精确路径匹配 &gt; 部分路径匹配 &gt; 通配符匹配 &gt; 后缀名匹配</p>
</li>
</ol>
<h3 id="ServletContext-对象（上下文对象）"><a href="#ServletContext-对象（上下文对象）" class="headerlink" title="ServletContext 对象（上下文对象）"></a>ServletContext 对象（上下文对象）</h3><p><strong>概念：</strong>代表整个 web 应用，可以和服务器通信</p>
<p><strong>生命周期：</strong></p>
<ul>
<li>创建：服务器启动，创建<strong>单例</strong> ServletContext 对象，</li>
<li>销毁：服务器关闭，ServletContext 对象销毁</li>
</ul>
<p><strong>获取 ServletContext 对象</strong>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 HttpServlet 获取 （实际开发中常用）</span></span><br><span class="line">ServletContext application = <span class="keyword">this</span>.getServletContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 request 对象来获取</span></span><br><span class="line">ServletContext application = request.getServletContext();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：ServletContext 对象的变量名必须叫 <strong>application</strong></p>
</blockquote>
<p><strong>功能：</strong></p>
<ul>
<li>使用 ServletContext 域对象存取值（在 web 应用的所有 Servlet 中共享数据）</li>
</ul>
<ol>
<li>上下文域对象<ul>
<li>上下文域对象的取值范围最为广泛（web 应用）</li>
<li>上下文域对象中的值在服务器关闭时才会被销毁</li>
</ul>
</li>
<li>域对象的常用方法<ul>
<li>存值：<code>application.setAttribute(String key, Object value)</code></li>
<li>取值：<code>application.getAttribute(String key)</code> </li>
<li>移除值：<code>application.removeAttribute(String key)</code>   <em>不常用</em></li>
</ul>
</li>
</ol>
<ul>
<li><p>获取 MIME 类型: <code>String getMimeType(String file)</code></p>
<blockquote>
<p>MIME 类型</p>
<p>概念：互联网通信过程中定义的一种文件数据类型</p>
<p>格式：大类型/小类型（<code>text/html</code>）</p>
</blockquote>
</li>
</ul>
<ul>
<li>获取文件的真实路径：<code>String realPath = ServletContext.getRealPath(String Path)</code></li>
</ul>
<ul>
<li><p>使用上下文对象取得全局参数信息：</p>
<p><strong>1、全局参数：</strong>可以应用于所有的 Servlet， 全局参数在 web.xml 中进行配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置全局参数，以键值对的方式呈现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">content-param</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>str1<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>abcd<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">content-param</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>2、使用上下文对象取得全局参数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取得上下文对象</span></span><br><span class="line">ServletContext application = <span class="keyword">this</span>.getServletContext();</span><br><span class="line"><span class="comment">// 使用上下文对象取得全局参数</span></span><br><span class="line">application.getInitparameter(<span class="string">"str1"</span>);</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="ServletConfig-对象"><a href="#ServletConfig-对象" class="headerlink" title="ServletConfig 对象"></a>ServletConfig 对象</h3><blockquote>
<p>ServletConfig 对象在企业级开发中用不到，在自己编写框架的时候会用到</p>
</blockquote>
<p><strong>概念：</strong>在 Servlet 对象创建出来之后，搭配每一个 Servlet，会产生一个 ServletConfig 对象，ServletConfig 对象是用来装饰 Servlet 对象的装饰对象</p>
<p><strong>取得方式：</strong><code>ServletConfig config = this.getServletConfig();</code></p>
<p><strong>注意：</strong>ServletConfig 对象的名字必须为：<strong>config</strong></p>
<p><strong>常用方法：</strong></p>
<ul>
<li><p>获取 web.xml 文件中配置的 servlet-name –&gt; <code>config.getServletName()</code></p>
</li>
<li><p>取得 Servlet 的参数值 –&gt; <code>config.getInitParameter(&quot;key&quot;)</code></p>
<ul>
<li><p>取得的参数值是当前 Servlet 的<strong>局部参数</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>str1<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>abcd<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<h3 id="欢迎页（index-html）和404页面"><a href="#欢迎页（index-html）和404页面" class="headerlink" title="欢迎页（index.html）和404页面"></a>欢迎页（index.html）和404页面</h3><p>欢迎页是在 web.xml 自动生成配置的，当我们没有指定具体的访问资源时，默认访问欢迎页</p>
<p>欢迎页一般命名为：<code>index.html</code></p>
<blockquote>
<p>欢迎页的正确使用方式：</p>
<ul>
<li>创建 index.html 文件，不做任何操作，只是跳转到一个作为欢迎页的网页（如登录页）</li>
</ul>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--404页面在 web.xml 中配置，当程序出现 error-code 对应的错误码时，就会跳转到相应的错误页--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/error/error_404.html<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="关于-Servlet-线程安全性的问题"><a href="#关于-Servlet-线程安全性的问题" class="headerlink" title="关于 Servlet 线程安全性的问题"></a>关于 Servlet 线程安全性的问题</h3><p>在 Servlet 中，<strong>成员变量</strong>会引起线程安全的问题，</p>
<p>要想解决这个问题，就<strong>不使用成员变量</strong>，因为在 Servlet 中一般也用不到成员变量</p>
<blockquote>
<p>在 IDEA 中不重启服务器就可以更新 Servlet 到界面：</p>
<ul>
<li>在启动 Tomcat 时使用 debug 模式</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript--2</title>
    <url>/2019/04/11/Java/2.JavaWeb/4.JavaScript--2/</url>
    <content><![CDATA[<p>BOM &amp; DOM</p>
<a id="more"></a>

<h1 id="BOM-amp-DOM"><a href="#BOM-amp-DOM" class="headerlink" title="BOM &amp; DOM"></a>BOM &amp; DOM</h1><h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><p><strong>BOM</strong> : Broswer Object Model：浏览器对象模型</p>
<p>对象：</p>
<ol>
<li><p><strong>Window（非常重要）</strong></p>
<p><strong>使用：</strong></p>
<p>Window 里面的方法可以通过 <code>window.方法名()</code> 使用</p>
<p>也可以直接通过 <code>方法名()</code> 使用</p>
<p><strong>方法：</strong></p>
<ol>
<li>与<strong>弹出</strong>有关的方法<ul>
<li><code>alert()</code> –&gt; 在页面弹个警告框，显示内容</li>
<li><code>confirm()</code> –&gt; 确认提示框，带有一段消息和确认/取消按钮，<u><strong>后期常用</strong></u><ul>
<li>点击确认按钮，方法返回 true</li>
<li>点击取消按钮，方法返回 false</li>
</ul>
</li>
<li><code>prompt(&quot;text&quot;,&quot;defaultText&quot;)</code> –&gt; 输入对话框，返回用户输入的值<ul>
<li>text –&gt; 提示文本</li>
<li>defaultText –&gt; 默认输入的内容</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<ol start="2">
<li><p>与<strong>打开关闭</strong>有关的方法</p>
<ul>
<li><code>open(&quot;url&quot;,&quot;name&quot;,&quot;features&quot;)</code> –&gt; 打开一个新的窗口，返回新窗口的 Window 对象<ul>
<li>url –&gt; 新窗口中要打开的页面地址</li>
<li>name –&gt; 新窗口名称，可为空</li>
<li>features –&gt; 窗口特征，可设置宽高等</li>
</ul>
</li>
<li><code>close()</code> –&gt; 关闭窗口（浏览器兼容性比较差）<ul>
<li>谁调用close()，就关闭谁</li>
</ul>
</li>
</ul>
</li>
<li><p>与<strong>定时器</strong>有关的方法</p>
<ul>
<li><p><code>setTimeout(&quot;js代码&quot;,毫秒数)</code> –&gt; 在一定的毫秒数之后，只执行一次结束代码（一次）</p>
<ul>
<li>方法的返回值：一个唯一标识，用于取消定时器</li>
</ul>
</li>
<li><p><code>clearTimeout()</code> –&gt; 清除 setTimeout 设置的计时器</p>
</li>
</ul>
</li>
</ol>
<pre><code>- `setInterval(&quot;js代码&quot;,毫秒数)` --&gt; 每过一定的毫秒数，执行一次 js 代码（循环）

  - 方法的返回值：一个唯一标识，用于取消定时器
- `clearInterval()` --&gt; 清除 setInterval 设置的计时器</code></pre><p>   <strong>属性：</strong></p>
<ol>
<li>获取其他 BOM 对象<ul>
<li>navigator</li>
<li>screen</li>
<li>location</li>
<li>history</li>
</ul>
</li>
<li>获取 DOM 对象<ul>
<li>document</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>Navigator –&gt;  获取浏览器的信息</p>
</li>
<li><p>Screen –&gt; 获取屏幕的相关信息</p>
</li>
<li><p>Location –&gt; 请求的 URL 地址</p>
<ul>
<li>href 属性：<ul>
<li><code>location.href</code> –&gt; 获取到请求的 URL 地址</li>
<li><code>location.href = &quot;url&quot;;</code> –&gt; 设置 URL 地址</li>
</ul>
</li>
<li>reload() 方法：<ul>
<li><code>location.reload();</code> –&gt; 刷新页面</li>
</ul>
</li>
</ul>
</li>
<li><p>History –&gt; 请求的 URL 历史记录</p>
<ul>
<li>方法：<ul>
<li><code>back()</code>–&gt; 加载 history 列表的前一个 URL（到上一个页面）</li>
<li><code>forward()</code> –&gt; 加载 history 列表的后一个 URL（到下一个页面）</li>
<li><code>go(-1/1)</code> –&gt; 到上/下一个页面</li>
</ul>
</li>
<li>属性：<ul>
<li>length –&gt; 返回当前窗口历史列表的 URL 数量</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p><strong>DOM：</strong>Document Object Model：文档对象模型</p>
<ul>
<li>文档：超文本标记文档，HTML / XML</li>
<li>对象： 提供了属性和方法</li>
<li>模型：使用属性和方法操作文档</li>
</ul>
<p>一句话：将标记文档的各个组成部分，封装成对象。可以使用这些对象，对文档进行动态操作</p>
<p><strong>使用 DOM 解析 HTML 的过程:</strong></p>
<ul>
<li>根据 HTML 的结构，在内存中分配一个树形结构，然后把 HTML 的每一部分都封装成对象<ul>
<li>document 对象： 整个文档</li>
<li>element 对象：标签对象</li>
<li>属性对象</li>
<li>文本对象</li>
</ul>
</li>
<li>Node 节点对象：为上面几个对象的父对象<ul>
<li>如果在上面几个对象中找不到想要的对象，就到 Node 对象里面去找</li>
</ul>
</li>
</ul>
<p><strong>DHTML</strong>：是多种技术的简称</p>
<ul>
<li>HTML：封装数据</li>
<li>CSS： 使用属性和属性值设置样式</li>
<li>dom：操作HTML文档</li>
<li>JavaScript：专指ECMAScript</li>
</ul>
<h3 id="Document-对象"><a href="#Document-对象" class="headerlink" title="Document 对象"></a>Document 对象</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>通过 window 来创建： window.document</p>
<p>直接创建：document</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul>
<li><code>write()</code> –&gt; 直接向页面输出内容（变量值、HTML 代码）<ul>
<li>输出变量值：document.write(str);</li>
<li>输出HTML代码：<code>document.write(&quot;&lt;hr/&gt;&quot;);</code></li>
</ul>
</li>
<li><code>getElementById()</code> –&gt; 通过 <strong>id 属性值</strong>获取 <strong>element 对象</strong></li>
<li><code>getElementsByName()</code> –&gt; 通过 <strong>name 属性值</strong>获取 <strong>element 对象数组</strong></li>
<li><code>getElementsByClass()</code> –&gt; 通过 <strong>class 属性值</strong>获取 <strong>element 对象数组</strong></li>
<li><code>getElementsByTagName()</code> –&gt; 通过<strong>标签名称</strong>获取 <strong>element 对象数组</strong></li>
<li><code>createElement()</code>–&gt; 创建元素对象</li>
</ul>
<h3 id="Element-对象"><a href="#Element-对象" class="headerlink" title="Element 对象"></a>Element 对象</h3><h4 id="获取-创建"><a href="#获取-创建" class="headerlink" title="获取/创建"></a>获取/创建</h4><p>使用 document 中的相应方法获取和创建</p>
<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><ul>
<li><code>getAttribute(&quot;属性名称&quot;)</code> –&gt; 获取属性里面的值</li>
<li><code>setAttribute(&quot;属性名&quot;,&quot;属性值&quot;)</code> –&gt; 设置某个属性的值</li>
<li><code>removeAttribute(&quot;属性名&quot;)</code> –&gt; 删除某个属性<ul>
<li>remove 不能删除 <strong>value</strong> 属性</li>
</ul>
</li>
</ul>
<p>获取标签下面的子标签</p>
<p>使用 <code>getElementsByTagName(&quot;&quot;)</code>，这是唯一有效方法。</p>
<h3 id="Node-对象"><a href="#Node-对象" class="headerlink" title="Node 对象"></a>Node 对象</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>parentNode：返回当前节点的父节点</p>
<h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h4><ul>
<li><code>appendChild()</code> –&gt; 向当前节点的子节点列表末尾添加新的子节点</li>
<li><code>removeChild()</code> –&gt; 删除（并返回）当前节点的指定子节点</li>
<li><code>replaceChild(newnode, oldnode)</code> –&gt; 用新节点替换一个子节点</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>所有的 DOM 对象都可以被看成一个节点</p>
<blockquote>
<p>节点不能自己删除自己，插入、删除、替换都得通过父节点来进行操作</p>
</blockquote>
<h3 id="innerHTML-属性（重要）"><a href="#innerHTML-属性（重要）" class="headerlink" title="innerHTML 属性（重要）"></a>innerHTML 属性（<em>重要</em>）</h3><p>设置和获取标签体的内容</p>
<h3 id="控制元素样式"><a href="#控制元素样式" class="headerlink" title="控制元素样式"></a>控制元素样式</h3><ol>
<li><p>使用元素的 <code>style</code> 属性来设置</p>
<p><code>div1.style.border = &quot;1px solid red&quot;</code></p>
</li>
<li><p>提前定义好类选择器的样式，通过元素的 <code>className</code> 属性来设置其 <code>class</code> 属性值</p>
</li>
</ol>
<h3 id="事件☆"><a href="#事件☆" class="headerlink" title="事件☆"></a>事件☆</h3><p>概念：某些组件被执行了某些操作后，触发某些代码的执行</p>
<ul>
<li>事件：某些操作</li>
<li>事件源：组件</li>
<li>监听器：代码</li>
<li>注册监听：将事件、事件源、监听器绑定在一起</li>
</ul>
<p>常见的事件：</p>
<ol>
<li>点击事件<ol>
<li>onclick –&gt; 单击事件</li>
<li>ondblclick –&gt; 双击事件</li>
</ol>
</li>
<li>焦点事件<ol>
<li>onfocus –&gt; 得到焦点</li>
<li>onblur –&gt; 失去焦点</li>
</ol>
</li>
<li>加载事件<ol>
<li>onload –&gt; 一张网页或一幅图像完成加载</li>
</ol>
</li>
<li>鼠标事件<ol>
<li>onmousedown –&gt; 鼠标按钮按下<ul>
<li>定义方法时，定义一个形参，接收 event 对象，enent 对象的 button 属性可以获取鼠标的那个键被点击了</li>
</ul>
</li>
<li>onmouseup –&gt; 鼠标按钮松开</li>
<li>onmousemove –&gt; 鼠标移动</li>
<li>onmouseover –&gt; 鼠标移动到某元素上</li>
<li>onmouseout –&gt; 鼠标从某元素上移开</li>
</ol>
</li>
<li>键盘事件<ol>
<li>onkeydown –&gt; 某个键盘按键被按下</li>
<li>onkeyup –&gt; 某个键盘按键被松开</li>
<li>onkeypress –&gt; 某个键盘按键按下后松开</li>
</ol>
</li>
<li>选择和改变<ol>
<li>onchange –&gt; 域的内容被改变（一般和 select 标签一起使用）<ul>
<li>实现 <code>省市联动</code> 时使用</li>
</ul>
</li>
<li>onselect –&gt; 文本被选中</li>
</ol>
</li>
<li>表单事件<ol>
<li>onsubmit –&gt; 提交按钮被点击<ul>
<li>可以阻止表单的提交（方法返回 false）</li>
</ul>
</li>
<li>onreset –&gt; 重置按钮被点击</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript</title>
    <url>/2019/04/10/Java/2.JavaWeb/3.JavaScript--1/</url>
    <content><![CDATA[<p>JavaScript 是 ECMAScript 的一种实现</p>
<a id="more"></a>

<h1 id="JavaScript–ECMAScript"><a href="#JavaScript–ECMAScript" class="headerlink" title="JavaScript–ECMAScript"></a>JavaScript–ECMAScript</h1><h2 id="初识-JS"><a href="#初识-JS" class="headerlink" title="初识 JS"></a>初识 JS</h2><p>JS 是<strong>基于对象</strong>和<strong>事件驱动</strong>的语言，应用于客户端</p>
<p><strong>特点：</strong>交互性、安全性、跨平台性</p>
<p><strong>组成：</strong>ECMAScript、bom、dom</p>
<p><strong>作用：</strong></p>
<ul>
<li>让网页和用户之间进行直接简单的<strong>交互</strong></li>
<li>可以给网页添加特效和<strong>动画</strong></li>
</ul>
<blockquote>
<p>HTML –&gt; 定义了网页的<strong>内容</strong></p>
<p>CSS  –&gt; 描述了网页的<strong>布局</strong></p>
<p>JavaScript –&gt; 规定了网页的<strong>行为</strong></p>
</blockquote>
<h2 id="JS-的声明"><a href="#JS-的声明" class="headerlink" title="JS 的声明"></a>JS 的声明</h2><p>JS 需要在 HTML 中进行声明</p>
<p><strong>声明方式：</strong></p>
<ul>
<li>使用 <code>script</code> 标签<strong>声明 JS 代码域</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    alert(<span class="string">"去吧，皮卡丘"</span>);	</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>script</code> 标签<strong>引入外部声明的 JS 文件</strong><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"相对路径"</span> &gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>script 标签可以定义在 HTML 页面的任意位置，建议把 script 标签放到 <code>&lt;/body&gt;</code> 后面</p>
<p>script 可以定义多个</p>
</blockquote>
<h2 id="JS-的变量"><a href="#JS-的变量" class="headerlink" title="JS 的变量"></a>JS 的变量</h2><p>1、变量的声明：使用 <code>var</code> 关键字（JS 为<strong>弱类型</strong>语言）</p>
<p><code>var 变量名 = 初始值;</code></p>
<p>如 ：<code>var  a = 1;</code></p>
<p>2、变量的特点：</p>
<ul>
<li>变量声明只有 var 关键字，声明的变量可以存储任意类型的数据</li>
<li>允许出现同名变量，后面的值会把前面的值覆盖</li>
<li>声明一个变量但不赋值，默认值为 <code>undefined</code></li>
</ul>
<p>3、变量的<strong>数据类型</strong></p>
<ul>
<li>变量的数据类型<ul>
<li><strong>number：</strong>数字类型（实数）</li>
<li><strong>string：</strong>字符串类型（包括单个字符）</li>
<li><strong>boolean：</strong>布尔类型</li>
<li><strong>undefined：</strong>声明但未初始化的变量为此类型</li>
</ul>
</li>
<li>引用数据类型<ul>
<li><strong>object：</strong>对象类型</li>
</ul>
</li>
</ul>
<p>使用方法 <code>typeof(变量名)</code> 来判断变量的数据类型</p>
<p>4、变量的<strong>强制类型转换</strong></p>
<ul>
<li>使用 <code>Number()</code> 函数，将其他数据类型转换为数值类型，转换失败返回 NaN（Not a Number）</li>
<li>使用 <code>Boolean()</code> 函数，将其他数据类型转换为布尔类型，有值返回 true，无值返回 false</li>
</ul>
<p>5、变量的<strong>自动类型转换</strong></p>
<ul>
<li>在需要数字的地方如果给了 其他的类型的变量，会将其他类型自动转换为数字，转换规则如下：<ul>
<li>字符串会按照字面值进行转换，如果字符串无法转换为数字，则运算结果为 NaN</li>
<li>boolean 类型：true 对应的数值为 1，false 对应的数值是 0</li>
</ul>
</li>
<li>在需要 boolean 的地方如果给了 其他的类型的变量，会将其他类型自动转换为 boolean，转换规则如下：<ul>
<li>number：0 和 NaN 为 false，其它为 true</li>
<li>string：空字符串为 false，其它为 true</li>
<li>null &amp; undefined ：都为 false</li>
<li>对象：所有对象都为 true</li>
</ul>
</li>
</ul>
<p>6、特殊的值</p>
<ul>
<li>null –类型–&gt; object</li>
<li>undefined –类型–&gt;  undefined</li>
<li>NaN –类型–&gt; number</li>
</ul>
<p>7、JS 的全局变量和局部变量</p>
<ul>
<li><p>全局变量：</p>
<ul>
<li>在 script 标签中定义了一个变量，这个变量在页面中 js 部分（包括其他 script 标签）都可以使用</li>
</ul>
</li>
<li><p>局部变量</p>
<ul>
<li>在方法内部定义的变量，只能在方法内部使用，如果在方法外部调用，会报错</li>
</ul>
</li>
</ul>
<h2 id="JS-的运算符"><a href="#JS-的运算符" class="headerlink" title="JS 的运算符"></a>JS 的运算符</h2><p>JS 的大部分运算符都和 Java 是一样的，不一样的如下：</p>
<p>1、关于数值类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">123</span>;</span><br><span class="line">alert(a/<span class="number">1000</span>*<span class="number">1000</span>); <span class="comment">// 输出的结果是：123，因为JS的数据是不分整数和小数的</span></span><br><span class="line"><span class="comment">// 但是Java中得到的结果是0</span></span><br></pre></td></tr></table></figure>

<p>2、字符串和数字的相加相减操作</p>
<ul>
<li>相加的时候执行的是字符串的连接</li>
<li>相减的时候执行的是减法（做减法之前会先把字符串按照字面值转换为数字，如果字符串无法转换为数字，则运算结果为 NaN）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"456"</span>;</span><br><span class="line">alert(str+<span class="number">1</span>);<span class="comment">// 得到的结果是string："4561"</span></span><br><span class="line">alert(str<span class="number">-1</span>);<span class="comment">// 得到的结果是number：455</span></span><br></pre></td></tr></table></figure>

<p>3、boolean 类型的运算</p>
<ul>
<li>如果 boolean 变量的值为 true，则对应的数值为 1</li>
<li>如果 boolean 变量的值为 false，则对应的数值是 0</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line">alert(flag+<span class="number">1</span>);<span class="comment">// 得到的结果是number：2</span></span><br><span class="line"><span class="keyword">var</span> flag1 = <span class="literal">false</span>;</span><br><span class="line">alert(flag1+<span class="number">1</span>);<span class="comment">// 得到的结果是number：1</span></span><br></pre></td></tr></table></figure>

<p>4、== 和 ===</p>
<ul>
<li>== 判断<strong>值</strong>是否相同，返回 true/false</li>
<li>=== 判断<strong>值和类型</strong>是否相同，返回 true/false</li>
</ul>
<h2 id="JS-的语句"><a href="#JS-的语句" class="headerlink" title="JS 的语句"></a>JS 的语句</h2><p>1、if 判断语句</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">if</span>(m==<span class="number">5</span>) &#123;</span><br><span class="line">   alert(<span class="string">"m=5"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(m==<span class="number">6</span>) &#123;</span><br><span class="line">    alert(<span class="string">"m==5"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    alert(<span class="string">"m!=5 &amp; m!=6"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2、switch 语句</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	在js中的switch语句和Java中不太一样</span></span><br><span class="line"><span class="comment">	Java中：switch只能接收：byte，short，int，String（jdk1.7之后），enum（jdk1.5之后）</span></span><br><span class="line"><span class="comment">	js中：switch可以接收所有原始数据类型：String，number，boolean，null,undefined</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">switch</span>(b)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">		alert(<span class="string">"3"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    	alert(<span class="string">"6"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        alert(<span class="string">"other"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>3、循环语句</p>
<ul>
<li>for 循环</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">    alert(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>while 循环</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">while</span>(a&lt;<span class="number">6</span>)&#123;</span><br><span class="line">    alert(a);</span><br><span class="line">    a++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>直接向页面输出的语句：</p>
<p>document.write(“abc”);<br>document.write(“<code>&lt;hr&gt;</code>“);  // 可以输出HTML的标签</p>
</blockquote>
<h2 id="JS-对象"><a href="#JS-对象" class="headerlink" title="JS 对象"></a>JS 对象</h2><h3 id="String-对象"><a href="#String-对象" class="headerlink" title="String 对象"></a>String 对象</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>​    <code>var str = &quot;abc&quot;;</code></p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p><code>length</code> –&gt; 字符串的长度</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul>
<li>与 HTML 相关的方法<ul>
<li><code>bold()</code> –&gt; 加粗</li>
<li><code>fontcolor(&quot;color&quot;)</code> –&gt; 设置字体颜色</li>
<li><code>fontsize(1-7)</code> –&gt; 设置字体大小，<em>1 最小，7 最大</em></li>
<li><code>link(&quot;url&quot;)</code> –&gt; 将字符串设置成超链接</li>
<li><code>sub()</code> 和 <code>sup()</code> –&gt; 设置上标和下标</li>
</ul>
</li>
<li>与 Java 相似的方法<ul>
<li><code>concat()</code> –&gt; 连接字符串</li>
<li><code>charAt()</code> –&gt; 返回指定位置的字符</li>
<li><code>indexOf()</code> –&gt; 返回指定字符的索引</li>
<li><code>split()</code> –&gt; 切分字符串</li>
<li><code>replace(&quot;被替换&quot;, &quot;替换&quot;)</code> –&gt; 替换字符串</li>
<li><code>substr()</code> 和 <code>substring()</code><ul>
<li><code>substr(a, b)</code> –&gt; 从第 a 位开始，向后截取 b 位</li>
<li><code>substring(a, b)</code> –&gt; 从第 a 位开始，到第 b 位结束，不包含最后一位</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Function-函数（方法）对象"><a href="#Function-函数（方法）对象" class="headerlink" title="Function 函数（方法）对象"></a>Function 函数（方法）对象</h3><h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><ol>
<li><p>使用关键字 function</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 方法名（参数列表）</span>&#123;</span><br><span class="line">    <span class="comment">// 方法体；</span></span><br><span class="line">    <span class="comment">// 返回值；（可有可无）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>匿名函数，使用关键字 function，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fun = <span class="function"><span class="keyword">function</span>（参数列表）</span>&#123;</span><br><span class="line">	<span class="comment">// 方法体；</span></span><br><span class="line">	<span class="comment">// 返回值；（可有可无）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态函数（<em>了解即可</em>），使用内置对象 Function</p>
<p><code>(var a =) new Function (&quot;参数列表&quot;,&quot;方法体; 返回值;&quot;);</code></p>
</li>
</ol>
<h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><p>length：代表形参的个数</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>1、定义方法时，形参类型不用写，返回值类型也不用写</p>
<p>2、如果定义重名方法，后面定义的会把前面定义的覆盖</p>
<p>3、在 JS 中，方法的调用只与方法的名称有关，与方法的参数无关</p>
<p>4、在方法的声明中有一个隐藏的内置对象 arguments，它是一个数组，封装了所有的实际参数</p>
<blockquote>
<p><strong>JS 的函数重载</strong></p>
<p>问：JS 中是否存在重载（面试题目）</p>
<p>答：</p>
<ol>
<li><p>JS 中不存在重载</p>
</li>
<li><p>但是可以通过其他方式模拟重载的效果（利用arguments数组实现）</p>
</li>
</ol>
</blockquote>
<h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><p><code>方法名称(参数列表)</code></p>
<h3 id="Array-对象"><a href="#Array-对象" class="headerlink" title="Array 对象"></a>Array 对象</h3><h4 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h4><ol>
<li>var arr = [元素列表];</li>
<li>var arr1 = new Array(默认长度);</li>
<li>var arr2 = new Array(元素列表); </li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="string">"2"</span>,<span class="literal">true</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种，使用内置对象Array</span></span><br><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>); <span class="comment">// 定义一个数组，长度为5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种，使用内置对象Array</span></span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// 定义一个数组，数组中的元素为：1 2 3</span></span><br></pre></td></tr></table></figure>

<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><ul>
<li>concat() –&gt; 连接两个数组</li>
<li>join() –&gt; 更换分割数组中元素的字符</li>
<li>push() –&gt; 向数组末尾添加元素，返回新的数组的长度</li>
<li>pop() –&gt; 删除数组的最后一个元素，并返回最后一个元素</li>
<li>reverse() –&gt; 将数组逆序</li>
</ul>
<h4 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h4><p>length：获取数组的长度</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>JS 的数组可以存放<strong>不同的数据类型</strong></p>
<p>JS 的数组<strong>长度是可变的</strong></p>
<h3 id="Date-对象"><a href="#Date-对象" class="headerlink" title="Date 对象"></a>Date 对象</h3><h4 id="创建-3"><a href="#创建-3" class="headerlink" title="创建"></a>创建</h4><p>var date = new Date();</p>
<h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h4><p>toLocaleString()：将获取到的时间转换成习惯的格式</p>
<p>获取当前年.月.日，时.分.秒，毫秒</p>
<ul>
<li>年 –&gt; getFullYear() –&gt; 获取四位数年份</li>
<li>月 –&gt; getMonth() –&gt; 返回 0 - 11</li>
<li>日(星期) –&gt; getDay() –&gt; 返回 0 - 6，星期日为 0</li>
<li>日(月) –&gt; getDate() –&gt; 返回 1 - 31</li>
<li>时 –&gt; getHours()</li>
<li>分 –&gt; getMinutes()</li>
<li>秒 –&gt; getSeconds()</li>
<li>毫秒 –&gt; getTime –&gt; 返回1970年1月1日至今的毫秒数</li>
</ul>
<h3 id="Math-对象"><a href="#Math-对象" class="headerlink" title="Math 对象"></a>Math 对象</h3><h4 id="创建-4"><a href="#创建-4" class="headerlink" title="创建"></a>创建</h4><p>Math 对象不需要创建，直接 <strong>Math.方法名</strong> 使用</p>
<h4 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h4><p>PI –&gt; 圆周率</p>
<h4 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h4><ul>
<li><p>random() –&gt; 返回0~1之间的随机数，[0,1)</p>
</li>
<li><p>ceil() –&gt; 向上舍入</p>
</li>
<li><p>floor() –&gt; 向下舍入</p>
</li>
<li><p>round() –&gt; 四舍五入</p>
</li>
</ul>
<h3 id="RegExp-对象"><a href="#RegExp-对象" class="headerlink" title="RegExp 对象"></a>RegExp 对象</h3><h4 id="创建-5"><a href="#创建-5" class="headerlink" title="创建"></a>创建</h4><p>1、<code>var reg = new RegExp(&quot;正则表达式&quot;);</code></p>
<p>2、<code>var reg = /正则表达式/;</code>(常用)</p>
<h4 id="方法-4"><a href="#方法-4" class="headerlink" title="方法"></a>方法</h4><p><code>test(参数字符串)</code> –&gt; 验证指定的字符串是否符合定义的正则表达式的规范</p>
<h2 id="Global-对象"><a href="#Global-对象" class="headerlink" title="Global 对象"></a>Global 对象</h2><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><p>Global 对象为全局对象，其中封装的方法不需要对象，可以直接写名称使用</p>
<h4 id="方法-5"><a href="#方法-5" class="headerlink" title="方法"></a>方法</h4><ul>
<li>eval() –&gt; 执行 js 代码（如果一个字符串的内容是 js 代码，使用此方法可以直接执行）</li>
<li>encodeURI() –&gt; 对字符进行编码</li>
<li>decodeURI() –&gt; 对字符进行解码</li>
<li>isNaN() –&gt; 判断是否不是数字，不是返回 true，是返回 false</li>
<li>parseInt() –&gt; 类型转换（将字符串转换为数字）<ul>
<li>逐一判断每一个字符是不是数字，直到不是数字为止，将数字部分转为 number</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS</title>
    <url>/2019/04/08/Java/2.JavaWeb/2.CSS/</url>
    <content><![CDATA[<p>CSS 主要是给 HTML ”美容“的</p>
<a id="more"></a>



<h3 id="一、CSS-的基本概念"><a href="#一、CSS-的基本概念" class="headerlink" title="一、CSS 的基本概念"></a>一、CSS 的基本概念</h3><p><strong>CSS</strong>（Cascading Style Sheets）：层叠样式表</p>
<p><strong>作用：</strong>给 HTML 或 XML 添加样式的计算机语言</p>
<h3 id="二、CSS-的声明"><a href="#二、CSS-的声明" class="headerlink" title="二、CSS 的声明"></a>二、CSS 的声明</h3><p>1、在标签上使用 style 属性进行声明 (<em>内联样式</em>)–<u>不常用</u></p>
<p>​    作用：此声明会将 css 样式直接作用于<strong>当前标签</strong></p>
<p>2、在 head 标签中使用 style 标签声明 (<em>内部样式</em>)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作用：此声明一般声明<strong>当前网页</strong>的公共样式</p>
<p>3、在 head 标签中使用 link 标签引入外部声明好的 css 文件 (<em>外部样式</em>)</p>
<p>​    作用：此声明适用于<strong>不同网页</strong>间样式重复使用的问题</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在head标签中使用style标签声明 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    hr&#123;</span><br><span class="line">        width: 50%;</span><br><span class="line">        height: 10px;</span><br><span class="line">        background: red;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在head标签中使用link标签引入外部声明好的css文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"css文件路径"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在标签上使用style属性进行声明 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span> <span class="attr">style</span>=<span class="string">"background: blue;"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>不同的声明给同一个标签操作了同一个样式，遵循就近原则进行显示</p>
</blockquote>
<h3 id="三、CSS-的选择器"><a href="#三、CSS-的选择器" class="headerlink" title="三、CSS 的选择器"></a>三、CSS 的选择器</h3><ol>
<li><p><strong>标签选择器</strong>：将当前网页内的所有该标签增加相同的样式</p>
<p><code>标签名{样式名1:样式值1;......}</code></p>
</li>
<li><p><strong>id 选择器</strong>：选择具体的 id 属性值的元素</p>
<p><code>#id属性值{样式名1:样式值1;......}</code></p>
</li>
<li><p><strong>类选择器</strong>：选择具有<strong>相同 class 属性值</strong>的元素</p>
<p><code>.class属性值{样式名1:样式值1;......}</code></p>
</li>
<li><p><strong>全部选择选择器</strong>：选择所有的 HTML 标签，并添加相同的样式</p>
<p><code>*{样式名1:样式值1;......}</code></p>
</li>
</ol>
<hr>
<ol>
<li><p><strong>组合选择器</strong>：解决不同的选择器之间重复样式的问题</p>
<p><code>选择器1,选择器2{样式名1:样式值1;......}</code></p>
</li>
<li><p><strong>子标签选择器</strong></p>
<p><code>选择器1 子标签选择器2{样式名1:样式值1;......}</code></p>
</li>
<li><p><strong>属性选择器</strong>：指定某属性为特定值的标签的样式</p>
<p><code>标签名[属性名=&quot;属性值&quot;]{样式名1:样式值1;......}</code></p>
</li>
<li><p><strong>伪类选择器</strong>：选择一些元素具有的状态,</p>
<p><code>元素:状态{}</code></p>
</li>
</ol>
<hr>
<p><strong>CSS 的使用过程：</strong></p>
<ol>
<li>声明 CSS 代码域</li>
<li>使用选择器选择要添加样式的标签<ol>
<li>使用 <code>*</code> 选择器给整个页面添加基础样式</li>
<li>使用类选择器给不同的标签添加基础样式</li>
<li>使用标签选择器给某类标签添加基础样式</li>
<li>使用 id 选择器、属性选择器、style 属性声明给单独标签添加样式</li>
</ol>
</li>
<li>书写样式单</li>
</ol>
<h2 id="CSS-的常用样式"><a href="#CSS-的常用样式" class="headerlink" title="CSS 的常用样式"></a>CSS 的常用样式</h2><ul>
<li><strong>边框</strong>设置<ul>
<li><code>border:solid 1px;</code></li>
</ul>
</li>
<li><strong>字体</strong>设置<ul>
<li><code>font-size:10px;</code> –&gt; 设置字体大小</li>
<li><code>font-family:&quot;宋体&quot;;</code> –&gt; 设置字体格式</li>
<li><code>font-weight:bold;</code> –&gt; 加粗</li>
</ul>
</li>
<li><strong>字体颜色</strong>设置<ul>
<li><code>color:颜色;</code></li>
</ul>
</li>
<li><strong>背景颜色</strong>设置<ul>
<li><code>background-color:颜色;</code></li>
</ul>
</li>
<li><strong>背景图片</strong>设置<ul>
<li><code>background-image:url(图片路径);</code> –&gt; 设置背景图片</li>
<li><code>background-repeat:no-repeat;</code> –&gt; 设置图片不重复</li>
<li><code>background-size:cover;</code> –&gt; 图片平铺整个页面</li>
</ul>
</li>
<li><strong>高和宽</strong>设置<ul>
<li><code>width:200px;</code></li>
<li><code>height:300px;</code></li>
</ul>
</li>
<li><strong>浮动</strong>设置<ul>
<li><code>float:left/right;</code></li>
<li>浮动设置可将列表横向显示</li>
</ul>
</li>
<li><strong>行高(行间距)</strong>设置<ul>
<li><code>line-height:10;</code></li>
</ul>
</li>
</ul>
<h2 id="CSS-的盒子模型"><a href="#CSS-的盒子模型" class="headerlink" title="CSS 的盒子模型"></a>CSS 的盒子模型</h2><p><strong>div 标签：</strong></p>
<p>块级标签，主要是用来进行网页布局的，会将其中的子元素内容作为一个独立的整体存在</p>
<p>特点：</p>
<ul>
<li>默认宽度是页面的宽度，可以设置</li>
<li>默认没有高度，可以设置</li>
</ul>
<p><strong>盒子模型：</strong></p>
<p>由内向外以此为：</p>
<ul>
<li><p>内容区域：</p>
<ul>
<li>作用：改变内容区域的大小</li>
<li>设置宽和高即可改变内容区域的大小</li>
</ul>
</li>
<li><p>内边距：<code>padding</code></p>
<ul>
<li>作用：设置<strong>内容和边框</strong>之间的距离</li>
<li>注意：内边距不会改变内容区域的大小</li>
<li>可以单独设置上下左右</li>
</ul>
</li>
<li><p>边框：<code>border</code></p>
<ul>
<li>作用：用来设置元素边框的大小</li>
<li>可以单独设置上下左右</li>
</ul>
</li>
<li><p>外边距：<code>margin</code></p>
<ul>
<li>作用：用于设置元素和元素之间的间隔</li>
<li>居中设置：<code>margin: 0px auto;</code> 上下间距为 0，左右居中</li>
<li>可以单独设置上下左右</li>
</ul>
</li>
</ul>
<h2 id="CSS-的定位"><a href="#CSS-的定位" class="headerlink" title="CSS 的定位"></a>CSS 的定位</h2><p><strong>position：</strong></p>
<ul>
<li>相对定位：<code>relative</code><ul>
<li>作用：相对元素原有的位置移动指定的距离</li>
<li>注意：其他元素的位置是不改变的</li>
</ul>
</li>
<li>绝对定位：<code>absolute</code><ul>
<li>作用：相对于元素的参照界面进行移动</li>
<li>注意：默认参照元素为界面，如果父级元素使用了相对定位，则成为参照元素</li>
</ul>
</li>
<li>固定定位：<code>fixed</code><ul>
<li>作用：将元素固定在页面的指定位置</li>
</ul>
</li>
</ul>
<blockquote>
<p>以上定位都可以用 top、bottom、left、right 来进行移动</p>
</blockquote>
<p><code>z-index</code>：声明元素的显示级别</p>
<p><code>hover</code>：可用于设置与鼠标相关的动作</p>
<blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 去除无序列表前的黑点 --&gt;</span></span><br><span class="line">li&#123;list-style-type: none;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 去除超链接下滑线 --&gt;</span></span><br><span class="line">a&#123;text-decoration: none;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="模拟-360-主页"><a href="#模拟-360-主页" class="headerlink" title="模拟 360 主页"></a>模拟 360 主页</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*&#123;<span class="attribute">margin</span>: <span class="number">0px</span>; <span class="attribute">padding</span>: <span class="number">0px</span>;&#125;</span><br><span class="line"><span class="selector-id">#header</span>&#123;<span class="attribute">width</span>: <span class="number">100%</span>; <span class="attribute">height</span>: <span class="number">36px</span>;&#125;</span><br><span class="line">	<span class="selector-id">#header_left</span>&#123;<span class="attribute">position</span>: absolute; <span class="attribute">left</span>: <span class="number">10px</span>; <span class="attribute">top</span>:<span class="number">10px</span>;&#125;</span><br><span class="line">	<span class="selector-id">#header_right</span>&#123;<span class="attribute">position</span>: absolute; <span class="attribute">right</span>: <span class="number">0px</span>; <span class="attribute">top</span>:<span class="number">10px</span>;&#125;</span><br><span class="line">	<span class="selector-id">#header_left</span> <span class="selector-tag">li</span>&#123;<span class="attribute">float</span>: left; <span class="attribute">list-style-type</span>: none; <span class="attribute">margin-right</span>: <span class="number">20px</span>;&#125;</span><br><span class="line">	<span class="selector-id">#header_right</span> <span class="selector-tag">li</span>&#123;<span class="attribute">float</span>: left; <span class="attribute">list-style-type</span>: none; <span class="attribute">margin-right</span>: <span class="number">20px</span>;&#125;</span><br><span class="line">	<span class="selector-id">#header_left</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span>&#123;<span class="attribute">font-size</span>: <span class="number">13px</span>; <span class="attribute">color</span>: <span class="number">#666666</span>; <span class="attribute">text-decoration</span>: none; &#125;</span><br><span class="line">	<span class="selector-id">#header_right</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span>&#123;<span class="attribute">font-size</span>: <span class="number">13px</span>; <span class="attribute">color</span>: <span class="number">#666666</span>; <span class="attribute">text-decoration</span>: none; &#125;</span><br><span class="line"><span class="selector-id">#main</span>&#123;<span class="attribute">width</span>: <span class="number">100%</span>; <span class="attribute">height</span>: <span class="number">532px</span>; <span class="attribute">text-align</span>: center;&#125;</span><br><span class="line">	<span class="selector-id">#img_logo</span>&#123;<span class="attribute">margin-top</span>: <span class="number">56px</span>;<span class="attribute">margin-bottom</span>: <span class="number">45px</span>;&#125;</span><br><span class="line">	<span class="selector-tag">input</span><span class="selector-attr">[type=text]</span>&#123;<span class="attribute">width</span>: <span class="number">441px</span>; <span class="attribute">height</span>: <span class="number">46px</span>;&#125;</span><br><span class="line">	<span class="selector-tag">input</span><span class="selector-attr">[type=submit]</span>&#123;<span class="attribute">width</span>: <span class="number">100px</span>; <span class="attribute">height</span>: <span class="number">46px</span>;<span class="attribute">border</span>: <span class="number">0px</span>;<span class="attribute">background-color</span>: <span class="number">#19B955</span>; <span class="attribute">position</span>: relative; <span class="attribute">right</span>: <span class="number">6px</span>; <span class="attribute">top</span>: <span class="number">1px</span>;&#125;</span><br><span class="line"><span class="selector-id">#footer</span>&#123;<span class="attribute">width</span>: <span class="number">100%</span>; <span class="attribute">height</span>: <span class="number">90px</span>; <span class="attribute">text-align</span>: center;&#125;</span><br><span class="line">	<span class="selector-id">#img_bottom</span>&#123;<span class="attribute">margin-top</span>: <span class="number">37px</span>;&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>360搜索<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"360搜索.css"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"shortcut icon"</span> <span class="attr">href</span>=<span class="string">"img/360so.ico"</span> <span class="attr">type</span>=<span class="string">"image/x-icon"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"header_left"</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>360导航<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>资讯<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>视频<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>图片<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>良医<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>地图<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>百科<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>英文<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"header_right"</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>设置<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>换肤<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>提醒<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">"img_logo"</span> <span class="attr">src</span>=<span class="string">"img/360搜索.png"</span>  /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"https://www.so.com/s"</span> <span class="attr">method</span>=<span class="string">"get"</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"q"</span> /&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"搜索"</span> /&gt;</span></span><br><span class="line"> 			<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"footer"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">"img_bottom"</span> <span class="attr">src</span>=<span class="string">"img/360bottom.png"</span>  /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML</title>
    <url>/2019/04/06/Java/2.JavaWeb/1.HTML/</url>
    <content><![CDATA[<p>HTML 是互联网的三大基石之一</p>
<a id="more"></a>

<p><img src="/C:/Users/pikachu/Desktop/HTML.jpg" alt="HTML"></p>
<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="一、HTML-的基本概念"><a href="#一、HTML-的基本概念" class="headerlink" title="一、HTML 的基本概念"></a>一、HTML 的基本概念</h2><p><strong>1、</strong>HTML（Hyper Text Markup Language）：<strong>超文本标记语言</strong></p>
<ul>
<li>HTML 是由<strong>浏览器</strong>解析执行的</li>
</ul>
<p><strong>2、</strong>作用：告诉浏览器接收到的数据以何种<strong>数据组织</strong>形式进行展示</p>
<p><strong>3、</strong>互联网的三大基石：</p>
<ul>
<li>URL</li>
<li>HTTP</li>
<li>HTML</li>
</ul>
<p><strong>4、</strong>HTML 文档后缀名：<strong>html</strong> 或 <strong>htm</strong></p>
<p><strong>5、</strong>HTML 的标签分类：</p>
<ul>
<li>围堵标签：有开始标签和结束标签，如<code>&lt;html&gt; &lt;/html&gt;</code></li>
<li>自闭和标签：开始标签和结束标签在一起，如<code>&lt;br/&gt;</code></li>
</ul>
<p><strong>6、</strong>HTML 标签不区分大小写，建议使用小写</p>
<p><strong>7、</strong>在开始标签中可以定义属性。属性是由键值对构成，值需要用引号（单双都可）引起来</p>
<p><strong>8、</strong>标准文档结构：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">			这个标签是HTML的注释</span></span><br><span class="line"><span class="comment">			头标签里面主要是浏览器显示数据的配置信息</span></span><br><span class="line"><span class="comment">		--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        this is my first html</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br/>

<h2 id="二、head-标签"><a href="#二、head-标签" class="headerlink" title="二、head 标签"></a>二、head 标签</h2><p><strong>1、网页标题标签</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>好好学习，天天向上<span class="tag">&lt;/<span class="name">title</span>&gt;</span> <span class="comment">&lt;!-- 配置网页标题 --&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>2、编码格式标签</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>/&gt;</span> <span class="comment">&lt;!-- 告诉浏览器使用指定的编码格式解析文档（HTML5） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"content-type"</span> <span class="attr">content</span>=<span class="string">"text/html,charset=utf-8"</span>/&gt;</span> <span class="comment">&lt;!-- HTML4 --&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>3、网页搜索优化标签</strong>(认识即可)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"keywords"</span> <span class="attr">content</span>=<span class="string">"HTML,练习"</span>/&gt;</span> <span class="comment">&lt;!-- 网页关键字 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">"这个网页是学习HTML的一个练习网页"</span>/&gt;</span> <span class="comment">&lt;!-- 网页描述 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"author"</span> <span class="attr">content</span>=<span class="string">"me"</span>/&gt;</span> <span class="comment">&lt;!-- 网页作者 --&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>4、网页自动跳转标签</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"refresh"</span>  <span class="attr">content</span>=<span class="string">"5,url=http://www.baidu.com"</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>5、其他标签</strong></p>
<p>​    css 引入标签、js 引入标签</p>
<h2 id="三、body-标签–文本标签"><a href="#三、body-标签–文本标签" class="headerlink" title="三、body 标签–文本标签"></a>三、body 标签–文本标签</h2><p><strong>1、标题标签</strong></p>
<p><code>h1</code> 到 <code>h6</code>：将其中的文本<strong>加粗加黑</strong>显示，<strong>自动换行</strong>（块级标签）</p>
<p>属性：<strong>align</strong>：<strong>center  left  right</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span> Hello World <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>2、水平线标签</strong></p>
<p><code>hr</code>：会在页面中显示一条水平线，默认<strong>全尺寸</strong>居中显示</p>
<p>属性：</p>
<ul>
<li><code>width=&quot;宽度&quot;</code></li>
<li><code>size=&quot;高度&quot;</code></li>
<li><code>color=&quot;颜色&quot;</code></li>
<li><code>align=&quot;位置&quot;</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hr</span> <span class="attr">width</span>=<span class="string">"800px"</span> <span class="attr">size</span>=<span class="string">"20px"</span> <span class="attr">color</span>=<span class="string">"red"</span> <span class="attr">align</span>=<span class="string">"center"</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>3、段落标签</strong></p>
<p><code>p</code>：会将一段数据作为整体进行显示，方便 css 和 js 操作，<strong>自动换行</strong>（块级标签）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    这是一段文字，作为一个整体进行显示</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>4、换行标签</strong></p>
<p><code>br</code>：在此位置换行</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">你好<span class="tag">&lt;<span class="name">br</span> /&gt;</span>再见<span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>5、空格符</strong></p>
<p><code>&amp;nbsp ;</code> –&gt; 在此位置增加空格</p>
<p><strong>6、权重标签</strong></p>
<p><code>b</code>：将内容<strong>加黑</strong>显示</p>
<p><code>i</code>：将内容<strong>斜体</strong>显示</p>
<p><code>u</code>：将内容加<strong>下划线</strong></p>
<p><code>del</code>：将内容加<strong>删除线</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>加黑<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span>&gt;</span>斜体<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">u</span>&gt;</span>下划线<span class="tag">&lt;/<span class="name">u</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">del</span>&gt;</span>删除线<span class="tag">&lt;/<span class="name">del</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="四、body-标签-–-列表标签"><a href="#四、body-标签-–-列表标签" class="headerlink" title="四、body 标签 – 列表标签"></a>四、body 标签 – 列表标签</h2><p>无序列表</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>广州<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>有序列表</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 属性:type="1","a","A","I" --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">"a"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>早饭<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>午饭<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>晚饭<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>自定义列表</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>一线城市：<span class="tag">&lt;/<span class="name">dt</span>&gt;</span> <span class="comment">&lt;!-- 数据的标题 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>成都<span class="tag">&lt;/<span class="name">dd</span>&gt;</span> <span class="comment">&lt;!-- 数据的内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>西安<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>杭州<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="五、body-标签–图片标签"><a href="#五、body-标签–图片标签" class="headerlink" title="五、body 标签–图片标签"></a>五、body 标签–图片标签</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"图片路径"</span> <span class="attr">width</span>=<span class="string">200px</span> <span class="attr">title</span>=<span class="string">"图片"</span> <span class="attr">alt</span>=<span class="string">"图片丢失了"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 只修改图片的一个尺寸属性时，图片会等比例变化 --&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>1、</strong>图片标签支持<strong>静态图片</strong>和<strong>动态图片</strong></p>
<p><strong>2、</strong>图片标签为<strong>行内元素</strong>，不会自动换行</p>
<p><strong>3、</strong>图片路径：</p>
<ul>
<li>本地：相对路径或绝对路径，常用相对路径</li>
<li>网络：图片 URL</li>
</ul>
<p><strong>4、</strong>属性：</p>
<ul>
<li><code>width = &quot;图片宽度&quot;</code></li>
<li><code>height = &quot;图片高度&quot;</code></li>
<li><code>title = &quot;图片标题&quot;</code> （鼠标放到图片上的时候会显示）</li>
<li><code>alt = &quot;图片加载失败时显示的文字&quot;</code></li>
</ul>
<h2 id="六、超链接标签"><a href="#六、超链接标签" class="headerlink" title="六、超链接标签"></a>六、超链接标签</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"链接路径"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>链接点击处<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>a</code> 标签属性：</p>
<ul>
<li><p>超链接标签为<strong>行内元素</strong>，无自动换行功能</p>
</li>
<li><p><code>href</code>：要跳转的网页资源路径</p>
<ul>
<li>可以是本地资源（本地 html 文件，建议填写相对路径）</li>
<li>也可以是网络资源（URL）</li>
</ul>
</li>
<li><p><code>target</code>：指明跳转之后的网页显示的位置</p>
<ul>
<li><code>_self</code> –&gt; 在当前页刷新显示</li>
<li><code>_blank</code> –&gt; 在新的标签页中打开</li>
<li><code>_top</code> –&gt; 在顶层页面中显示</li>
<li><code>_parent</code> –&gt; 在父级页面中显示</li>
</ul>
</li>
</ul>
<p><strong>链接点击处：</strong></p>
<ul>
<li>可以是文字</li>
<li>也可以是图片</li>
</ul>
<p><strong>锚点标签：</strong></p>
<ul>
<li><p><strong>作用：</strong>在一张网页中进行资源跳转</p>
</li>
<li><p><strong>使用：</strong></p>
<ul>
<li><p>1、使用超链接标签在指定的位置增加锚点：</p>
</li>
<li><pre><code class="html"><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">"锚点名"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span>
<span class="comment"><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 2、使用a标签跳转到指定锚点：</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;html</span><br><span class="line">  &lt;a href&#x3D;&quot;#锚点名&quot;&gt;点击处&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure></span></code></pre>
</li>
</ul>
</li>
<li><p><strong>回到顶部：</strong></p>
<p>在网页底部添加如下标签：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>回到顶部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="七、表格标签"><a href="#七、表格标签" class="headerlink" title="七、表格标签"></a>七、表格标签</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>表格标签<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        	表格标签学习：</span></span><br><span class="line"><span class="comment">        		table：声明一个表格</span></span><br><span class="line"><span class="comment">        			tr：声明一行，可以设置该行的高度</span></span><br><span class="line"><span class="comment">        				th：声明表头单元格，默认居中加黑显示,可通过表头设置该列的宽度</span></span><br><span class="line"><span class="comment">        				td：声明普通单元格，默认居左显示</span></span><br><span class="line"><span class="comment">        		属性：</span></span><br><span class="line"><span class="comment">        			border：给表格添加边框</span></span><br><span class="line"><span class="comment">        			width：设置表格宽度</span></span><br><span class="line"><span class="comment">        			height：设置表格高度</span></span><br><span class="line"><span class="comment">        			cellpadding：设置内容距边框的距离</span></span><br><span class="line"><span class="comment">        			cellspacing：设置边框的宽度</span></span><br><span class="line"><span class="comment">        		特点：默认根据数据的多少进行表格的大小显示	</span></span><br><span class="line"><span class="comment">        		</span></span><br><span class="line"><span class="comment">        	单元格的合并：</span></span><br><span class="line"><span class="comment">        		1、确保单元格是一个规整的表格</span></span><br><span class="line"><span class="comment">        		2、根据要合并的单元格，找到其源码位置</span></span><br><span class="line"><span class="comment">        		3、使用单元格合并属性进行合并</span></span><br><span class="line"><span class="comment">       				行合并：rowspan="要合并的单元格个数"</span></span><br><span class="line"><span class="comment">       				列合并：colspan="要合并的单元格个数"</span></span><br><span class="line"><span class="comment">       			4、删除被合并的位置的单元格	</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">h3</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span>学生信息统计表<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1px"</span> <span class="attr">cellpadding</span>=<span class="string">"10px"</span> <span class="attr">cellspacing</span>=<span class="string">"0px"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">tr</span> <span class="attr">height</span>=<span class="string">"75px"</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">th</span> <span class="attr">width</span>=<span class="string">"150"</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">th</span> <span class="attr">width</span>=<span class="string">"150"</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">th</span> <span class="attr">width</span>=<span class="string">"150"</span>&gt;</span>身高<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">th</span> <span class="attr">width</span>=<span class="string">"150"</span>&gt;</span>体重<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">td</span>&gt;</span>小明<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">td</span>&gt;</span>18<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">td</span>&gt;</span>175<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">td</span>&gt;</span>70<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">td</span>&gt;</span>小红<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>19<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>165<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>55<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">td</span>&gt;</span>小强<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">td</span>&gt;</span>20<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">td</span>&gt;</span>185<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">td</span>&gt;</span>80<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">table</span>&gt;</span>	</span><br><span class="line">		</span><br><span class="line">			<span class="tag">&lt;<span class="name">h3</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span>单元格合并<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1px"</span> <span class="attr">cellpadding</span>=<span class="string">"10px"</span> <span class="attr">cellspacing</span>=<span class="string">"0px"</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">tr</span> <span class="attr">height</span>=<span class="string">"50px"</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span> <span class="attr">width</span>=<span class="string">"100px"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span> <span class="attr">width</span>=<span class="string">"100px"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span> <span class="attr">width</span>=<span class="string">"100px"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span> <span class="attr">width</span>=<span class="string">"100px"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span> <span class="attr">width</span>=<span class="string">"100px"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span> <span class="attr">width</span>=<span class="string">"100px"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">tr</span> <span class="attr">height</span>=<span class="string">"50px"</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">tr</span> <span class="attr">height</span>=<span class="string">"50px"</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span> <span class="attr">rowspan</span>=<span class="string">"2"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">tr</span> <span class="attr">height</span>=<span class="string">"50px"</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">tr</span> <span class="attr">height</span>=<span class="string">"50px"</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"2"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">tr</span> <span class="attr">height</span>=<span class="string">"50px"</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="八、内嵌标签"><a href="#八、内嵌标签" class="headerlink" title="八、内嵌标签"></a>八、内嵌标签</h2><p><code>iframe</code></p>
<p><strong>作用：</strong>在当前网页中加载其他网页的资源，达到同一个页面显示多个网页资源的目的</p>
<p><strong>属性：</strong></p>
<ul>
<li>src：要显示的网页路径（本地或网络）</li>
<li>width：设置显示区域的宽度</li>
<li>height：设置显示区域的高度</li>
<li>name：设置内嵌区域的名字，结合超链接标签的target属性使用</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span> <span class="attr">target</span>=<span class="string">"_if"</span>&gt;</span>百度一下<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">width</span>=<span class="string">"50%"</span> <span class="attr">height</span>=<span class="string">"400px"</span> <span class="attr">name</span>=<span class="string">"_if"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://www.taobao.com"</span> <span class="attr">width</span>=<span class="string">"50%"</span> <span class="attr">height</span>=<span class="string">"400px"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="九、框架标签"><a href="#九、框架标签" class="headerlink" title="九、框架标签"></a>九、框架标签</h2><p><code>frameset</code>：可以实现 <code>iframe</code> 的功能，但更灵活</p>
<p><strong>作用：</strong>把当前页面切分成不同的块，每一块都可以独立的显示一个网页</p>
<p><strong>属性：</strong></p>
<ul>
<li><p>rows：按照行切分页面</p>
</li>
<li><p>cols：按照列切分页面</p>
</li>
<li><p><strong>子标签：frame</strong> –&gt; 进行切分区域的占位</p>
<ul>
<li>src：资源路径</li>
<li>name：区域名称，结合超链接使用</li>
</ul>
</li>
</ul>
<p><strong>注意事项：</strong></p>
<p>使用框架标签时要<strong>删除 body 标签</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>框架标签<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">frameset</span> <span class="attr">rows</span>=<span class="string">"50%,*"</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"http://www.baidu.com"</span>&gt;</span><span class="tag">&lt;/<span class="name">frame</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">name</span>=<span class="string">"_bottom"</span>&gt;</span><span class="tag">&lt;/<span class="name">frame</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="十、form-标签-amp-表单域标签"><a href="#十、form-标签-amp-表单域标签" class="headerlink" title="十、form 标签 &amp; 表单域标签"></a>十、form 标签 &amp; 表单域标签</h2><h3 id="form-标签"><a href="#form-标签" class="headerlink" title="form 标签"></a>form 标签</h3><p><strong>作用：</strong>收集并提交用户数据给指定服务器</p>
<p><strong>属性：</strong></p>
<ul>
<li><code>action</code>：收集到的数据的提交地址</li>
<li><code>method</code>：收集数据的提交方式<ul>
<li><code>get</code>：适合小量数据，表单数据以<strong>?</strong>隔开写在 URL 后面，不安全</li>
<li><code>post</code>：适合大量数据，安全</li>
</ul>
</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>form 标签收集其<strong>内部</strong>的数据</li>
<li>要提交的表单项必须拥有 <code>name</code> 属性（作为<strong>键</strong>），否则不会提交</li>
<li>表单数据提交的是表单域标签的 <code>value</code> 值</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"#"</span> <span class="attr">method</span>=<span class="string">"get"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="form-表单域标签"><a href="#form-表单域标签" class="headerlink" title="form 表单域标签"></a>form 表单域标签</h3><p>form 表单域标签写在 form 标签内部</p>
<p><strong>作用：</strong>给用户提供可以<strong>书写</strong>数据或<strong>选择</strong>的标签</p>
<p><strong>注意：</strong></p>
<ul>
<li>表单域标签为行内元素，需要借助<code>br</code> 实现换行</li>
</ul>
<p><strong>文本框：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"uname"</span> /&gt;</span> <span class="comment">&lt;!-- 收集少量文本数据，用户可见 --&gt;</span></span><br><span class="line">密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"upwd"</span> /&gt;</span> <span class="comment">&lt;!-- 收集密码数据，不可见 --&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>单选框：</strong></p>
<p>属性：</p>
<ul>
<li><p><code>name</code>：name 属性值相同的选择框只能选择一项数据​</p>
</li>
<li><p><code>checked</code>：带有 <code>checked=&quot;checked&quot;</code> 属性的为默认选中</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">男：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"1"</span> <span class="attr">checked</span>=<span class="string">"checked"</span> /&gt;</span></span><br><span class="line">女：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"0"</span> /&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>多选框：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">吃饭<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"fav"</span> <span class="attr">value</span>=<span class="string">"1"</span> <span class="attr">checked</span>=<span class="string">"checked"</span> /&gt;</span></span><br><span class="line">睡觉<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"fav"</span> <span class="attr">value</span>=<span class="string">"2"</span> /&gt;</span></span><br><span class="line">打豆豆<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"fav"</span> <span class="attr">value</span>=<span class="string">"3"</span> /&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>文件选择框：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file"</span> /&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>普通按钮：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"普通按钮"</span> /&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>登录按钮：</strong></p>
<p>登录按钮为<strong>提交数据</strong>的触发点</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"登录"</span> /&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>使用超链接标签提交数据：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"链接路径?username=12345"</span>&gt;</span>使用超链接标签提交<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>隐藏标签：</strong></p>
<blockquote>
<p> 隐藏的数据跟随用户数据的提交而提交，但是不能展示给用户。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"hidden"</span> <span class="attr">value</span>=<span class="string">"1"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>单选下拉框：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"city"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"2"</span>&gt;</span>南京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"3"</span> <span class="attr">selected</span>=<span class="string">"selected"</span>&gt;</span>济宁<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>文本域：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">"say"</span> <span class="attr">rows</span>=<span class="string">"10"</span> <span class="attr">cols</span>=<span class="string">"20"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="模拟百度"><a href="#模拟百度" class="headerlink" title="模拟百度"></a>模拟百度</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"https://www.baidu.com/s"</span> <span class="attr">method</span>=<span class="string">"get"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"wd"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"百度一下"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>静态代理和动态代理</title>
    <url>/2019/04/04/Java/1.Java%E5%9F%BA%E7%A1%80/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p>静态代理的代理类是创建好的一个类</p>
<p>通过动态代理，可以在不修改源码的基础上对方法进行增强</p>
<a id="more"></a>



<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><blockquote>
<p>代理类和被代理类实现实现同一个接口</p>
</blockquote>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> WeddingCompany(<span class="keyword">new</span> You()).happyMarry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">happyMarry</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真实角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">You</span> <span class="keyword">implements</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">happyMarry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"结婚啦"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeddingCompany</span> <span class="keyword">implements</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line">    <span class="comment">// 代理类中需要被代理类的对象</span></span><br><span class="line">    <span class="keyword">private</span> Marry target;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeddingCompany</span><span class="params">(Marry target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">happyMarry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在代理的前后可以执行一些额外的操作</span></span><br><span class="line">        System.out.println(<span class="string">"布置会场"</span>);</span><br><span class="line">        target.happyMarry();</span><br><span class="line">        System.out.println(<span class="string">"收拾会场"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>特点：字节码随用随创建，随用随加载</p>
<p>作用：不修改源码的基础上，对方法进行增强</p>
<p>分类：</p>
<ul>
<li>基于接口的动态代理</li>
<li>基于子类的动态代理</li>
</ul>
<hr>
<h4 id="基于接口的动态代理"><a href="#基于接口的动态代理" class="headerlink" title="基于接口的动态代理"></a>基于接口的动态代理</h4><p><strong>涉及的类：</strong>Proxy</p>
<p><strong>提供者：</strong>JDK 官方</p>
<p><strong>如何创建代理对象：</strong>使用 Proxy 类中的<code>newProxyInstance</code>方法</p>
<p><strong>创建代理对象的要求：</strong>被代理类至少实现一个接口，没有则不能创建</p>
<p><strong>newProxyInstance 方法的参数：</strong></p>
<ul>
<li>ClassLoader：类加载器<ul>
<li>用于加载代理对象字节码，和被代理对象使用相同的类加载器，<strong>固定写法</strong></li>
</ul>
</li>
<li>Class[]：字节码数组<ul>
<li>用于让代理对象和被代理对象有相同的方法，<strong>固定写法</strong></li>
</ul>
</li>
<li>InvocationHandler(接口)：用于提供增强的代码<ul>
<li>它让我们写如何进行代理。一般都是写InvocationHandler的实现类（匿名内部类）</li>
</ul>
</li>
</ul>
<p>代码体现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 该处成员方法设置为final，</span></span><br><span class="line"><span class="comment">         * 是因为在匿名内部类中要想调用外部类的方法，</span></span><br><span class="line"><span class="comment">         * 那么该外部类的方法必须是 final 的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> IProducer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 使用Proxy创建一个代理对象</span></span><br><span class="line">        IProducer proxyProducer = (IProducer) Proxy.newProxyInstance(producer.getClass().getClassLoader(),</span><br><span class="line">                producer.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 执行被代理对象的任何接口方法都会经过该方法</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> proxy     代理对象的引用(一般用不到)</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> method    当前执行的方法</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> args      当前执行的方法的参数</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@return</span>          和被代理对象有相同的返回值</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        <span class="comment">// 提供增强的代码</span></span><br><span class="line">                        Object returnValue = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 1、获取方法执行的参数</span></span><br><span class="line">                        Integer money = (Integer) args[<span class="number">0</span>];</span><br><span class="line">                        <span class="comment">// 2、判断当前方法是不是销售</span></span><br><span class="line">                        <span class="keyword">if</span>(<span class="string">"saleProduct"</span>.equals(method.getName()))&#123;</span><br><span class="line">                            returnValue = method.invoke(producer,(<span class="keyword">int</span>)(money*<span class="number">0.8</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> returnValue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">// 使用代理对象调用方法</span></span><br><span class="line">        proxyProducer.saleProduct(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="基于子类的动态代理"><a href="#基于子类的动态代理" class="headerlink" title="基于子类的动态代理"></a>基于子类的动态代理</h4><p><strong>涉及的类：</strong>Enhancer</p>
<p><strong>提供者：</strong>第三方cglib库</p>
<blockquote>
<p>maven坐标：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1_3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


</blockquote>
<p><strong>如何创建代理对象：</strong>使用Enhancer类中的<code>create</code>方法</p>
<p><strong>创建代理对象的要求：</strong>被代理的类不能被final修饰（不能为最终类）</p>
<p><strong>create方法的参数：</strong></p>
<ul>
<li>Class：字节码<ul>
<li>用于指定被代理对象的字节码</li>
</ul>
</li>
<li>Callback(接口)：用于提供增强的代码<ul>
<li>我们一般写的都是该接口的子接口的实现类：MethodInterceptor</li>
</ul>
</li>
</ul>
<p>代码体现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        Producer cglibProducer = (Producer) Enhancer.create(producer.getClass(),</span><br><span class="line">                <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     *  执行被代理对象的任何方法都会经过该方法</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> objects</span></span><br><span class="line"><span class="comment">                     *      以上三个方法参数和基于接口的动态代理中invoke方法的参数是一样的</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> methodProxy   当前执行方法的代理对象（一般用不到）</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        <span class="comment">// 提供增强的代码</span></span><br><span class="line">                        Object returnValue = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 1、获取方法执行的参数</span></span><br><span class="line">                        Integer money = (Integer) objects[<span class="number">0</span>];</span><br><span class="line">                        <span class="comment">// 2、判断当前方法是不是销售</span></span><br><span class="line">                        <span class="keyword">if</span>(<span class="string">"saleProduct"</span>.equals(method.getName()))&#123;</span><br><span class="line">                            returnValue = method.invoke(producer,(<span class="keyword">int</span>)(money*<span class="number">0.8</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> returnValue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">// 使用代理对象调用方法</span></span><br><span class="line">        cglibProducer.saleProduct(<span class="number">20000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>静态代理</tag>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>XML</title>
    <url>/2019/04/04/Java/1.Java%E5%9F%BA%E7%A1%80/XML/</url>
    <content><![CDATA[<p>XML 是一种非常灵活的语言，通常用于信息的记录和传递</p>
<a id="more"></a>



<h2 id="XML-基本信息"><a href="#XML-基本信息" class="headerlink" title="XML 基本信息"></a>XML 基本信息</h2><p><strong>1、</strong>XML(eXtensible Markup Language)：<strong>可扩展标记语言</strong></p>
<p><strong>2、</strong>XML 是一种非常<strong>灵活</strong>的语言，<strong>没有固定的标签</strong>，任何标签都可以自定义</p>
<p><strong>3、</strong>XML 通常被<strong>用于信息的记录和传递</strong>，因此，XML 经常被<strong>用作配置文件</strong></p>
<p><strong>4、</strong>格式良好的 XML：遵循 XML 文档的基本规则</p>
<ul>
<li>必须有 XML 声明语句</li>
<li>有且只有一个根元素</li>
<li>标签大小写敏感</li>
<li>属性的值用双引号</li>
<li>标签成对</li>
<li>元素正确嵌套</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">books</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">book</span> <span class="attr">id</span>=<span class="string">"01"</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">name</span>&gt;</span>西游记<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">author</span>&gt;</span>吴承恩<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">books</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>5、</strong>有效的 XML 文档</p>
<ul>
<li>首先应该是格式良好的 XML 文档</li>
<li>使用 DTD 和 XSD 定义语义约束</li>
</ul>
<h2 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h2><p>DTD（Document Type Definition）：文件类型定义</p>
<p><strong>作用：</strong>约束XML的文档格式，保证 XML 为一个有效的 XML</p>
<p>DTD 分为<strong>内部 DTD</strong> 和 <strong>外部 DTD</strong></p>
<h3 id="内部-DTD"><a href="#内部-DTD" class="headerlink" title="内部 DTD"></a>内部 DTD</h3><blockquote>
<p>定义在 XML 文档内部的 DTD</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">books</span> [</span></span><br><span class="line"><span class="meta">	<span class="meta">&lt;!ELEMENT <span class="meta-keyword">books</span> (<span class="meta-keyword">book</span>+)&gt;</span></span></span><br><span class="line"><span class="meta">	<span class="meta">&lt;!ELEMENT <span class="meta-keyword">book</span> (<span class="meta-keyword">name</span>,<span class="meta-keyword">author</span>,<span class="meta-keyword">type</span>)&gt;</span></span></span><br><span class="line"><span class="meta">	<span class="meta">&lt;!ELEMENT <span class="meta-keyword">name</span> (<span class="meta-keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">	<span class="meta">&lt;!ELEMENT <span class="meta-keyword">author</span> (<span class="meta-keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">	<span class="meta">&lt;!ELEMENT <span class="meta-keyword">type</span> (<span class="meta-keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">books</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">book</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>西游记<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">author</span>&gt;</span>吴承恩<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">type</span>&gt;</span>四大名著<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">book</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>三国演义<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">author</span>&gt;</span>罗贯中<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">type</span>&gt;</span>四大名著<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">books</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="外部-DTD"><a href="#外部-DTD" class="headerlink" title="外部 DTD"></a>外部 DTD</h3><blockquote>
<p>定义在 XML 外部的 DTD，为一个单独的文件</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">books</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"bookdtd.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">books</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">book</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>西游记<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">author</span>&gt;</span>吴承恩<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">type</span>&gt;</span>四大名著<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">book</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>三国演义<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">author</span>&gt;</span>罗贯中<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">type</span>&gt;</span>四大名著<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">books</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>books的DTD文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!ELEMENT books (book+)&gt;</span><br><span class="line">&lt;!ELEMENT book (name,author,type)&gt;</span><br><span class="line">&lt;!ELEMENT name (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT author (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT type (#PCDATA)&gt;</span><br></pre></td></tr></table></figure>



<h2 id="XSD"><a href="#XSD" class="headerlink" title="XSD"></a>XSD</h2><p>XSD（XML Schema）: DTD 的替代者</p>
<p>XSD 不仅可以定义文档的结构，还可以规范文档的内容</p>
<blockquote>
<p>XSD 和 DTD 基本都不需要我们自己写，能看懂即可</p>
</blockquote>
<h2 id="XML-解析技术"><a href="#XML-解析技术" class="headerlink" title="XML 解析技术"></a>XML 解析技术</h2><p><strong>1、</strong>XML 解析：对 XML 文件进行操作，包括创建 XML 文件，对 XML 文件进行增删改查等操作</p>
<p><strong>2、</strong>XML 常用的解析技术</p>
<ul>
<li>DOM –&gt; 官方提供，基于 XML 树解析，消耗资源大</li>
<li>SAX –&gt; 民间提供，基于事件，消耗资源小</li>
<li>JDOM –&gt; 第三方提供(解析器)，开源，速度比 DOM 快</li>
<li><strong>dom4j</strong> –&gt; 第三方提供（解析器），开源，是 JDOM 的升级版</li>
</ul>
<p><strong>3、dom4j(Dom for Java) 解析 XML</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.dom4j.Attribute;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Document;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.DocumentException;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Element;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.SAXReader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Dom4j读取XML</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pikachu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDom4j</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 创建SAXReader输入流,</span></span><br><span class="line">		SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">		<span class="comment">// 使用SAXReader输入流获取XML文件，创建Document对象</span></span><br><span class="line">		Document document = reader.read(<span class="keyword">new</span> File(<span class="string">"src/book2.xml"</span>));</span><br><span class="line">		<span class="comment">// 获取根元素</span></span><br><span class="line">		Element root = document.getRootElement();</span><br><span class="line"><span class="comment">//		System.out.println(root.getName());</span></span><br><span class="line">		<span class="comment">// 使用迭代器从根元素获取子元素</span></span><br><span class="line">		Iterator&lt;?&gt; it = root.elementIterator();</span><br><span class="line">		<span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">			Element ele = (Element)it.next();</span><br><span class="line">			System.out.println(ele.getName());</span><br><span class="line">			Attribute att = ele.attribute(<span class="string">"num"</span>);<span class="comment">// 获取元素的属性</span></span><br><span class="line">			System.out.println(att.getName()+<span class="string">" = "</span>+att.getData());</span><br><span class="line">			</span><br><span class="line">			Element name = ele.element(<span class="string">"name"</span>);</span><br><span class="line">			Element author = ele.element(<span class="string">"author"</span>);</span><br><span class="line">			Element type = ele.element(<span class="string">"type"</span>);</span><br><span class="line">			</span><br><span class="line">			System.out.println(name.getName()+<span class="string">" = "</span>+name.getText());</span><br><span class="line">			System.out.println(author.getName()+<span class="string">" = "</span>+author.getText());</span><br><span class="line">			System.out.println(type.getName()+<span class="string">" = "</span>+type.getText());</span><br><span class="line">			</span><br><span class="line">			System.out.println(<span class="string">"---------------------"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="利用-dom4j-生成-XML"><a href="#利用-dom4j-生成-XML" class="headerlink" title="利用 dom4j 生成 XML"></a>利用 dom4j 生成 XML</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Writer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.dom4j.Document;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.DocumentHelper;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Element;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.OutputFormat;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.XMLWriter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成XML文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pikachu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDom4j02</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 1.创建Document对象</span></span><br><span class="line">		Document document = DocumentHelper.createDocument();</span><br><span class="line">		<span class="comment">// 2.为Document对象添加根元素</span></span><br><span class="line">		Element root = document.addElement(<span class="string">"books"</span>);</span><br><span class="line">		<span class="comment">// 3.为根元素添加子元素</span></span><br><span class="line">		Element book = root.addElement(<span class="string">"book"</span>);</span><br><span class="line">		<span class="comment">// 4.为book元素添加属性</span></span><br><span class="line">		book.addAttribute(<span class="string">"id"</span>, <span class="string">"b01"</span>);</span><br><span class="line">		<span class="comment">// 5.为book元素添加子元素</span></span><br><span class="line">		Element name = book.addElement(<span class="string">"name"</span>);</span><br><span class="line">		Element author = book.addElement(<span class="string">"author"</span>);</span><br><span class="line">		Element type = book.addElement(<span class="string">"type"</span>);</span><br><span class="line">		<span class="comment">// 6.为子元素添加文本</span></span><br><span class="line">		name.addText(<span class="string">"红楼梦"</span>);</span><br><span class="line">		author.addText(<span class="string">"曹雪芹"</span>);</span><br><span class="line">		type.addText(<span class="string">"四大名著"</span>);</span><br><span class="line">		</span><br><span class="line"><span class="comment">//		// 7.将Document对象输出到文件</span></span><br><span class="line"><span class="comment">//		Writer writer = new FileWriter("src/boooook.xml");</span></span><br><span class="line"><span class="comment">//		document.write(writer);</span></span><br><span class="line"><span class="comment">//		writer.flush();</span></span><br><span class="line"><span class="comment">//		// 8.释放资源</span></span><br><span class="line"><span class="comment">//		writer.close();</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 7.将Document对象进行格式良好的输出</span></span><br><span class="line">		OutputFormat format = OutputFormat.createPrettyPrint();</span><br><span class="line">		XMLWriter writer = <span class="keyword">new</span> XMLWriter(<span class="keyword">new</span> FileWriter(<span class="string">"src/boooook.xml"</span>), format); </span><br><span class="line">		writer.write(document);</span><br><span class="line">		<span class="comment">// 8.关闭资源</span></span><br><span class="line">		writer.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2019/04/04/Java/1.Java%E5%9F%BA%E7%A1%80/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>正则表达式适用于复杂的文本处理</p>
<a id="more"></a>

<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p><strong>1、正则表达式（Regular Expression）简介：</strong></p>
<ul>
<li><strong>定义</strong>：正则表达式描述了一个规则，通过这个规则可以匹配一类字符串</li>
<li>正则表达式适用于<strong>文本的复杂处理</strong></li>
<li>大部分<strong>编程语言</strong>，<strong>数据库</strong>，<strong>文本编辑器</strong>，<strong>开发环境</strong>都支持正则表达式</li>
<li>学习正则表达式就是学习它的<strong>语法规则</strong></li>
</ul>
<hr>
<p><strong>2、开发中使用正则表达式的流程</strong></p>
<ul>
<li><strong>分析</strong>所要匹配的数据，写出测试用的典型数据</li>
<li>在<strong>工具软件（RegexBuddy）</strong>中进行匹配<strong>测试</strong></li>
<li>在程序中<strong>调用</strong>通过测试的正则表达式</li>
</ul>
<hr>
<p><strong>3、正则表达式语法</strong></p>
<ul>
<li><p><strong>普通字符</strong></p>
<p>字母、数字、汉字、下划线以及没有特殊定义的标点符号，都是”普通字符“，表达式中的普通字符，<strong>匹配一个与之相同的字符</strong></p>
</li>
<li><p><strong>普通的转义字符</strong></p>
<ul>
<li><code>\n</code> –&gt; 换行符</li>
<li><code>\t</code> –&gt; 制表符</li>
<li><code>\\</code>–&gt; 匹配 <code>\</code></li>
<li><code>\^</code>，<code>\$</code>，<code>\.</code> 等 –&gt; 匹配这些字符本身</li>
</ul>
</li>
<li><p><strong>标准字符集合</strong></p>
<ul>
<li><code>\d</code> –&gt; 匹配 0~9 中任意一个数字</li>
<li><code>\D</code> –&gt; 匹配 0~9 之外的所有字符（大写表示相反，下同）</li>
<li><code>\w</code> –&gt; 匹配任意一个<strong>字母</strong>或<strong>数字</strong>或<strong>下滑线</strong>，A<del>Z，a</del>z，0~9，_</li>
<li><code>\s</code> –&gt; 匹配任意一个<strong>空白字符</strong>，空格，制表符，换行符等</li>
<li><code>.</code> –&gt; 小数点可以匹配任意一个字符（不包括 <code>\n</code>），匹配 <code>\n</code> 在内的所有字符用 <code>[\s\S]</code></li>
</ul>
</li>
<li><p><strong>自定义字符集合</strong></p>
<blockquote>
<p>方括号匹配方式，可以匹配方括号中的任意一个字符</p>
</blockquote>
</li>
</ul>
<ul>
<li><p><strong>[ab5@]</strong> –&gt; 匹配 <code>a</code> 或 <code>b</code> 或 <code>5</code> 或 <code>@</code></p>
</li>
<li><p><strong>[^abc]</strong> –&gt; 匹配 <code>a</code>，<code>b</code>，<code>c</code> <strong>之外</strong>的任意一个字符</p>
</li>
<li><p><strong>[c-s]</strong> –&gt; 匹配 <code>c</code> ~ <code>s</code> 之间的任意一个字符</p>
</li>
<li><p><strong>[^2-7b-g]</strong> –&gt; 匹配 <code>2</code> ~ <code>7</code>，<code>b</code> ~ `g <strong>之外</strong>的任意一个字符</p>
<blockquote>
<p>正则表达式中的特殊符号，被包含到中括号中，则失去了特殊含义，除了 <code>^</code> 和 <code>-</code></p>
<p>标准字符集合，除小数点外，如果被包含于中括号，自定义字符集合也将包含该集合</p>
</blockquote>
</li>
</ul>
<ul>
<li><p><strong>量词</strong></p>
<blockquote>
<p>修饰匹配次数的特殊符号</p>
</blockquote>
</li>
</ul>
<ul>
<li><p><code>{n}</code> –&gt; 表达式重复 n 次</p>
</li>
<li><p><code>{m,n}</code> –&gt; 表达式至少重复 m 次，最多重复 n 次</p>
</li>
<li><p><code>{m,}</code> –&gt; 表达式至少重复 m 次</p>
</li>
<li><p><code>?</code> –&gt; 匹配表达式 0 次或 1 次，相当于 {0,1}</p>
</li>
<li><p><code>+</code> –&gt; 表达式至少出现 1 次，相当于 {1,}</p>
</li>
<li><p><code>*</code> –&gt; 表达式至少出现 0 次,相当于 {0,}</p>
<blockquote>
<p>匹配次数中的<strong>贪婪模式</strong>：匹配的字符越多越好，<em>默认</em></p>
<p>匹配次数中的<strong>非贪婪模式</strong>：匹配的字符越少越好，需要在修饰匹配次数的特殊符号后加 <code>?</code></p>
</blockquote>
</li>
</ul>
<ul>
<li><p><strong>字符边界</strong></p>
<blockquote>
<p>字符边界匹配的不是字符而是<strong>符合某种条件的位置</strong>（<strong>零宽</strong>）</p>
</blockquote>
</li>
</ul>
<ul>
<li><strong>^</strong> –&gt; 与字符串开始的地方匹配</li>
<li><strong>$</strong> –&gt; 与字符串结束的地方匹配</li>
<li><strong>\b</strong> –&gt; 匹配一个单词边界（前面的字符和后面的字符不全是 <strong>\w</strong>）</li>
</ul>
<ul>
<li><p><strong>匹配模式</strong></p>
<ul>
<li><strong>IGNORECASE</strong> –&gt; 忽略大小写模式</li>
<li><strong>SINGLELINE</strong> –&gt; 单行模式<ul>
<li>整个文本看成一个字符串，只有一个开头和一个结尾</li>
<li>这种情况下小数点 <code>.</code> 可以匹配包括 <code>\n</code> 在内的所有字符</li>
</ul>
</li>
<li>MULTILINE –&gt; 多行模式<ul>
<li>每一行都是一个字符串</li>
<li>在多行模式下，如果仅要匹配<strong>最开始</strong>和<strong>最后</strong>的字符，可使用 <code>\A</code> 和 <code>\Z</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>选择符和分组</strong></p>
<ul>
<li><code>|</code> –&gt; 分支结构，匹配左边或右边</li>
<li><code>()</code> –&gt; 捕获组</li>
<li><code>(?:Expression)</code> –&gt; 非捕获组</li>
</ul>
</li>
<li><p><strong>反向引用 (\nnn)</strong></p>
<ul>
<li>每一对 <code>()</code> 都会分配一个编号，根据<strong>左括号的顺序从 1 开始编号</strong></li>
<li>通过反向引用，可以对<strong>捕获组已捕获的字符串</strong>进行引用</li>
</ul>
</li>
<li><p><strong>预搜索（零宽断言）</strong></p>
<ul>
<li><strong>(?=exp)</strong> –&gt; 断言自身出现的位置<strong>后面能</strong>出现表达式 exp</li>
<li><strong>(?&lt;=exp)</strong> –&gt; 断言自身出现的位置<strong>前面能</strong>出现表达式 exp</li>
<li><strong>(?!exp)</strong> –&gt; 断言自身出现的位置<strong>后面不能</strong>出现表达式 exp</li>
<li><strong>(?&lt;!exp)</strong> –&gt; 断言自身出现的位置<strong>前面不能</strong>出现表达式 exp</li>
</ul>
</li>
</ul>
<h2 id="Java-中使用正则表达式"><a href="#Java-中使用正则表达式" class="headerlink" title="Java 中使用正则表达式"></a>Java 中使用正则表达式</h2><blockquote>
<p>import java.util.regex.Pattern</p>
<p>import java.util.regex.Matcher</p>
</blockquote>
<h3 id="创建正则表达式对象，进行匹配"><a href="#创建正则表达式对象，进行匹配" class="headerlink" title="创建正则表达式对象，进行匹配"></a>创建正则表达式对象，进行匹配</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pattern p = <span class="keyword">new</span> Pattern(<span class="string">"\\b"</span>);</span><br><span class="line">Matcher m = p.compile(<span class="string">"String8Str"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> flag = m.matches();<span class="comment">// 判断整个字符串是否与正则表达式匹配</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(m.find())&#123;<span class="comment">// 找到与该正则表达式匹配的第一个子字符串，然后找下一个</span></span><br><span class="line">	System.out.println(m.group());<span class="comment">// 按照捕获组来输出，0输出全部组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pattern p = Pattern.compile(<span class="string">"[0-9]"</span>);</span><br><span class="line">Matcher m = p.matcher(<span class="string">"asd456fgh"</span>);</span><br><span class="line">String str = m.replaceAll(<span class="string">"!"</span>);<span class="comment">// 把与正则表达式匹配的元素替换成“!”</span></span><br></pre></td></tr></table></figure>



<h3 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"a1b23243434343c33d4e5"</span>;</span><br><span class="line">String[] strarr = str.split(<span class="string">"\\d+"</span>);<span class="comment">//split(String Regex)</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/2019/04/03/Java/Linux/</url>
    <content><![CDATA[<p>Linux 在服务器端有着大量的应用</p>
<a id="more"></a>

<p><img src="/images/Linux/Linux.jpg" alt="Linux"></p>
<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>资源准备：</p>
<ul>
<li>虚拟机：VMware</li>
<li>镜像文件：CentOS 7 镜像文件</li>
</ul>
<p>安装步骤：<a href="https://www.jianshu.com/p/ce08cdbc4ddb?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">https://www.jianshu.com/p/ce08cdbc4ddb?utm_source=tuicool&amp;utm_medium=referral</a></p>
<p>远程连接工具：</p>
<ul>
<li>Xshell（远程连接管理工具）</li>
<li>Xftp（文件拷贝工具）</li>
</ul>
<blockquote>
<p>Linux 查看 IP命令：<code>ifconfig</code></p>
</blockquote>
<blockquote>
<p><strong>Linux 中的一些名词解释：</strong></p>
<ol>
<li>分区：把大硬盘分成小的逻辑分区</li>
<li>格式化：写入文件系统</li>
<li>分区设备文件名：给每个分区定义设备文件名</li>
<li>挂载：给每个分区分配挂载点（必须是空文件夹）</li>
</ol>
</blockquote>
<blockquote>
<p><strong>使用 Linux 的一些注意事项：</strong></p>
<ol>
<li>Linux 严格区分大小写，<strong>命令全为小写</strong></li>
<li>Linux 中所有的内容都是以<strong>文件</strong>保存的，包括硬件</li>
<li>Linux <strong>不靠扩展名</strong>区分文件系统</li>
<li>Linux 所有的存储设备都必须<strong>挂载</strong>之后才能使用</li>
<li>Windows 下的程序不能在 Linux 中安装和运行</li>
</ol>
</blockquote>
<h2 id="Linux-目录简介"><a href="#Linux-目录简介" class="headerlink" title="Linux 目录简介"></a>Linux 目录简介</h2><p><strong>/bin/</strong> –&gt; 存放系统命令的目录，普通用户和超级用户都可以执行，在单用户模式下也可以执行</p>
<p><strong>/sbin/</strong> –&gt; 存放系统环境设置相关的命令，只有超级用户可以执行，</p>
<p><strong>/usr/bin/</strong> –&gt; 存放系统命令的目录，普通用户和超级用户都可以执行，单用户模式下不可执行</p>
<p><strong>/usr/sbin/</strong> –&gt; 存放根文件系统不必要的系统管理命令，只有超级用户可以执行</p>
<hr>
<p><strong>/boot/</strong> –&gt; 系统启动目录，保存启动相关文件，如内核文件和启动引导程序（grub）文件等</p>
<p><strong>/dev/</strong> –&gt; 硬件设备文件保存位置</p>
<p><strong>/etc/</strong> –&gt; 系统配置文件默认保存位置</p>
<hr>
<p><strong>/home/</strong> –&gt; 普通用户的家目录，如 pikachu 用户的家目录就是/home/pikachu/</p>
<p><strong>/lib/</strong> –&gt; 系统调用的函数库保存位置</p>
<p><strong>/lost+found/</strong> –&gt; 备份恢复目录，系统非正常关闭时，会产生一些文件碎片放在这里，当系统启动过程中 fsck 工具会检查这里，并修复已经损坏的文件系统</p>
<hr>
<p><strong>/media/</strong> –&gt; 挂载目录，系统建议用来挂载媒体设备，如光盘</p>
<p><strong>/mnt/</strong> –&gt; 挂载目录，早期 Linux 仅有这一个挂载目录，现在系统建议此目录挂载额外设备，如U盘</p>
<p><strong>/misc/</strong> –&gt; 挂载目录，系统建议用来挂载 NFS 服务的共享目录</p>
<hr>
<p><strong>/opt/</strong> –&gt; 第三方安装的文件保存位置，但是用的不多，<strong>/usr/local/</strong>用的比较多</p>
<hr>
<p><strong>/proc/</strong> –&gt; 虚拟文件系统，该目录中的数据保存在内存中，主要保存系统相关状态</p>
<p><strong>/sys/</strong> –&gt; 虚拟文件系统，数据也是保存在内存中，主要保存内核相关信息</p>
<hr>
<p><strong>/root/</strong> –&gt; 超级用户的家目录，位于 / 目录下</p>
<p><strong>/srv/</strong> –&gt; 服务数据目录</p>
<p><strong>/tmp/</strong> –&gt; 存放临时文件的目录</p>
<p><strong>/usr/</strong> –&gt; 系统软件资源目录，“<strong>U</strong>nix <strong>S</strong>oftware <strong>R</strong>esource”</p>
<p><strong>/var/</strong> –&gt; 动态数据保存目录，保存缓存、日志等</p>
<blockquote>
<p><strong>服务器管理和维护建议</strong></p>
<ul>
<li>服务器不允许关机，只能重启</li>
<li>重启时应关闭服务</li>
<li>不要在服务器访问高峰运行运行高负载命令</li>
<li>远程配置防火墙时不要把自己踢出服务器</li>
<li>指定合乎规范的密码并定期更新</li>
<li>合理分配权限（够用就好，越少越好）</li>
<li>定期备份重要数据和日志（/erc/，/lib/，/var/，/usr/，/boot/等目录）</li>
</ul>
</blockquote>
<h2 id="Linux-关机-amp-重启"><a href="#Linux-关机-amp-重启" class="headerlink" title="Linux 关机 &amp; 重启"></a>Linux 关机 &amp; 重启</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sync				<span class="comment"># 将内存中的数据保存到硬盘上</span></span><br><span class="line"></span><br><span class="line">halt				<span class="comment"># 立刻关机</span></span><br><span class="line">poweroff			<span class="comment"># 立刻关机</span></span><br><span class="line">shutdown -h now 	<span class="comment"># 立刻关机（root用户）</span></span><br><span class="line">shutdown -h 10		<span class="comment"># 10分钟后关机（root用户）</span></span><br><span class="line">shutdown -h 20:30	<span class="comment"># 在今天20:35分关机（root用户）</span></span><br><span class="line"></span><br><span class="line">reboot				<span class="comment"># 立刻重启</span></span><br><span class="line">shutdown -r now		<span class="comment"># 立刻重启（root用户）</span></span><br><span class="line">shutdown -r 10		<span class="comment"># 10分钟后重启（root用户）</span></span><br><span class="line"></span><br><span class="line">shutdown -c			<span class="comment"># 取消关机或重启命令（root用户）</span></span><br></pre></td></tr></table></figure>



<h2 id="目录相关命令"><a href="#目录相关命令" class="headerlink" title="目录相关命令"></a>目录相关命令</h2><blockquote>
<p>Linux 中的路径：</p>
<ul>
<li>绝对路径：以 <code>/</code> 开头</li>
<li>相对路径：以 <code>.</code> 开头，<code>.</code> 表示当前目录，<code>..</code> 表示上级目录</li>
</ul>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span>			<span class="comment"># 切换目录</span></span><br><span class="line">ls			<span class="comment"># 查看当前目录下内容</span></span><br><span class="line"><span class="built_in">pwd</span>			<span class="comment"># 查看当前所在目录</span></span><br><span class="line"></span><br><span class="line">touch		<span class="comment"># 新建文件</span></span><br><span class="line">mkdir		<span class="comment"># 新建目录</span></span><br><span class="line"></span><br><span class="line">rm			<span class="comment"># 删除文件或目录</span></span><br><span class="line">rmdir		<span class="comment"># 删除空目录</span></span><br><span class="line"></span><br><span class="line">cp			<span class="comment"># 复制文件或目录</span></span><br><span class="line">mv			<span class="comment"># 移动文件或目录</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p><strong>Linux中命令的格式：</strong> <code>command [-options] [parameter]</code></p>
<ul>
<li><p><code>commond</code>：命令名</p>
</li>
<li><p><code>options</code>：选项，对命令进行控制，可省略</p>
</li>
<li><p><code>parameter</code>：参数，可以多个，可以省略</p>
<p>例如：删除目录：<code>rm -r dir1</code></p>
</li>
</ul>
<p><strong>查询命令的帮助信息：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">command</span> --<span class="built_in">help</span>	<span class="comment"># 显示命令的帮助信息</span></span><br><span class="line">man <span class="built_in">command</span>		<span class="comment"># 显示命令的使用手册</span></span><br></pre></td></tr></table></figure>



<p><strong>自动补全和命令选择：</strong></p>
<ul>
<li>自动补全：Tab 键，如果结果不唯一，再按两下 Tab 键显示提示</li>
<li>命令选择：上下键，如果不想执行当前选中的命令，按<code>ctrl+c</code></li>
</ul>
</blockquote>
<p><strong>ls 命令选项：</strong></p>
<ul>
<li><code>-a</code>：显示隐藏内容（以 <code>.</code> 开头的内容）</li>
<li><code>-l</code>：以列表的形式显示文件的详细信息</li>
<li><code>-h</code>：配合 <code>-l</code> 以通用方式显示文件大小</li>
</ul>
<p><strong>mkdir 命令选项：</strong></p>
<ul>
<li><p><code>-p</code>：可以直接创建多级目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir dir				<span class="comment"># 不加 -p 只能创建一级目录</span></span><br><span class="line">mkdir -p dir1/dir2/dir3	<span class="comment"># 可以创建多级目录</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>-m</code>：创建目录时指定权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -m 777 dir		<span class="comment"># 指定该目录权限为 777</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<p><strong>rmdir 命令选项：</strong></p>
<ul>
<li><p><code>-p</code>：可以删除多级空目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rmdir dir				<span class="comment"># 不加 -p 只能删除一级空目录</span></span><br><span class="line">rmdir -p dir1/dir2/dir3	<span class="comment"># 可以删除多级空目录</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<p><strong>rm 命令选项：</strong></p>
<ul>
<li><code>-f</code>：强制删除，不会出现提示信息</li>
<li><code>-d</code>：删除空文件夹，等同于 <code>rmdir</code></li>
<li><code>-r</code>：递归删除文件夹</li>
</ul>
<p><strong>cp 命令选项：</strong></p>
<ul>
<li><p><code>-a</code>：相当于 <code>-pdr</code></p>
</li>
<li><p><code>-p</code>：文件和属性一起复制（备份常用）</p>
</li>
<li><p><code>-d</code>：若文件为链接，则复制链接而非文件本身</p>
</li>
<li><p><code>-r</code>：递归复制目录</p>
</li>
<li><p><code>-l</code>：创建硬链接，而非复制文件本身</p>
</li>
<li><p><code>-s</code>：创建软链接文件（快捷方式）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp -a file destdir</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p><strong>mv 命令选项：</strong></p>
<ul>
<li><p><code>-f</code>：若文件已存在，则不会询问，直接覆盖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mv -f file destdir</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h2><p>Linux 系统是一种典型的多用户系统，不同用户拥有不同的权限，不同的文件可以对不同的用户设置不同的权限。</p>
<p>在 Linux 中可以使用 <code>ls -l</code> 或者 <code>ll</code> 命令显示一个文件的属性以及文件所属的用户和用户组</p>
<p><img src="/images/Linux/image-20210418074019926.png" alt="image-20210418074019926"></p>
<p>从上图可以看到，文件信息中第一列共十个字符：<code>drwxr-xr-x</code></p>
<p>第 1 个字符标识文件类型：</p>
<ul>
<li><code>d</code>：目录</li>
<li><code>-</code>：文件</li>
<li><code>l</code>：链接文档（link file）</li>
<li><code>b</code>：装置文件中可供存储的接口设备 ( 可随机存取装置 )</li>
<li><code>c</code>：装置文件里面的串行端口设备，例如键盘、鼠标</li>
</ul>
<p>后面 9 个字符标识文件权限，三个一组，均为 <code>rwx</code> 的组合：</p>
<ul>
<li><code>r</code>：read（可读）</li>
<li><code>w</code>：write（可写）</li>
<li><code>x</code>：execute（可执行）</li>
</ul>
<p>这三个权限的前后位置不会改变，没有权限用 <code>-</code> 表示</p>
<p><img src="/images/Linux/%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7.jpg" alt="图片"></p>
<p><strong>修改文件属性：</strong></p>
<p>两种方法：</p>
<ul>
<li>符号修改法</li>
<li>数字修改法（方便，常用）</li>
</ul>
<p>数字修改法：</p>
<p><code>rwx</code> 三种权限分别使用数字代替：<code>r:4  w:2  x:1</code></p>
<p>每个组的权限使用加和的方式，如 <code>rwx = 4 + 2 + 1 = 7</code>，<code>r-x = 4 + 0 + 1 = 5</code></p>
<p>使用 <code>chmod</code> 命令修改权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod 755 testfile	<span class="comment"># 修改 testfile 文件的属性为 rwxr-xr-x</span></span><br></pre></td></tr></table></figure>





<h2 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h2><p>查看文件内容相关命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat		<span class="comment"># 从第一行开始查看</span></span><br><span class="line">tac		<span class="comment"># 从最后一行开始查看</span></span><br><span class="line"></span><br><span class="line">nl		<span class="comment"># 查看的时候显示行号</span></span><br><span class="line"></span><br><span class="line">more	<span class="comment"># 一页一页查看（只能向后翻页）</span></span><br><span class="line">less	<span class="comment"># 一页一页查看（可以前后翻页）</span></span><br><span class="line"></span><br><span class="line">head	<span class="comment"># 只看开始几行</span></span><br><span class="line">tail	<span class="comment"># 只看最后几行</span></span><br></pre></td></tr></table></figure>



<p><strong>cat 命令选项：</strong></p>
<ul>
<li><code>-A</code>：相当于 <code>-vET</code> 的整合</li>
<li><code>-v</code>：列出一些看不出来的特殊字符</li>
<li><code>-E</code>：将结尾的断行字节 $ 显示出来；</li>
<li><code>-T</code>：将 <code>tab</code> 按键以 <code>^I</code> 显示出来；</li>
<li><code>-b</code>：列出行号，空白行不标行号</li>
<li><code>-n</code>：列出行号，空白行也标</li>
</ul>
<p><strong>more 命令细节：</strong></p>
<ul>
<li>空格键：向下翻一页</li>
<li>Enter 键：向下翻一行</li>
<li><code>:f</code>：立刻显示文件名及当前所显示的行数</li>
<li><code>q</code>：退出文件内容显示</li>
</ul>
<p><strong>less 命令细节：</strong></p>
<ul>
<li>空格键：向下翻一页</li>
<li>Enter 键：向下翻一行</li>
<li>上，下键：上下一行一行查看</li>
<li>PgUp，PgDn 键：上下一页一页查看</li>
<li><code>/字符串</code>：向下搜寻字符串</li>
<li><code>?字符串</code>：向上搜寻字符串</li>
<li><code>q</code>：退出文件内容显示</li>
</ul>
<p><strong>head / tail 命令选项：</strong></p>
<ul>
<li><p><code>-n</code>：后面跟数字，代表要显示多少行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">head testfile.txt		<span class="comment"># 默认显示 10 行</span></span><br><span class="line">head -n 20 testfile.txt	<span class="comment"># 显示 20 行</span></span><br><span class="line"></span><br><span class="line">tail testfile.txt		<span class="comment"># 默认显示 10 行</span></span><br><span class="line">tail -n 20 testfile.txt	<span class="comment"># 显示 20 行</span></span><br></pre></td></tr></table></figure>





</li>
</ul>
<blockquote>
<p>Linux 链接：</p>
<ul>
<li>硬链接（Hard Link）：B 是 A 的硬链接，则 B 和 A 指向同一个文件。</li>
<li>软链接（Symbolic Link）：C 是 A 的软链接，则 C 指向 A，A 指向文件。</li>
</ul>
</blockquote>
<h2 id="Vim-编辑器"><a href="#Vim-编辑器" class="headerlink" title="Vim 编辑器"></a>Vim 编辑器</h2><p>如何打开 Vim 编辑器：<code>vim filename</code></p>
<p>Vim 编辑器共有三种模式：</p>
<ul>
<li>命令模式（Command mode）</li>
<li>输入模式（Insert mode）</li>
<li>底线命令模式（Last line mode）</li>
</ul>
<p>进入 Vim 编辑器默认就是命令模式；</p>
<p>在命令模式下按 <code>i</code> 键进入输入模式，按 <code>Esc</code> 键退出输入模式；</p>
<p>在命令模式下按 <code>:</code> 键进入底线命令模式，按 <code>Esc</code> 键可以退出底线命令模式。</p>
<p>底线命令模式基本命令：</p>
<ul>
<li><code>:w</code> ：保存文件</li>
<li><code>:q</code> ：退出 Vim</li>
<li><code>:wq</code> ：保存文件并退出 Vim</li>
</ul>
<h2 id="Linux-中安装软件"><a href="#Linux-中安装软件" class="headerlink" title="Linux 中安装软件"></a>Linux 中安装软件</h2><p><strong>rpm 安装（以安装 JDK 为例）：</strong></p>
<ol>
<li><p>先使用 <code>java -version</code> 查看系统是否自带了 openJDK</p>
<p><img src="/images/Linux/image-20210418153200968.png" alt="image-20210418153200968"></p>
</li>
</ol>
<ol start="2">
<li><p>如果有，先使用 <code>rpm -qa|grep jdk</code> 找出来自带的 JDK</p>
<p><img src="/images/Linux/image-20210418153945051.png" alt="image-20210418153945051"></p>
</li>
</ol>
<ol start="3">
<li><p>把后缀为 <code>.x86_64</code> 的两个卸载（使用 <code>rpm -e --nodeps jdk名称</code>）</p>
<p><img src="/images/Linux/image-20210418154051891.png" alt="image-20210418154051891"></p>
<p><img src="/images/Linux/image-20210418154111013.png" alt="image-20210418154111013"></p>
</li>
</ol>
<ol start="4">
<li><p>再次使用 <code>java -version</code> 检查</p>
<p><img src="/images/Linux/image-20210418154453460.png" alt="image-20210418154453460"></p>
</li>
</ol>
<ol start="5">
<li>安装自己下载的 JDK（使用 <code>rpm -ivh jdk-8u271-linux-x64.rpm</code>）</li>
</ol>
<p><strong>压缩包安装（以安装 Tomcat 为例）：</strong></p>
<p>把 Tomcat 的压缩包用 Xftp 传到 <code>/home</code> 目录下，然后解压压缩包：</p>
<p><code>tar -zxvf apache-tomcat-9.0.31.tar.gz</code> </p>
<p>解压完成就相当于安装成功了（和 Windows 上面一样）</p>
<p><strong>yum 安装（以安装 docker 为例）：</strong></p>
<h2 id="Linux-防火墙"><a href="#Linux-防火墙" class="headerlink" title="Linux 防火墙"></a>Linux 防火墙</h2><p>CentOS 7 防火墙相关命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status firewalld.service				<span class="comment"># 查看防火墙状态</span></span><br><span class="line">systemctl stop firewalld.service				<span class="comment"># 临时关闭防火墙</span></span><br><span class="line">systemctl start firewalld.service				<span class="comment"># 临时打开防火墙</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld.service				<span class="comment"># 开机禁用防火墙</span></span><br><span class="line">systemctl <span class="built_in">enable</span> firewalld.service				<span class="comment"># 开机启用防火墙</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不加 --permanent 代表本次生效，重启Linux后失效</span></span><br><span class="line">firewall-cmd --list-ports						<span class="comment"># 查看防火墙当前开启的端口</span></span><br><span class="line">firewall-cmd --list-ports --permanent			<span class="comment"># 查看防火墙永久开启的端口</span></span><br><span class="line"></span><br><span class="line">firewall-cmd --add-port=3306/tcp				<span class="comment"># 临时打开 3306 端口</span></span><br><span class="line">firewall-cmd --add-port=3306/tcp --permanent	<span class="comment"># 永久打开 3306 端口</span></span><br><span class="line"></span><br><span class="line">firewall-cmd --remove-port=3306					<span class="comment"># 临时关闭 3306 端口</span></span><br><span class="line">firewall-cmd --remove-port=3306 --permanent		<span class="comment"># 永久关闭 3306 端口</span></span><br></pre></td></tr></table></figure>





<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service network restart						<span class="comment"># 重启网络</span></span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -nltp				<span class="comment"># 查看系统中的tcp进程和对应监听的端口</span></span><br></pre></td></tr></table></figure>

<p>netstat 命令：显示网络相关的信息，如网络连接，路由表，接口状态等</p>
<ul>
<li><code>-a</code>：显示所有选项，默认不显示 Listen 相关</li>
<li><code>-t</code>：仅显示 tcp 相关</li>
<li><code>-u</code>：仅显示 udp 相关</li>
<li><code>-n</code>：拒绝显示别名，能显示数字的就显示数字</li>
<li><code>-l</code>：仅显示 Linten 相关</li>
<li><code>-p</code>：显示建立相关连接的程序名</li>
<li><code>-r</code>：显示路由表</li>
<li><code>-e</code>：显示扩展信息，如 uid 等</li>
<li><code>-s</code>：按各个协议进行统计</li>
<li><code>-c</code>：每隔固定时间，执行该 netstat</li>
</ul>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表&amp;排序</title>
    <url>/2019/04/02/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8&amp;%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p><strong>快速排序</strong>非常重要，一定要烂熟于心！！！</p>
<a id="more"></a>

<p><img src="/images/%E5%93%88%E5%B8%8C%E8%A1%A8&%E6%8E%92%E5%BA%8F/4.2.jpg" alt="4.2"></p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="结构和特点"><a href="#结构和特点" class="headerlink" title="结构和特点"></a>结构和特点</h3><p>哈希表（hashtable）：也叫散列表</p>
<p><strong>结构：</strong>有很多种，最流行的是<strong>顺序表</strong>+<strong>链表</strong></p>
<p><strong>特点：</strong>快，<strong>很快</strong>，非常快</p>
<h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><p><strong>三步：</strong></p>
<ul>
<li>1、计算哈希码（hashcode，调用 <code>hashCode()</code> 方法获得）</li>
<li>2、计算在哈希表中的存储位置</li>
<li>3、存入哈希表</li>
</ul>
<p>存入哈希表中的数据<strong>唯一</strong>且<strong>无序</strong></p>
<h3 id="hashCode-和-equals-的作用"><a href="#hashCode-和-equals-的作用" class="headerlink" title="hashCode() 和 equals() 的作用"></a>hashCode() 和 equals() 的作用</h3><p><strong>hashCode()：</strong>获取哈希码，返回一个 <strong>int</strong>，根据哈希码计算出数据在哈希表中的存储位置</p>
<p><strong>equals()：</strong>添加或查询数据是需要使用 <code>equals()</code> 进行对比，判断是否有相同数据</p>
<h3 id="如何获取哈希码"><a href="#如何获取哈希码" class="headerlink" title="如何获取哈希码"></a>如何获取哈希码</h3><p><strong>int：</strong>调用 <code>hashCode()</code> 方法，其实就是取自身</p>
<p><strong>其他类型：</strong>调用默认的 <code>hashCode()</code> 方法获取</p>
<h3 id="如何减少冲突"><a href="#如何减少冲突" class="headerlink" title="如何减少冲突"></a>如何减少冲突</h3><p><strong>1、装填因子</strong>：</p>
<p>装填因子 = 表中的记录数 / 哈希表的长度</p>
<p>装填因子越小，发生冲突的可能性就越小</p>
<p>研究标明：当装填因子为 0.5 时，哈希表的性能达到最优</p>
<p><strong>因此，一般情况下，装填因子取 0.5</strong></p>
<hr>
<p><strong>2、哈希函数的选择</strong></p>
<p>直接定址法、平方取中法、折叠法、除留取余法等</p>
<hr>
<p><strong>3、处理冲突的方法</strong></p>
<p>链地址法、开放地址法、再散列法等</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="排序的分类"><a href="#排序的分类" class="headerlink" title="排序的分类"></a>排序的分类</h3><p><strong>1、内部排序和外部排序</strong></p>
<ul>
<li>内部排序：整个排序过程都在<strong>内存</strong>中进行。<em>本章介绍的排序都是内部排序</em></li>
<li>外部排序：数据量太大，无法全部放入内存，需要<strong>借助外存</strong>完成。</li>
</ul>
<p><strong>2、稳定排序和不稳定排序</strong></p>
<ul>
<li>稳定排序：排序完成后，相同关键字的<strong>前后</strong>相对位置<strong>没有发生变化</strong>。</li>
<li>不稳定排序：排序完成后，相同关键字的<strong>前后</strong>相对位置<strong>发生变化</strong>。</li>
</ul>
<p><strong>3、比较排序和非比较排序</strong></p>
<ul>
<li>比较排序：通过比较来判断大小，作为排序的依据。</li>
<li>非比较排序：不需要通过比较就能排序，如基数排序，计数排序。</li>
</ul>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><ul>
<li><p>比较排序</p>
<ul>
<li>插入排序<ul>
<li>直接插入排序（基本）</li>
<li>希尔排序（完善）</li>
</ul>
</li>
<li>选择排序<ul>
<li>直接选择排序（基本）</li>
<li>堆排序（完善）</li>
</ul>
</li>
<li>交换排序<ul>
<li>冒泡排序（基本）</li>
<li><strong>快速排序</strong>（完善）</li>
</ul>
</li>
<li>归并排序<ul>
<li>归并排序</li>
</ul>
</li>
</ul>
</li>
<li><p>非比较排序</p>
<ul>
<li>计数排序</li>
<li>基数排序</li>
</ul>
</li>
</ul>
<blockquote>
<p>建议先掌握：直接插入排序、直接选择排序、冒泡排序、快速排序</p>
</blockquote>
<h3 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h3><blockquote>
<p>定义（摘自百度百科）：</p>
<p>​        它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小、首字母从Z到A）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。</p>
</blockquote>
<p>时间复杂度：O(n2)</p>
<p>代码实现（ Java ）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对一个数组进行冒泡排序</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">    <span class="comment">// 每遍历一遍，则少循环一次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;arr.length-<span class="number">1</span>-i; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j]&lt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">            arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">            arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure>





<h3 id="快速排序（Quicksort）"><a href="#快速排序（Quicksort）" class="headerlink" title="快速排序（Quicksort）"></a>快速排序（Quicksort）</h3><blockquote>
<p>快速排序是冒泡排序的改进版，也是最好的一种内部排序，涉及分治和递归的思想，必须掌握</p>
</blockquote>
<p><strong>基本思想：</strong></p>
<ul>
<li>1、先从数列中取出一个数作为<strong>基准数</strong>（第一个数）</li>
<li>2、将比基准数小的放到它的左边，大于或等于它的放到右边（<strong>分区</strong>）</li>
<li>3、对左、右分区重复第一步、第二步，直到各区间只有一个数（<strong>递归</strong>）</li>
</ul>
<p><strong>代码实现:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 实现排序算法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span>[] quickSort(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)&#123;</span><br><span class="line">    <span class="comment">// 如果起点坐标大于等于终点坐标，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(begin&gt;=end)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = begin;</span><br><span class="line">    <span class="keyword">int</span> right = end;</span><br><span class="line">    <span class="keyword">int</span> pivot = arr[left];  <span class="comment">// 把第一个值设为基准 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right &amp;&amp; arr[right]&gt;=pivot)&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">            arr[left] = arr[right];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right &amp;&amp; arr[left]&lt;pivot)&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">            arr[right] = arr[left];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arr[left] = pivot;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 递归排序pivot左边的元素</span></span><br><span class="line">    quickSort(arr, begin, right-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 递归排序pivot右边的元素</span></span><br><span class="line">    quickSort(arr, right+<span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="排序总结"><a href="#排序总结" class="headerlink" title="排序总结"></a>排序总结</h3><p><img src="/images/%E5%93%88%E5%B8%8C%E8%A1%A8&%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.png" alt="排序算法"></p>
<p><strong>1、</strong>直接插入排序，直接选择排序，冒泡排序是三种最简单、最基本的排序，时间复杂度也最高（O(n<sup>2</sup>)）,三种都必须熟练掌握。</p>
<p><strong>2、</strong>快速排序和归并排序都使用了<strong>归并</strong>和<strong>递归</strong>的思想，面试时可能会被问到。</p>
<p><strong>3、</strong>在数据不大的情况下，从时间性能来看，快速排序时实际性能最优的排序算法。</p>
<p><strong>4、</strong>堆排序在任何情况下的时间复杂度都为 O(nlog<sub>2</sub>n)，在元素较多时是很有效的排序算法。</p>
<p><strong>5、</strong>基于<strong>比较</strong>的排序的时间复杂度下限是 <strong>Ω(nlog<sub>2</sub>n))</strong>，这已经是最高的效率了。</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>哈希表</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>查找</title>
    <url>/2019/04/01/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p><strong>查找</strong>和<strong>排序</strong>是数据结构中两个最重要的操作</p>
<a id="more"></a>

<p><img src="/images/%E6%9F%A5%E6%89%BE/4.1.jpg" alt="4.1"></p>
<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="一、线性表查找"><a href="#一、线性表查找" class="headerlink" title="一、线性表查找"></a>一、线性表查找</h2><h3 id="1、顺序查找"><a href="#1、顺序查找" class="headerlink" title="1、顺序查找"></a>1、顺序查找</h3><p><em>非常简单</em></p>
<p><strong>查找方法</strong>：逐个比较查询，如果找到，返回数据或者索引，如果没找到，返回 null</p>
<p>时间复杂度：T(n) = O(n)</p>
<h3 id="2、折半（二分）查找"><a href="#2、折半（二分）查找" class="headerlink" title="2、折半（二分）查找"></a>2、折半（二分）查找</h3><p>查找表进行折半查找必须满足<strong>两个条件</strong>：</p>
<ul>
<li>查找表必须使用<strong>顺序存储结构</strong></li>
<li>查找表必须按关键字大小<strong>有序排列</strong></li>
</ul>
<p>折半查找可以使用两种方式来实现：</p>
<ul>
<li><p><strong>非递归方式</strong></p>
<p>时间复杂度：T(n) = O(log<sub>2</sub>n)</p>
<p>空间复杂度：S(n) = O(1)</p>
</li>
</ul>
<ul>
<li><p><strong>递归方式</strong></p>
<p>时间复杂度：T(n) = O(log<sub>2</sub>n)</p>
<p>空间复杂度：S(n) = O(log<sub>2</sub>n)</p>
</li>
</ul>
<h2 id="二、查找树"><a href="#二、查找树" class="headerlink" title="二、查找树"></a>二、查找树</h2><p><strong>二叉查找树 BST</strong>（Binary Search Tree）：</p>
<p>或是一棵空树，</p>
<p>或是具有如下性质的二叉树：</p>
<ul>
<li>若它的左子树不为空，则左子树上的所有节点的值小于根节点的值</li>
<li>若它的右子树不为空，则右子树上的所有节点的值大于根节点的值</li>
<li>它的左、右子树也都为二叉查找树</li>
</ul>
<blockquote>
<p>对二叉查找树进行<strong>中序遍历</strong>，得到有序集合</p>
</blockquote>
<hr>
<p><strong>平衡二叉树</strong>（self-balance Binary Search Tree）:自平衡二叉查找树，又称 <strong>AVL 树</strong></p>
<p>或是一棵空树</p>
<p>或它的左、右子树的高度差（<strong>平衡因子（平衡度）</strong>）的绝对值不大于 1</p>
<p><strong>意义：</strong>减少二叉查找树层次，提高查找速度</p>
<hr>
<p><strong>红黑树</strong>（R-B Tree）：是一种平衡二叉树</p>
<p><strong>特性：</strong></p>
<ul>
<li>每个节点都有颜色，或是黑色，或是红色</li>
<li>根节点是黑色</li>
<li>每个叶子节点（null）是黑色</li>
<li>如果一个节点是红色的，那么它的子节点一定是黑色的</li>
<li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点</li>
</ul>
<p><img src="/images/%E6%9F%A5%E6%89%BE/%E7%BA%A2%E9%BB%91%E6%A0%91.jpg" alt="红黑树"></p>
<p><strong>应用：</strong></p>
<p>Java 集合中的 TreeSet 和 TreeMap 就是使用红黑二叉树实现的</p>
<hr>
<p><strong>B 树</strong>（Balance Tree）: 平衡树</p>
<p>平衡树可以降低树的深度，提高查找效率</p>
<p>B 树应<strong>文件系统</strong>的要求而发展起来的</p>
<p><img src="/images/%E6%9F%A5%E6%89%BE/B%E6%A0%91.jpg" alt="B树"></p>
<hr>
<p><strong>B+ 树：</strong></p>
<p>在 B 树的基础上，<strong>为叶子节点增加链表指针</strong>，所有关键字都在叶子节点中出现，非叶子节点只作为索引</p>
<p><strong>数据库的索引</strong>的默认结构采用的就是 B+ 树</p>
<p><img src="/images/%E6%9F%A5%E6%89%BE/B+%E6%A0%91.jpg" alt="B+树"></p>
<hr>
<p><strong>B* 树：</strong></p>
<p>B+ 树的变体，在<strong>非根和非叶子节点再增加执行兄弟的指针</strong></p>
<p><img src="/images/%E6%9F%A5%E6%89%BE/B%E6%98%9F%E6%A0%91.jpg" alt="B星树"></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title>图</title>
    <url>/2019/03/31/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/</url>
    <content><![CDATA[<p>图中最重要的操作就是求最短路径</p>
<a id="more"></a>

<p><img src="/images/%E5%9B%BE/3.31.jpg" alt="3.31"></p>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>1、基本概念</p>
<p>图（graph）是一种网状数据结构，图是由非空的顶点集合和一个描述顶点之间关系的集合组成。</p>
<p>图中的元素称为<strong>顶点</strong>，顶点之间的关系称为边（edge）</p>
<p>图分为<strong>有向图</strong>（单向）和<strong>无向图</strong>（双向）</p>
<p>实际应用中，图的每条边都有与它相关的实数，称为 <code>权</code>，带有权的图称为<strong>带权图</strong></p>
<p>2、图的存储</p>
<ul>
<li>顺序结构：邻接矩阵 –&gt; 二维数组</li>
<li>链表结构：邻接表 –&gt; 类似于HashMap的存储结构</li>
</ul>
<p>3、图的遍历</p>
<ul>
<li>深度优先遍历（DFS  deep-first search）：类似与树的先根遍历，可利用递归或非递归（借助栈）实现</li>
<li>广度优先遍历（BFS  breadth-first search）：类似于树的层次遍历，非递归（借助队列）实现</li>
</ul>
<p>4、最短路径</p>
<ul>
<li><p><strong>段数最少</strong>的最短路径：</p>
<p>生活案例：换乘最少</p>
<p>解决方案：使用<strong>广度优先搜索</strong></p>
</li>
<li><p><strong>权值最小</strong>的最短路径：</p>
<p>生活案例：时间最少，距离最短等</p>
<p>解决方案：使用<strong>狄克斯特拉</strong>算法</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2019/03/30/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>二叉树是最常见的一种树</p>
<a id="more"></a>

<p><img src="/images/%E4%BA%8C%E5%8F%89%E6%A0%91/3.30.png" alt="3.30"></p>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p><img src="/images/%E4%BA%8C%E5%8F%89%E6%A0%91/%E6%99%AE%E9%80%9A%E6%A0%91.jpg" alt="普通树"></p>
<h3 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h3><p>树是 n（n&gt;=0）个节点的有限集，</p>
<p>根据节点数量分为空树和非空树</p>
<p>树是一种非线性结构</p>
<h3 id="节点的度和树的度"><a href="#节点的度和树的度" class="headerlink" title="节点的度和树的度"></a>节点的度和树的度</h3><ul>
<li>节点拥有的子树的数目称为<strong>节点的度（degree）</strong></li>
<li>度为0的节点称为<strong>叶子节点（leaf）</strong>或<strong>终端节点</strong></li>
<li>度不为0的节点称为<strong>非终端节点</strong>或<strong>分支节点</strong>，除根之外的分支节点也称为<strong>内部节点</strong></li>
<li>树内<strong>节点的度的最大值</strong>称为<strong>树的度</strong></li>
</ul>
<h3 id="节点的层次和树的深度"><a href="#节点的层次和树的深度" class="headerlink" title="节点的层次和树的深度"></a>节点的层次和树的深度</h3><ul>
<li>节点的层次（level）：根节点的层次为 1</li>
<li>树的深度（depth）：节点的最大层次数</li>
</ul>
<h3 id="有序树、m-叉树、森林"><a href="#有序树、m-叉树、森林" class="headerlink" title="有序树、m 叉树、森林"></a>有序树、m 叉树、森林</h3><ul>
<li>考虑<strong>节点的左右顺序</strong>的树，称为<strong>有序树</strong>，否则称为<strong>无序树</strong>。</li>
<li>如不特别指明，一般讨论的是有序树</li>
<li>树的<strong>度为 m *<em>的树称为 *</em>m 叉树</strong></li>
<li><strong>森林（forest）</strong>是m（m&gt;=0）棵<strong>互不相交</strong>的树的集合</li>
</ul>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p><img src="/images/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91.jpg" alt="二叉树"></p>
<p>每个节点的度<strong>均不超过2</strong>的<strong>有序树</strong>，称为二叉树（binary tree）</p>
<ul>
<li>满二叉树：每一层节点都是满的二叉树</li>
<li>完全二叉树：在一颗满二叉树中，在最下层从最右侧去掉相邻的若干叶子节点，即得到完全二叉树</li>
</ul>
<h3 id="二叉树的一些重要性质"><a href="#二叉树的一些重要性质" class="headerlink" title="二叉树的一些重要性质"></a>二叉树的一些重要性质</h3><ul>
<li>对于任意一棵二叉树，其叶子节点数量为n<sub>0</sub>,其度为2的节点数量为 n<sub>2</sub>，则 n<sub>0</sub>-n<sub>2</sub>=1</li>
<li>二叉树的第 i 层最多有 2<sup>i-1</sup> 个节点（根是第一层）</li>
</ul>
<h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><ul>
<li><p>顺序存储结构</p>
<p>适用于满二叉树和完全二叉树，将其中的元素逐层存放到一维数组中，</p>
<p>可以通过公式很快的确定节点之间的关系</p>
</li>
<li><p>链式存储结构</p>
<p>对于一般的二叉树而言，顺序存储结构会造成<strong>空间的浪费</strong></p>
<p>所以使用链式存储结构</p>
<ul>
<li><p>每个节点设置 <strong>3 个域</strong>：数据域，左子域、右子域，这样形成的链表称为<strong>二叉链表</strong></p>
</li>
<li><p>每个节点设置 <strong>4 个域</strong>：数据域，左子域、右子域、父亲域，这样形成的链表称为<strong>三叉链表</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>遍历（traverse）： 按照某种次序访问树中的所有节点，且每个节点恰好访问一次。</p>
<p>树的遍历可以看成是人为的将<strong>非线性结构线性化</strong></p>
<p>二叉树的三种遍历方式：–<em>规定先遍历左子树，再遍历右子树</em>–</p>
<ul>
<li>先序(根)遍历：根  左子树  右子树</li>
<li>中序(根)遍历：左子树  根  右子树</li>
<li>后序(根)遍历：左子树  右子树  根</li>
</ul>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>线性表</title>
    <url>/2019/03/29/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<p>顺序表、链表、栈、队列其实都是线性表</p>
<a id="more"></a>

<p><img src="/images/%E7%BA%BF%E6%80%A7%E8%A1%A8/3.29.jpg" alt="3.29"></p>
<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p>线性表是 n 个<strong>类型相同</strong>的数据元素的<strong>有限序列</strong></p>
<ul>
<li>类型相同：每个元素占用相同的内存空间，查询定位非常方便</li>
<li>有限：线性表的长度是一个有限值</li>
<li>序列：除表头和表尾元素外，每个元素都有且仅有一个直接前驱和直接后继</li>
</ul>
<h3 id="1、顺序表"><a href="#1、顺序表" class="headerlink" title="1、顺序表"></a>1、顺序表</h3><p><img src="/images/%E7%BA%BF%E6%80%A7%E8%A1%A8/%E9%A1%BA%E5%BA%8F%E8%A1%A8.png" alt="顺序表"></p>
<p>特点：在内存中分配连续的空间，只存储数据，不存储地址<br>优点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 查询效率高</span><br><span class="line">- 空间占用小</span><br></pre></td></tr></table></figure>

<p>缺点：<br>    - 增删效率低<br>    - 必须提前分配确定的空间，如果存储数据少，可能造成空间浪费</p>
<h3 id="2、单链表"><a href="#2、单链表" class="headerlink" title="2、单链表"></a>2、单链表</h3><p><img src="/images/%E7%BA%BF%E6%80%A7%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8.png" alt="单链表"></p>
<p>特点：</p>
<ul>
<li>在内存中存储不连续，每个节点同时存储数据和指针</li>
<li>只能通过前驱节点找到后续节点，无法通过后续节点找到前驱节点</li>
</ul>
<p>优点：<br>    - 增删效率高<br>    - 有元素的时候才分配节点，没有空间浪费</p>
<p>缺点：<br>    - 查询效率低<br>    - 因为每个节点都需要存储指针，空间占用大</p>
<h2 id="一、顺序表"><a href="#一、顺序表" class="headerlink" title="一、顺序表"></a>一、顺序表</h2><p>存储结构为顺序结构，典型应用为ArrayList</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自己实现简单的ArrayList功能</span></span><br></pre></td></tr></table></figure>



<h2 id="二、链表"><a href="#二、链表" class="headerlink" title="二、链表"></a>二、链表</h2><p>存储结构为链式结构，分为单链表和双向链表，<br>双向链表：LinkedList</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自己实现简单的SingleLinkedList --&gt; 单链表</span></span><br></pre></td></tr></table></figure>



<h2 id="三、栈"><a href="#三、栈" class="headerlink" title="三、栈"></a>三、栈</h2><p>栈（stack）又称堆栈，是<strong>运算受限</strong>的<strong>线性表</strong></p>
<p>限制是：仅允许在栈的一端进行插入和删除操作，不允许在其他位置进行插入、查找、删除操作。</p>
<p>可以进行操作的一端是栈顶（top），另一端叫栈底（bottom）</p>
<p>重要特性：后进栈的元素先出栈，故堆栈简称<strong>后进先出表</strong>（Last In First Out –&gt;LIFO）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Stack</span></span>&#123;</span><br><span class="line">    <span class="comment">// 返回堆栈的大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断堆栈是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据元素 e 入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(object e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈顶元素出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="四、队列"><a href="#四、队列" class="headerlink" title="四、队列"></a>四、队列</h2><p>队列（queue）简称队，同样是一种<strong>运算受限</strong>的<strong>线性表</strong></p>
<p>限制是：仅允许在一端（<strong>队尾–&gt;rear</strong>）进行插入，在另一端（<strong>队首–&gt;front</strong>）进行删除</p>
<p>重要特性：先入队的先出队。故队列简称<strong>先进先出表</strong>（First In First Out–&gt;FIFO）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span></span>&#123;</span><br><span class="line">    <span class="comment">// 返回队列的大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断队列是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据元素 e 入队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(object e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队首元素出队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">dequeue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取队首元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="五、双端队列"><a href="#五、双端队列" class="headerlink" title="五、双端队列"></a>五、双端队列</h2><p><strong>双端队列 deque</strong>（double ended queue）<em>音：deck</em></p>
<p>顾名思义：队列的两端都可以进行入队和出队的操作</p>
<p>栈和队列都可以用双端队列实现</p>
<h2 id="六、Java-中的栈和队列类"><a href="#六、Java-中的栈和队列类" class="headerlink" title="六、Java 中的栈和队列类"></a>六、Java 中的栈和队列类</h2><p>Queue: 队列接口</p>
<p>Deque: 双端队列接口（栈操作时使用）</p>
<p>实现类：LinkedList，栈和队列操作都用这个</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>反射</title>
    <url>/2019/03/29/Java/1.Java%E5%9F%BA%E7%A1%80/%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<p>反射是实现 Java 动态性的方法之一</p>
<a id="more"></a>



<p><strong>概念：</strong>将类的组成部分封装为其他对象，这就是反射</p>
<p><strong>好处：</strong></p>
<ul>
<li>在程序运行过程中，可以动态的操作这些对象（成员属性、构造方法、成员方法等）</li>
<li>可以解耦，提高程序的可扩展性</li>
</ul>
<h3 id="获取-Class-对象的方法："><a href="#获取-Class-对象的方法：" class="headerlink" title="获取 Class 对象的方法："></a>获取 Class 对象的方法：</h3><p>1、通过 Class 的 forName() 方法获取</p>
<ul>
<li><code>Class clazz = Class.forName(&quot;包名.类名&quot;);</code></li>
</ul>
<p>2、通过类的 class 静态成员变量获取</p>
<ul>
<li><code>Class clazz = 类名.class;</code></li>
</ul>
<p>3、通过对象的 getClass() 方法获取</p>
<ul>
<li><code>Class clazz = 对象名.getClass();</code></li>
</ul>
<h3 id="通过-Class-对象，获取类的信息（类名，属性，构造器，方法等）"><a href="#通过-Class-对象，获取类的信息（类名，属性，构造器，方法等）" class="headerlink" title="通过 Class 对象，获取类的信息（类名，属性，构造器，方法等）"></a>通过 Class 对象，获取类的信息（类名，属性，构造器，方法等）</h3><p>1、<strong>类名</strong>相关</p>
<ul>
<li><code>public String getName()</code> –&gt; 获取 包名+类名</li>
<li><code>public String getSimpleName()</code> –&gt; 仅获取类名</li>
</ul>
<p>2、<strong>成员变量</strong>相关</p>
<ul>
<li><p><code>public Field getField(&quot;成员变量名&quot;)</code> –&gt; 指定名称，获取 public 成员变量</p>
</li>
<li><p><code>public Field[] getFields()</code> –&gt; 获取所有 public 成员变量</p>
</li>
</ul>
<ul>
<li><p><code>public Field getDeclaredField(&quot;成员变量名&quot;)</code> –&gt; 指定名称，获取成员变量</p>
</li>
<li><p><code>public Field[] getDeclaredFields()</code> –&gt; 获取所有成员变量</p>
</li>
</ul>
<p>3、<strong>构造方法</strong>相关</p>
<ul>
<li><code>public Constructor getConstructor(参数...)</code> –&gt; 指定参数，获取 public 构造方法</li>
<li><code>public Constructor[] getConstructors()</code> –&gt; 获取所有 public 构造方法</li>
</ul>
<ul>
<li><code>public Constructor getDeclaredConstructor(参数...)</code> –&gt; 指定参数，获取构造方法</li>
<li><code>public Constructor[] getDeclaredConstrustors()</code> –&gt; 获取所有构造方法</li>
</ul>
<p>4、<strong>成员方法</strong>相关</p>
<ul>
<li><code>getMethod(&quot;方法名&quot;,参数)</code> –&gt; 指定方法名和参数，获取 public 成员方法</li>
<li><code>getMethods()</code> –&gt; 获取所有 public 成员方法</li>
</ul>
<ul>
<li><code>getDeclaredMethod(&quot;方法名&quot;,参数)</code> –&gt; 指定方法名和参数，获取成员方法</li>
<li><code>getDeclaredMethods()</code> –&gt; 获取所有成员方法</li>
</ul>
<blockquote>
<p><strong>使用反射创建对象：</strong></p>
<p>1、通过 Class 对象创建(调用类的无参构造) –&gt; <code>clazz.newInstance()</code></p>
<p>2、通过 Constructor 对象创建(可调用无参，也可调用有参构造) –&gt; <code>constructor.newInstance(...)</code></p>
<p><strong>获取到方法后执行方法：</strong></p>
<p><code>method.invoke(对象名, 参数...)</code></p>
<p><strong>暴力反射：</strong></p>
<p><code>setAccessible(true)</code> –&gt; 可将（成员变量/构造方法/成员方法）设置为不需要做安全检查，直接可以访问。</p>
</blockquote>
<h3 id="测试反射-API-动态操作：构造器、方法、属性"><a href="#测试反射-API-动态操作：构造器、方法、属性" class="headerlink" title="测试反射 API 动态操作：构造器、方法、属性"></a>测试反射 API 动态操作：构造器、方法、属性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	String path = <span class="string">"test01.User"</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 通过 forName 方法创建 Class 对象</span></span><br><span class="line">		Class&lt;User&gt; clazz = (Class&lt;User&gt;) Class.forName(path);</span><br><span class="line">		<span class="comment">// 通过 Class对象 创建 User类的对象</span></span><br><span class="line">		User u1 = clazz.newInstance(); <span class="comment">// 其实是调用了User的无参构造器，所以JavaBean必须要有无参构造器</span></span><br><span class="line">		</span><br><span class="line">		Constructor&lt;User&gt; c = clazz.getDeclaredConstructor(<span class="keyword">int</span><span class="class">.<span class="keyword">class</span>,<span class="title">int</span>.<span class="title">class</span>,<span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">		User u2 = c.newInstance(<span class="number">1001</span>,<span class="number">22</span>,<span class="string">"小强"</span>); <span class="comment">// 调用有参构造器创建对象</span></span><br><span class="line">		System.out.println(u2.getUname());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 通过反射API调用普通方法</span></span><br><span class="line">		User u3 = clazz.newInstance();</span><br><span class="line">		Method m = clazz.getDeclaredMethod(<span class="string">"setUname"</span>,String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		m.invoke(u3, <span class="string">"小明"</span>); <span class="comment">// 激活该方法，传入对象及参数</span></span><br><span class="line">		System.out.println(u3.getUname());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 通过反射API操作属性</span></span><br><span class="line">		User u4 = clazz.newInstance();</span><br><span class="line">		Field f = clazz.getDeclaredField(<span class="string">"uname"</span>);</span><br><span class="line">		f.setAccessible(<span class="keyword">true</span>); <span class="comment">// 将属性设置为不需要做安全检查，直接可以访问。</span></span><br><span class="line">		f.set(u4, <span class="string">"小红"</span>); <span class="comment">// 通过反射直接写属性的值</span></span><br><span class="line">		</span><br><span class="line">		System.out.println(u4.getUname());</span><br><span class="line">		System.out.println(f.get(u4)); <span class="comment">// 通过反射直接读属性的值</span></span><br><span class="line">		</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反射效率问题"><a href="#反射效率问题" class="headerlink" title="反射效率问题"></a>反射效率问题</h3><p>反射是一把双刃剑，在<strong>提升了编程灵活性</strong>的同时<strong>降低了程序运行效率</strong></p>
<blockquote>
<p>通过 <code>setAccessible(boolean flag)</code> 来设置是否要进行访问安全检查<br>关闭访问安全检查可以比较大的提高程序运行的效率</p>
</blockquote>
]]></content>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法基本概念</title>
    <url>/2019/03/28/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>数据结构是计算机存储、组织数据的方式</p>
<p>算法是计算机解题的过程</p>
<a id="more"></a>

<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/3.28.jpg" alt="3.28"></p>
<h2 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h2><ul>
<li>逻辑结构<ul>
<li>线性结构（线性表、栈、队列、串、数组）</li>
<li>非线性结构（树、图）</li>
</ul>
</li>
<li>物理（存储）结构<ul>
<li>顺序结构</li>
<li>链表结构</li>
<li>索引结构</li>
<li>散列结构</li>
</ul>
</li>
<li>数据运算<ul>
<li>插入</li>
<li>删除</li>
<li>修改</li>
<li>查询</li>
<li>排序</li>
</ul>
</li>
</ul>
<blockquote>
<p>逻辑结构唯一<br>存储结构不唯一<br>运算的实现依赖与存储结构</p>
</blockquote>
<h2 id="二、算法"><a href="#二、算法" class="headerlink" title="二、算法"></a>二、算法</h2><p>算法是计算机解题的过程</p>
<p>算法优劣的评判依据：<strong>时间复杂度</strong>和<strong>空间复杂度</strong></p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p><strong>1、</strong>时间复杂度是表示<strong>问题的规模</strong>而不是指算法具体的运行时间或者<em>运行次数</em>（时间频度）<br><strong>2、</strong>时间复杂度的表示：T(n) = O(f(n))<br><strong>3、</strong>时间复杂度一般有<strong>最坏时间复杂度</strong>和<strong>平均时间复杂度</strong><br><strong>4、</strong>我们一般讨论的是<strong>最坏时间复杂度</strong></p>
<p><strong>5、</strong>时间复杂度的计算</p>
<ul>
<li>找出算法中的基本语句（执行次数最多的语句就是基本语句）</li>
<li>计算基本语句执行次数的数量级</li>
<li>将求得的数量级放入O()中</li>
</ul>
<p><strong>6、</strong>常见的时间复杂度</p>
<ul>
<li>常数阶 O(1)</li>
<li>对数阶 O(log<sub>2</sub>n)</li>
<li>线性阶 O(n)</li>
<li>线性对数阶 O(n*log<sub>2</sub>n)</li>
<li>平方阶 O(n<sup>2</sup>)</li>
<li>立方阶 O(n<sup>3</sup>)</li>
<li>…</li>
<li>k次方阶 O(n<sup>k</sup>)</li>
<li>指数阶 O(2<sup>n</sup>)</li>
<li>阶乘阶 O(n!    )</li>
</ul>
<blockquote>
<p>上面的时间复杂度级别，执行效率越来越低</p>
</blockquote>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>S(n) = O(g(n))<br>空间复杂度比时间复杂度分析要少；<br>在使用递归时算法的空间复杂度会比较高</p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>注解</title>
    <url>/2019/03/28/Java/1.Java%E5%9F%BA%E7%A1%80/%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p>注解和注释有相似之处，但也有比较大的差别</p>
<a id="more"></a>



<h2 id="注解-Annotation"><a href="#注解-Annotation" class="headerlink" title="注解 - Annotation"></a>注解 - Annotation</h2><blockquote>
<p>注解本质上就是一个接口，该接口默认继承 Annotation 接口</p>
</blockquote>
<p>1、注解的作用</p>
<ul>
<li>不是程序本身，可以对程序进行解释</li>
<li>可以被其他程序读取</li>
</ul>
<p>2、注解的格式</p>
<blockquote>
<p>@注解名</p>
</blockquote>
<p>3、注解的使用范围<br>package、class、method、field</p>
<p>4、内置注解</p>
<ul>
<li><code>@Override</code> –&gt; 该注解只适用于修饰方法，表示该方法重写了父类(或接口)的方法</li>
<li><code>@Deprecated</code> –&gt; 该注解可用于修饰方法、属性、类，表示不推荐使用这样的元素</li>
<li><code>@SuppressWarnings</code> –&gt; 用来抑制编译时的警告信息</li>
</ul>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p>定义<strong>关键字</strong>：<code>@interface</code> </p>
<p><strong>属性</strong>：注解中的抽象方法</p>
<ul>
<li><p>由于注解是接口，所以注解内可以定义 抽象方法</p>
<p>在注解内，抽象方法又被称为属性</p>
</li>
<li><p>抽象方法（属性）的返回值类型仅可为以下几种：</p>
<ul>
<li>基本数据类型</li>
<li>String </li>
<li>枚举</li>
<li>注解</li>
<li>以上类型的数组</li>
</ul>
</li>
<li><p>定义了属性，在使用时需要对属性进行赋值</p>
<ul>
<li>如果定义属性时，使用 default 关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值</li>
<li>如果<strong>只有一个</strong>属性需要赋值，并且属性的名称是 <strong>value</strong>，则 value 可以省略，直接定义值即可</li>
<li>数组赋值时，值使用 <code>{}</code> 包裹。如果数组中只有一个值，则 <code>{}</code> 可以省略</li>
</ul>
</li>
</ul>
<p><strong>元注解：</strong></p>
<ul>
<li><p><strong>@Target</strong>：表示注解可以修饰的范围</p>
<ul>
<li>PACKAGE –&gt; 包</li>
<li>TYPE –&gt; 类、接口、枚举、注解</li>
<li>CONSTRUCTOR –&gt; 构造器</li>
<li>FIELD –&gt; 域</li>
<li>METHOD –&gt; 方法</li>
<li>LOCAL_VARIABLE –&gt; 局部变量</li>
<li>PRARMETER –&gt; 参数</li>
</ul>
</li>
<li><p><strong>@Retention</strong>：描述注解的生命周期</p>
<ul>
<li>SOURCE –&gt; 在源文件中有效</li>
<li>CLASS –&gt; 在 class 文件中有效</li>
<li>RUNTIME –&gt; 在运行时有效</li>
</ul>
</li>
<li><p><strong>@Documented</strong>：描述注解是否被抽取到 API 文档中</p>
</li>
<li><p><strong>@Inherited</strong>：描述注解是否被子类继承</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(value=&#123;ElementType.METHOD,ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="使用反射机制读取注解"><a href="#使用反射机制读取注解" class="headerlink" title="使用反射机制读取注解"></a>使用反射机制读取注解</h2><blockquote>
<p>只有将注解读取出来，注解才有实际的使用意义。</p>
</blockquote>
]]></content>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>Junit</title>
    <url>/2019/03/27/Java/1.Java%E5%9F%BA%E7%A1%80/Junit/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="Junit-单元测试"><a href="#Junit-单元测试" class="headerlink" title="Junit 单元测试"></a>Junit 单元测试</h2><p>测试分类：</p>
<ul>
<li>黑盒测试：不需要写代码，只关心输入输出值</li>
<li>白盒测试：需要写代码，关心程序的具体执行流程</li>
</ul>
<p>使用 junit 的方法：</p>
<ul>
<li>给需要测试的方法加上 <code>@Test</code></li>
<li>导入 junit 依赖环境</li>
</ul>
<p>使用断言操作来处理结果：<br><code>Assert.assertEquals(期望的结果,运算的结果);</code></p>
<p>补充：</p>
<ul>
<li>@Before:<ul>
<li>修饰的方法会在测试方法之前被自动执行</li>
</ul>
</li>
<li>@After:<ul>
<li>修饰的方法会在测试方法执行之后自动被执行</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>junit</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程</title>
    <url>/2019/03/18/Java/1.Java%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>网络编程基本概念</p>
<a id="more"></a>



<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="网络上不同层次的定位方式"><a href="#网络上不同层次的定位方式" class="headerlink" title="网络上不同层次的定位方式"></a>网络上不同层次的定位方式</h3><ul>
<li>网络上的每个节点（电脑/手机）–&gt; IP 定位</li>
<li>电脑上的每个软件 –&gt; 端口 定位</li>
<li>软件中的资源 –&gt; URL 定位</li>
</ul>
<h3 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h3><ul>
<li>TCP –&gt; 需要建立连接，效率较低，安全性高</li>
<li>UDP –&gt; 不需要建立连接，效率较高，安全性低</li>
</ul>
<h3 id="B-S-amp-C-S"><a href="#B-S-amp-C-S" class="headerlink" title="B/S &amp; C/S"></a>B/S &amp; C/S</h3><ul>
<li>B/S –&gt; 范围广，协议统一，传输速率慢</li>
<li>C/S –&gt; 范围小，协议自定，传输速率块</li>
</ul>
<h3 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h3><p>OSI（Open System Interconnect）：开放系统互连参考模型<br>OSI 将网络分为 7 层：</p>
<ul>
<li>应用层</li>
<li>表示层</li>
<li>会话层</li>
<li>传输层</li>
<li>网络层</li>
<li>数据链路层</li>
<li>物理层</li>
</ul>
<h2 id="Java-为-IP、端口、URL-提供的类"><a href="#Java-为-IP、端口、URL-提供的类" class="headerlink" title="Java 为 IP、端口、URL 提供的类"></a>Java 为 IP、端口、URL 提供的类</h2><h3 id="IP-–-gt-InetAdderss"><a href="#IP-–-gt-InetAdderss" class="headerlink" title="IP –&gt; InetAdderss"></a>IP –&gt; InetAdderss</h3><p>InetAddress 类没有构造器，用 <code>getLocalHost()</code> / <code>getByName(String host)</code> 等静态方法创建对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">	InetAddress addr = InetAddress.getLocalHost();</span><br><span class="line">	System.out.println(addr.getHostAddress());</span><br><span class="line">	System.out.println(addr.getHostName());</span><br><span class="line">	</span><br><span class="line">	System.out.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">	</span><br><span class="line">	InetAddress addr2 = InetAddress.getByName(<span class="string">"www.shsxt.com"</span>);</span><br><span class="line">	System.out.println(addr2.getHostAddress());</span><br><span class="line">	System.out.println(addr2.getHostName());</span><br><span class="line">	</span><br><span class="line">	System.out.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">	</span><br><span class="line">	InetAddress addr3 = InetAddress.getByName(<span class="string">"123.56.138.186"</span>);</span><br><span class="line">	System.out.println(addr3.getHostAddress());</span><br><span class="line">	System.out.println(addr3.getHostName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="端口-–-gt-InetSocketAddress"><a href="#端口-–-gt-InetSocketAddress" class="headerlink" title="端口 –&gt; InetSocketAddress"></a>端口 –&gt; InetSocketAddress</h3><p>端口范围（不同协议的端口可以冲突）：</p>
<ul>
<li>TCP：0 ~ 65535</li>
<li>UDP：0 ~ 65535<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InetSocketAddress socketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>,<span class="number">9000</span>);</span><br><span class="line">System.out.println(socketAddress.getAddress()); <span class="comment">// 返回地址</span></span><br><span class="line">System.out.println(socketAddress.getPort()); <span class="comment">// 返回端口</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="URL-–-gt-URL"><a href="#URL-–-gt-URL" class="headerlink" title="URL –&gt; URL"></a>URL –&gt; URL</h3><ul>
<li>URI(Universal Resource Identifier) –&gt; 统一资源标志符</li>
<li>URL(Universal Recource Locator) –&gt; 统一资源定位符</li>
<li>URN(Universal Recource Name) –&gt; 统一资源名称</li>
</ul>
<p>UR L由 4 部分组成：<br>例：<code>http://www.google.com:80/index.html</code></p>
<ul>
<li>协议</li>
<li>存放资源的主机域名</li>
<li>端口号</li>
<li>资源文件名</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	URL url = <span class="keyword">new</span> URL(<span class="string">"https://m.baidu.com/?from=2001a"</span>);</span><br><span class="line">	System.out.println(url.getProtocol()); <span class="comment">// 获取协议</span></span><br><span class="line">	System.out.println(url.getHost()); <span class="comment">// 获取主机名称</span></span><br><span class="line">	System.out.println(url.getPort()); <span class="comment">// 获取端口</span></span><br><span class="line">	System.out.println(url.getFile()); <span class="comment">// 获取资源名称</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="UDP-使用的基本步骤"><a href="#UDP-使用的基本步骤" class="headerlink" title="UDP 使用的基本步骤"></a>UDP 使用的基本步骤</h1><h2 id="发送端"><a href="#发送端" class="headerlink" title="发送端"></a>发送端</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UDP使用基本步骤：发送端</span></span><br><span class="line"><span class="comment"> * 1、使用DatagramSocket 指定端口，创建发送端</span></span><br><span class="line"><span class="comment"> * 2、准备数据，转成字节数组</span></span><br><span class="line"><span class="comment"> * 3、将字节数组封装成DatagramPacket 包裹</span></span><br><span class="line"><span class="comment"> * 4、发送包裹send(DatagramPacket p)</span></span><br><span class="line"><span class="comment"> * 5、释放资源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pikachu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPSendTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"发送端启动中。。。。。。。"</span>);</span><br><span class="line">		<span class="comment">// 1、使用DatagramSocket 指定端口，创建发送端</span></span><br><span class="line">		DatagramSocket client = <span class="keyword">new</span> DatagramSocket(<span class="number">6666</span>);</span><br><span class="line">		<span class="comment">// 2、准备数据，转成字节数组</span></span><br><span class="line">		String s = <span class="string">"你好，朋友"</span>;</span><br><span class="line">		<span class="keyword">byte</span>[] datas = s.getBytes();</span><br><span class="line">		<span class="comment">// 3、将字节数组封装成DatagramPacket 包裹</span></span><br><span class="line">		DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(datas,<span class="number">0</span>,datas.length,<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">8888</span>));</span><br><span class="line">		<span class="comment">// 4、发送包裹send(DatagramPacket p)</span></span><br><span class="line">		client.send(packet);</span><br><span class="line">		<span class="comment">// 5、释放资源</span></span><br><span class="line">		client.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接收端"><a href="#接收端" class="headerlink" title="接收端"></a>接收端</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UDP使用基本步骤：接收端</span></span><br><span class="line"><span class="comment"> * 1、使用DatagramSocket 指定端口创建接收端</span></span><br><span class="line"><span class="comment"> * 2、准备容器，封装成DatagramPacket</span></span><br><span class="line"><span class="comment"> * 3、阻塞式接收receive(DatagramPacket p)</span></span><br><span class="line"><span class="comment"> * 4、分析数据：</span></span><br><span class="line"><span class="comment"> * 			getData()</span></span><br><span class="line"><span class="comment"> * 			getlength()</span></span><br><span class="line"><span class="comment"> * 5、释放资源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pikachu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPReceiveTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"接收方启动中。。。。。。。。。。"</span>);</span><br><span class="line">		<span class="comment">// 1、使用DatagramSocket 指定端口创建接收端</span></span><br><span class="line">		DatagramSocket sever = <span class="keyword">new</span> DatagramSocket(<span class="number">8888</span>);</span><br><span class="line">		<span class="comment">// 2、准备容器，封装成DatagramPacket</span></span><br><span class="line">		<span class="keyword">byte</span>[] datas = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">60</span>];</span><br><span class="line">		DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(datas,<span class="number">0</span>,datas.length);</span><br><span class="line">		<span class="comment">// 3、阻塞式接收receive</span></span><br><span class="line">		sever.receive(packet);</span><br><span class="line">		<span class="comment">// 4、分析数据：</span></span><br><span class="line">		<span class="comment">// 		getData</span></span><br><span class="line">		<span class="comment">// 		getlength</span></span><br><span class="line">		<span class="keyword">byte</span>[] b = packet.getData();</span><br><span class="line">		System.out.println(<span class="keyword">new</span> String(b,<span class="number">0</span>,b.length));</span><br><span class="line">		<span class="comment">// 5、释放资源</span></span><br><span class="line">		sever.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="TCP操作的基本步骤"><a href="#TCP操作的基本步骤" class="headerlink" title="TCP操作的基本步骤"></a>TCP操作的基本步骤</h1><h2 id="客户端："><a href="#客户端：" class="headerlink" title="客户端："></a>客户端：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCP编程：</span></span><br><span class="line"><span class="comment"> * 创建客户端Client</span></span><br><span class="line"><span class="comment"> * 1、建立连接：使用Socket创建客户端，指定服务器的IP和端口</span></span><br><span class="line"><span class="comment"> * 2、操作：输入输出流</span></span><br><span class="line"><span class="comment"> * 3、释放资源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pikachu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException, IOException </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"-----Client------"</span>);</span><br><span class="line">		<span class="comment">// 1、使用Socket创建客户端，指定IP和端口</span></span><br><span class="line">		Socket client = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>,<span class="number">8888</span>);</span><br><span class="line">		<span class="comment">// 2、操作：输入输出流</span></span><br><span class="line">		DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(client.getOutputStream());</span><br><span class="line">		String msc = <span class="string">"hello"</span>;</span><br><span class="line">		dos.writeUTF(msc);</span><br><span class="line">		dos.flush();</span><br><span class="line">		<span class="comment">// 3、释放资源	</span></span><br><span class="line">		dos.close();</span><br><span class="line">		client.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCP编程：</span></span><br><span class="line"><span class="comment"> * 创建服务器</span></span><br><span class="line"><span class="comment"> * 1、指定端口，使用SeverSocket创建服务器</span></span><br><span class="line"><span class="comment"> * 2、阻塞式等待连接 accept</span></span><br><span class="line"><span class="comment"> * 3、操作：输入输出流</span></span><br><span class="line"><span class="comment"> * 4、释放资源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pikachu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"-----Server------"</span>);</span><br><span class="line">		<span class="comment">// 1、指定端口，使用SeverSocket创建服务器</span></span><br><span class="line">		ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">		<span class="comment">// 2、阻塞式等待连接 accept</span></span><br><span class="line">		Socket client = server.accept();</span><br><span class="line">		System.out.println(<span class="string">"一个客户端建立了连接"</span>);</span><br><span class="line">		<span class="comment">// 3、操作：输入输出流</span></span><br><span class="line">		DataInputStream dis = <span class="keyword">new</span> DataInputStream(client.getInputStream());</span><br><span class="line">		String msc = dis.readUTF();</span><br><span class="line">		System.out.println(msc);</span><br><span class="line">		<span class="comment">// 4、释放资源</span></span><br><span class="line">		dis.close();</span><br><span class="line">		client.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="网络聊天室"><a href="#网络聊天室" class="headerlink" title="网络聊天室"></a>网络聊天室</h1><blockquote>
<p>一个可以实现群聊的网络聊天室</p>
</blockquote>
<h2 id="服务器-1"><a href="#服务器-1" class="headerlink" title="服务器"></a>服务器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现群聊</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pikachu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiChat</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 在服务器上创建容器</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> CopyOnWriteArrayList&lt;Channel&gt; all = <span class="keyword">new</span> CopyOnWriteArrayList&lt;Channel&gt;();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"-----Server------"</span>);</span><br><span class="line">		<span class="comment">// 1、指定端口，使用SeverSocket创建服务器</span></span><br><span class="line">		ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 2、阻塞式等待连接 accept</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			Socket client = server.accept();</span><br><span class="line">			System.out.println(<span class="string">"一个客户端建立了连接"</span>);</span><br><span class="line">			<span class="comment">// 将每一个客户端的连接放进容器</span></span><br><span class="line">			Channel c = <span class="keyword">new</span> Channel(client);</span><br><span class="line">			all.add(c);</span><br><span class="line">			<span class="keyword">new</span> Thread(c).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Channel</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> DataInputStream dis;</span><br><span class="line">		<span class="keyword">private</span> DataOutputStream dos;</span><br><span class="line">		<span class="keyword">private</span> Socket client;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">boolean</span> isRunning;</span><br><span class="line">		<span class="keyword">private</span> String name;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Channel</span><span class="params">(Socket client)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.client = client;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				dis = <span class="keyword">new</span> DataInputStream(client.getInputStream());</span><br><span class="line">				dos = <span class="keyword">new</span> DataOutputStream(client.getOutputStream());</span><br><span class="line">				<span class="keyword">this</span>.name = receive();</span><br><span class="line">				isRunning = <span class="keyword">true</span>;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">				System.out.println(<span class="string">"----1----"</span>);</span><br><span class="line">				release();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 接收消息</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			String msg = <span class="string">""</span>;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				msg = dis.readUTF();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				System.out.println(<span class="string">"----2----"</span>);</span><br><span class="line">				release();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> msg;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 发送消息</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				dos.writeUTF(msg);</span><br><span class="line">				dos.flush();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				System.out.println(<span class="string">"----3----"</span>);</span><br><span class="line">				release();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 将消息发给别人</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendOthers</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">for</span>(Channel other:all) &#123;</span><br><span class="line">				<span class="keyword">if</span>(other == <span class="keyword">this</span>) &#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				other.send(<span class="keyword">this</span>.name+<span class="string">"说:"</span>+msg);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 释放资源</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.isRunning = <span class="keyword">false</span>;</span><br><span class="line">			SxtUtils.close(dis,dos,client);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">while</span>(isRunning) &#123;</span><br><span class="line">				String msg = receive();</span><br><span class="line">				<span class="keyword">if</span>(!msg.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">					sendOthers(msg);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			release();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟网络群聊</span></span><br><span class="line"><span class="comment"> * 客户端</span></span><br><span class="line"><span class="comment"> * 实现多个客户消息的接收与发送</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pikachu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiClient</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException, IOException </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"-----Client------"</span>);</span><br><span class="line">		BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">		System.out.println(<span class="string">"请输入您的姓名："</span>);</span><br><span class="line">		String name = br.readLine();</span><br><span class="line">		<span class="comment">// 1、使用Socket创建客户端，指定IP和端口</span></span><br><span class="line">		Socket client = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>,<span class="number">8888</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> ClientSend(client,name)).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> ClientReceive(client)).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端发送"><a href="#客户端发送" class="headerlink" title="客户端发送"></a>客户端发送</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端的发送方法 封装</span></span><br><span class="line"><span class="comment"> * 加入多线程，实现读写同步进行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pikachu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientSend</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> BufferedReader reader;</span><br><span class="line">	<span class="keyword">private</span> DataOutputStream dos;</span><br><span class="line">	<span class="keyword">private</span> Socket client;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> isRunning;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ClientSend</span><span class="params">(Socket client,String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.client = client;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">			dos = <span class="keyword">new</span> DataOutputStream(client.getOutputStream());</span><br><span class="line">			<span class="keyword">this</span>.send(<span class="keyword">this</span>.name);</span><br><span class="line">			isRunning = <span class="keyword">true</span>;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">"====1===="</span>);</span><br><span class="line">			release();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 发送消息</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			dos.writeUTF(msg);</span><br><span class="line">			dos.flush();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">"====3===="</span>);</span><br><span class="line">			release();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 从控制台获取输入</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">getStrFromConsole</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> reader.readLine();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(isRunning) &#123;</span><br><span class="line">			String msg = <span class="keyword">this</span>.getStrFromConsole();</span><br><span class="line">			<span class="keyword">if</span>(!msg.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">				send(msg);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 释放资源</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.isRunning = <span class="keyword">false</span>;</span><br><span class="line">		SxtUtils.close(dos,client);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端接收"><a href="#客户端接收" class="headerlink" title="客户端接收"></a>客户端接收</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端的接收方法 封装</span></span><br><span class="line"><span class="comment"> * 加入多线程，实现读写同步进行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pikachu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientReceive</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> DataInputStream dis;</span><br><span class="line">	<span class="keyword">private</span> Socket client;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> isRunning;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ClientReceive</span><span class="params">(Socket client)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.client = client;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			dis = <span class="keyword">new</span> DataInputStream(client.getInputStream());</span><br><span class="line">			isRunning = <span class="keyword">true</span>;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">"====2===="</span>);</span><br><span class="line">			release();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String msg = <span class="string">""</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			msg = dis.readUTF();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">"====4===="</span>);</span><br><span class="line">			release();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> msg;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line">			String msg = receive();</span><br><span class="line">			<span class="keyword">if</span>(!msg.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">				System.out.println(msg);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.isRunning = <span class="keyword">false</span>;</span><br><span class="line">		SxtUtils.close(dis,client);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Closeable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工具类</span></span><br><span class="line"><span class="comment"> * 用于释放资源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pikachu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SxtUtils</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Closeable... targets)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(Closeable target:targets) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="keyword">null</span>!=target) &#123;</span><br><span class="line">					target.close();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/2019/03/16/Java/1.Java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>多线程在 Java 中多应用于网络编程和服务器端应用开发</p>
<a id="more"></a>
<p><img src="/images/3.16.jpg" alt=""></p>
<h2 id="实现多线程三种方式"><a href="#实现多线程三种方式" class="headerlink" title="实现多线程三种方式"></a>实现多线程三种方式</h2><ol>
<li><p>继承 Thread 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写run方法(线程入口点)</span></span><br><span class="line"><span class="comment">     * run方法没有返回类型，也不能抛出异常，有异常只能try..catch</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"dance"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();  <span class="comment">// 创建线程对象</span></span><br><span class="line">        myThread.start();  <span class="comment">// 调用 start 方法启动线程</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"sing"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>实现 Runnable 接口</p>
<blockquote>
<p>优先使用接口实现多线程，可避免单继承带来的局限性</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"dance"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="keyword">new</span> Thread(myThread).start();  <span class="comment">// 使用 Thread 代理对象启动线程</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"sing"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>实现 Callable 接口</p>
<blockquote>
<p>Callable 接口属于 JUC 包，涉及到高并发的时候会比较常用。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadWithCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写 call 方法，该方法可以有返回值类型，也可以抛出异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"dance"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        ThreadWithCallable t = <span class="keyword">new</span> ThreadWithCallable();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建执行服务</span></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交执行</span></span><br><span class="line">        Future&lt;Boolean&gt; result = executorService.submit(t);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取结果</span></span><br><span class="line">        Boolean r = result.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭服务</span></span><br><span class="line">        executorService.shutdownNow();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><blockquote>
<p>TODO: 线程状态图示（自己画）</p>
</blockquote>
<p>获取线程状态：<code>t.getState()</code></p>
<ol>
<li><p><code>NEW</code>：新生状态</p>
<p>new 线程对象，线程进入新生状态，开辟了自己的内存空间（每个线程都有独立的内存空间），可以和主存交互</p>
</li>
</ol>
<ol start="2">
<li><p><code>RUNNABLE</code>：就绪状态 / 运行状态<br>以下四种情况会使线程进入就绪状态</p>
<ul>
<li>start()</li>
<li>阻塞状态解除</li>
<li>yield()</li>
<li>JVM 干预</li>
</ul>
<p>cpu 调度到了，就进入运行状态</p>
</li>
</ol>
<ol start="3">
<li><p>阻塞状态：</p>
<ul>
<li><code>WAITING</code><ul>
<li><code>wait()</code></li>
<li><code>join()</code></li>
</ul>
</li>
<li><code>TIMED_WAITING</code><ul>
<li><code>sleep(1000)</code></li>
<li><code>wait(1000)</code></li>
<li><code>join(1000)</code></li>
</ul>
</li>
<li><code>BLOCKED</code></li>
</ul>
</li>
</ol>
<ol start="4">
<li><p><code>TERMINATED</code>：死亡状态</p>
<p>不推荐使用 <code>stop()</code> 和 <code>destory()</code> 来停止线程，因为这两个存在 bug</p>
<p>可以使用添加 boolean 标志的方法停止线程，方便外部进行控制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadStop</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置一个标志来控制线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程体中使用标志</span></span><br><span class="line">        <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 提供改变标志的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">terminate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadStop t = <span class="keyword">new</span> ThreadStop();</span><br><span class="line">        <span class="keyword">new</span> Thread(t).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 手动根据条件终止线程</span></span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">66</span>)&#123;</span><br><span class="line">                t.terminate();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="暂停-sleep"><a href="#暂停-sleep" class="headerlink" title="暂停 sleep"></a>暂停 sleep</h2><p><code>Thread.sleep(1000)</code>：线程阻塞 1s 后进入就绪状态</p>
<p>sleep 存在异常 <code>InterruptedException</code></p>
<p>可以使用 sleep 模拟网络延时、倒计时等</p>
<p>每一个对象都有一个锁，sleep 不会释放锁</p>
<h2 id="礼让-yield"><a href="#礼让-yield" class="headerlink" title="礼让 yield"></a>礼让 yield</h2><p><code>Thread.yield()</code>：让当前正在执行的线程从<strong>运行状态</strong>转入<strong>就绪状态</strong>，等待 cpu 调度器重新调度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YieldTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// lambda表达式</span></span><br><span class="line">		<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">				System.out.println(<span class="string">"lambda..."</span>+i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i%<span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">				Thread.yield(); <span class="comment">// 礼让，可能不成功</span></span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"main..."</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="插队-join"><a href="#插队-join" class="headerlink" title="插队 join"></a>插队 join</h2><p>成员方法，谁要插队，谁就调用 join。想要插入哪个线程，就写在哪个线程里面。</p>
<p><code>join()</code>：需要等待插队线程执行完，被插队线程才可以进入就绪状态</p>
<p><code>join(1000)</code>：不需要等待插队线程执行完，只要时间到了，被插队线程就进入就绪状态</p>
<h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>获取线程的优先级：<code>Thread.currentThread().getPriority()</code></p>
<ul>
<li>优先级的取值范围在 1-10 之间（所有线程默认都是 5）</li>
<li>优先级有三个常量<ul>
<li><code>MAX_PRIORITY = 10</code></li>
<li><code>MIN_PRIORITY = 1</code></li>
<li><code>NORM_PRIORITY = 5</code></li>
</ul>
</li>
<li>在 <code>start()</code> 之前设置优先级：<code>t.setPriority(Thread.MAX_PRIORITY)</code></li>
<li>优先级高的不一定先执行，优先级只是代表执行的概率</li>
</ul>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><ul>
<li>所有的线程默认都是用户线程，守护线程需要手动设置</li>
<li>JVM 停止不用考虑守护线程</li>
</ul>
<p>设置守护线程（在 <code>start()</code> 之前设置）</p>
<p><code>t.setDaemon(true)</code></p>
<h2 id="线程的基本信息"><a href="#线程的基本信息" class="headerlink" title="线程的基本信息"></a>线程的基本信息</h2><ul>
<li><code>t.isAlive()</code>：判断一个线程是否还活着</li>
<li><code>t.setName()</code>：设置代理对象的名称</li>
<li><code>t.getName()</code>：获得代理对象的名称</li>
<li><code>Thread.currentThread()</code>：获得当前线程</li>
</ul>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><blockquote>
<p><strong>并发：</strong>多个线程同时操作同一个资源</p>
</blockquote>
<p><strong>概念：</strong>队列 + 锁（synchronized） = 线程安全 = 线程同步</p>
<blockquote>
<p>使用锁可以保证线程安全，但会导致性能下降（因为加锁和释放锁都比较消耗资源）</p>
</blockquote>
<p><strong>synchronized 用法：</strong></p>
<ul>
<li>同步方法：把 synchronized 写在方法的声明上（锁的是 this）</li>
<li>同步块：<code>synchronized（obj）{}</code>，obj 称之为同步监视器（被锁的对象 or 要修改的对象）</li>
</ul>
<p><strong>使用 synchronized  注意事项：</strong></p>
<ul>
<li>锁准对象，否则不能保证线程安全</li>
<li>锁准范围，如果锁定的范围（指的是数据的范围，而不是代码的范围）过大，将会大大影响效率</li>
</ul>
<blockquote>
<p>多用同步块，少用同步方法，因为同步块在保证线程安全的前提下，性能更优</p>
</blockquote>
<p><strong>死锁：</strong>过多的同步可能造成相互不释放资源，从而相互等待，一般发生于同步中持有多个对象的锁。</p>
<p><strong>避免死锁：</strong>不要在同一个代码块中同时持有多个对象的锁</p>
<h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><p>协作模型：生产者 / 消费者模型</p>
<p>两种实现方式：</p>
<ul>
<li>管程法（生产者和消费者之间增加缓冲区）</li>
<li>信号灯法（使用标志位来调度生产者和消费者）</li>
</ul>
<p>相关方法：</p>
<ul>
<li><code>wait()</code>：线程一直等待，直到其他线程通知，会释放锁</li>
<li><code>wait(long timeout)</code>：线程只等待一定的时间</li>
<li><code>notify()</code>：唤醒一个处于等待状态的线程</li>
<li><code>notifyAll()</code>：唤醒同一个对象中所有处于等待状态的线程</li>
</ul>
<blockquote>
<p>这四个方法是 Object 提供的，也就是说所有的对象都会有这四个方法</p>
<p>这四个方法只能在同步方法或同步块中使用</p>
</blockquote>
<p><strong>管程法代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCooperation</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SynContainer container = <span class="keyword">new</span> SynContainer();</span><br><span class="line">		Productor productor = <span class="keyword">new</span> Productor(container);</span><br><span class="line">		Consumer consumer = <span class="keyword">new</span> Consumer(container);</span><br><span class="line">		productor.start();</span><br><span class="line">		consumer.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Productor</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	SynContainer container;	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Productor</span><span class="params">(SynContainer container)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.container = container;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 生产</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">105</span>; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"生产 --&gt; 第"</span>+ i +<span class="string">"个馒头"</span>);</span><br><span class="line">			container.push(<span class="keyword">new</span> Steamedbun(i));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	SynContainer container;	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(SynContainer container)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.container = container;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 消费</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"消费 --&gt; 第"</span>+ container.pop().getId() +<span class="string">"个馒头"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓冲区</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynContainer</span></span>&#123;</span><br><span class="line">	Steamedbun[] buns = <span class="keyword">new</span> Steamedbun[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">//计数器(容器中的馒头数量)</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 储存 --&gt; 生产</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Steamedbun bun)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 何时生产 容器中有空余空间时</span></span><br><span class="line">		<span class="comment">// 没有空间，停止生产</span></span><br><span class="line">		<span class="keyword">if</span>(count == buns.length) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">this</span>.wait(); <span class="comment">// 线程阻塞，消费者通知生产时解除阻塞</span></span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 存在空间，可以生产</span></span><br><span class="line">		buns[count] = bun;</span><br><span class="line">		count++;</span><br><span class="line">		<span class="keyword">this</span>.notifyAll(); <span class="comment">// 唤醒消费者进行消费</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获取 --&gt; 消费</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Steamedbun <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 何时消费 判断容器中是否存在数据</span></span><br><span class="line">		<span class="comment">// 没有数据 --&gt; 等待</span></span><br><span class="line">		<span class="keyword">if</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">this</span>.wait(); <span class="comment">// 线程阻塞，生产者通知消费时解除阻塞</span></span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 存在数据 --&gt; 消费</span></span><br><span class="line">		count--;</span><br><span class="line">		Steamedbun bun = buns[count];  <span class="comment">// 从最后一个开始拿</span></span><br><span class="line">		<span class="keyword">this</span>.notifyAll(); <span class="comment">// 唤醒生产者进行生产</span></span><br><span class="line">		<span class="keyword">return</span> bun;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 馒头 --&gt; 资源</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Steamedbun</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Steamedbun</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>信号灯法代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 信号灯法实现生产者消费者模式</span></span><br></pre></td></tr></table></figure>





<h2 id="定时调度"><a href="#定时调度" class="headerlink" title="定时调度"></a>定时调度</h2><p>Timer 和 TimerTask</p>
<h2 id="quartz-–-任务调度框架"><a href="#quartz-–-任务调度框架" class="headerlink" title="quartz – 任务调度框架"></a>quartz – 任务调度框架</h2><h2 id="happenbefore"><a href="#happenbefore" class="headerlink" title="happenbefore"></a>happenbefore</h2><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>IO</title>
    <url>/2019/03/06/Java/1.Java%E5%9F%BA%E7%A1%80/IO/</url>
    <content><![CDATA[<p>IO 基本概念</p>
<a id="more"></a>

<p><img src="/images/IO/3.6.jpg" alt="3.6"></p>
<h2 id="IO中的四大抽象基类"><a href="#IO中的四大抽象基类" class="headerlink" title="IO中的四大抽象基类"></a>IO中的四大抽象基类</h2><ul>
<li><strong>字节</strong>输入、输出流：<code>InputStream</code>，<code>OutputStream</code></li>
</ul>
<p>  <strong>InputStream</strong> 类常用方法：</p>
<ol>
<li><p><code>read()</code>：每次读取一个字节的数据，返回读到的字节对应的 int 整数（0~255），没读到数据返回 <code>-1</code></p>
</li>
<li><p><code>read(byte[] b)</code>：每次读取 <code>b.length</code> 个字节，存到 b 中，返回本次读到的字节数量。没读到数据返回 <code>-1</code>（<strong>调用了 3</strong>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> read(b, <span class="number">0</span>, b.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p><code>read(byte[] b, int off, int len)</code>：每次读取 len 个字节，存到 b 中，从下标为 off 的位置开始存，返回本次读到的字节数量。没读到数据返回 <code>-1</code></p>
</li>
<li><p><code>close()</code>：通知操作系统释放资源</p>
</li>
</ol>
<p>  <strong>OutputStream</strong> 类常用方法：</p>
<ol>
<li><p><code>write(byte[] b)</code>：将 b 中的数据输出（<strong>调用了 2</strong>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    write(b, <span class="number">0</span>, b.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p><code>write(byte[] b, int off, int len)</code>：将 b 中从 off 下标位置开始的 len 个字节输出</p>
</li>
<li><p><code>flush()</code>：刷新此次输出流，强制写出缓冲的数据。</p>
</li>
<li><p><code>close()</code>：通知操作系统释放资源（带有 flush 功能）</p>
</li>
</ol>
<ul>
<li><strong>字符</strong>输入、输出流：<code>Reader</code>， <code>Writer</code></li>
</ul>
<p>  <strong>Reader</strong> 类常用方法：</p>
<ol>
<li><p><code>read()</code>：每次读取一个字符，返回该字符对应的编码数字（int 0~65535）</p>
</li>
<li><p><code>read(char[] cbuf)</code>：每次读取 <code>cbuf.length</code> 个字符，存到 cbuf 中，返回本次读到的字符数量。没读到数据返回 <code>-1</code>（<strong>调用了 3</strong>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> cbuf[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> read(cbuf, <span class="number">0</span>, cbuf.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><code>read(char[] cbuf, int off, int len)</code>：每次读取 len 个字符，存到 b 中，从下标为 off 的位置开始存，返回本次读到的字符数量。没读到数据返回 <code>-1</code></li>
</ol>
<p>  <strong>Writer</strong> 类常用方法：</p>
<ol>
<li><p><code>write(char[] cbuf)</code>：将 cbuf 中的数据写出（<strong>调用了 2</strong>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> cbuf[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    write(cbuf, <span class="number">0</span>, cbuf.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p><code>write(char[] cbuf, int off. int len)</code>：将 cbuf 中从 off 下标位置开始的 len 个字符输出</p>
</li>
<li><p><code>append(CharSequence csq)</code>：返回 Writer 对象，流式打点连续输出 <code>writer.append(a).append(b).append(c)</code>。</p>
<p>字符串也实现了 <code>CharSequence</code> 接口，可以直接作为方法的参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Writer <span class="title">append</span><span class="params">(CharSequence csq)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (csq == <span class="keyword">null</span>)</span><br><span class="line">        write(<span class="string">"null"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        write(csq.toString());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ol>
<h2 id="IO流操作的标准步骤"><a href="#IO流操作的标准步骤" class="headerlink" title="IO流操作的标准步骤"></a>IO流操作的标准步骤</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * IO 操作基本步骤：</span></span><br><span class="line"><span class="comment"> * 		1. 创建源</span></span><br><span class="line"><span class="comment"> * 		2. 选择流</span></span><br><span class="line"><span class="comment"> * 		3. 操作</span></span><br><span class="line"><span class="comment"> * 		4. 释放资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInputStream01</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 1. 创建源</span></span><br><span class="line">		File src = <span class="keyword">new</span> File(<span class="string">"C:/Users/pikachu/eclipse-workspace/sxt.Io/src/sxt.txt"</span>);</span><br><span class="line">		<span class="comment">// 2. 选择流</span></span><br><span class="line">		InputStream is = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			is = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line">			<span class="keyword">int</span> temp;</span><br><span class="line">			<span class="comment">// 3. 操作</span></span><br><span class="line">			<span class="keyword">while</span>((temp=is.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">				System.out.print((<span class="keyword">char</span>)temp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">// 4. 释放资源</span></span><br><span class="line">			<span class="keyword">if</span>(is!=<span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					is.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="文件字节流"><a href="#文件字节流" class="headerlink" title="文件字节流"></a>文件字节流</h2><ul>
<li><p><strong>FileInputStream：</strong>文件字节输入流，通过字节方式读取文件</p>
<p>构造方法：</p>
<ol>
<li><p><code>new FileInputStream(File file)</code>：传入文件对象创建流，如果对应文件不存在，则抛出 <code>FileNotFoundException</code></p>
</li>
<li><p><code>new FileInputStream(String name)</code>：传入文件名创建流（<strong>调用了 1</strong>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(String name)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// 这里帮忙new了一个File对象，调用了第一种构造方法</span></span><br><span class="line">    <span class="keyword">this</span>(name != <span class="keyword">null</span> ? <span class="keyword">new</span> File(name) : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ul>
<ul>
<li><p><strong>FileOutputStream：</strong>文件字节输出流，通过字节的方式写出或追加数据到文件</p>
<p>构造方法：</p>
<ol>
<li><p><code>new FileOutputStream(File file)</code>：传入文件对象创建流（这个文件可以不存在，不存在则会新建文件）（<strong>调用了 2</strong>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// append为false，每次write都从头添加</span></span><br><span class="line">    <span class="keyword">this</span>(file, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ul>
<ol start="2">
<li><p><code>new FileOutputStream(File file, boolean append)</code>：传入文件对象同时传入是否开启追加模式</p>
</li>
<li><p><code>new FileOutputStream(String name)</code>：传入文件名（<strong>调用了 1</strong>）</p>
</li>
<li><p><code>new FileOutputStream(String name, boolean append)</code>：传入文件名和是否开启追加模式（<strong>调用了 2</strong>）</p>
<blockquote>
<p>追加模式：</p>
<p>在创建输出流对象的时候相当于打开了一次文件，而是否开启追加模式决定了这次对文件的操作是<strong>清空文件内容后再写</strong>还是<strong>在原有内容后追加</strong>。</p>
<p>一个输出流对象多次调用 <code>write()</code> 方法和追加模式无关，就是追加往文件里面写，后面的 <code>write()</code> 不会覆盖前面 <code>write()</code> 的内容</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>try-with-resource 简化流的释放（JDK1.7 开始提供）</p>
<p>把流的创建写在 try 后面的括号里面，就不用在 finally 里面手动关闭流了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多个流直接使用 分号 分隔</span></span><br><span class="line"><span class="keyword">try</span>(InputStream is = <span class="keyword">new</span> FileInputStream(src))&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<h2 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h2><p>利用 <strong>FileInputStream</strong> 和 <strong>FileOutputStream</strong> 进行文件的拷贝</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 创建源</span></span><br><span class="line">	File src = <span class="keyword">new</span> File(<span class="string">"C:/Users/pikachu/eclipse-workspace/sxt.Io/Java学习路线图.jpg"</span>);</span><br><span class="line">	File dest = <span class="keyword">new</span> File(<span class="string">"dest2.jpg"</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 选择流</span></span><br><span class="line">	<span class="keyword">try</span>(InputStream is = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line">        OutputStream os = <span class="keyword">new</span> FileOutputStream(dest)) &#123;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 操作</span></span><br><span class="line">		<span class="keyword">byte</span>[] datas = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>((len = is.read(datas))!= -<span class="number">1</span>) &#123;</span><br><span class="line">			os.write(datas, <span class="number">0</span>, len); <span class="comment">// 写入	</span></span><br><span class="line">		&#125;</span><br><span class="line">		os.flush(); <span class="comment">// 强制刷新</span></span><br><span class="line">	&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="文件字符流"><a href="#文件字符流" class="headerlink" title="文件字符流"></a>文件字符流</h2><blockquote>
<p>在各种字符集中，一个字符可能占一个字节、两个字节或三个字节，所以如果使用字节流操作字符，可能会出现乱码的情况。</p>
<p>字符流可以消除不同字符集的编码差异，让我们可以自己对字符进行随心所欲的操作，而不需要考虑乱码。</p>
</blockquote>
<ul>
<li><code>FileReader</code>：文件字符输入流</li>
<li><code>FileWriter</code>：文件字符输出流</li>
</ul>
<h2 id="字节数组流"><a href="#字节数组流" class="headerlink" title="字节数组流"></a>字节数组流</h2><ul>
<li>ByteArrayInputStream</li>
<li>ByteArrayOutputStream</li>
</ul>
<blockquote>
<p>字节数组流操作的是内存中的<strong>字节数组</strong>，不与 OS 打交道，故可由 gc 自动回收，不用关闭</p>
<p>任何东西都可以转成字节数组，可以方便后期进行网络传输等操作</p>
</blockquote>
<hr>
<blockquote>
<p>以上介绍的流都是节点流，属于直接操作数据源，但是效率可能不是特别高，为了提高 IO 流效率，所以对节点流进行包装处理，提升效率，简化操作，就出现了处理流。</p>
<p>处理流并不能直接操作数据，只是对节点流的包装，这其中使用到了设计模式中的<strong>装饰器模式</strong></p>
</blockquote>
<h2 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h2><p>字节缓冲流内部定义了一个缓冲区（默认大小为8k），可以提高字节流处理的效率。</p>
<p>常用方法和 InputStream 中一致。</p>
<ul>
<li><p><strong>BufferedInputStream</strong></p>
<p>构造方法：</p>
<ol>
<li><p><code>BufferedInputStream(InputStream in)</code>：传入字节输入流对象（<strong>调用了 2</strong>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内部定义的缓冲区大小默认为 8k</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_BUFFER_SIZE = <span class="number">8192</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedInputStream</span><span class="params">(InputStream in)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(in, DEFAULT_BUFFER_SIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ul>
<ol start="2">
<li><code>BufferedInputStream(InputStream in, int size)</code>：传入字节输入流对象和缓冲区大小</li>
</ol>
<ul>
<li><p><strong>BufferedOutputStream</strong></p>
<p>构造方法：</p>
<ol>
<li><code>BufferedOutputStream(OutputStream out)</code>：类似 <strong>BufferedInputStream</strong></li>
<li><code>BufferedOutputStream(OutputStream out, int size)</code>：类似 <strong>BufferedInputStream</strong></li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用字节缓冲流(一般情况下使用默认的缓冲区大小就行)</span></span><br><span class="line">InputStream in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(src));</span><br><span class="line">OutputStream out = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutoutStream(dest));</span><br></pre></td></tr></table></figure>





<h2 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h2><p>字符缓冲流包装了字符流，提高了字符处理的效率，同时提供了一些新方法简化操作。</p>
<ul>
<li><p><strong>BufferedReader</strong></p>
<p>构造方法：</p>
<ol>
<li><p><code>BufferedReader(Reader in)</code>：传入一个 Reader 对象（<strong>调用了 2</strong>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内部缓存字符数组的默认大小默认为 8192</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> defaultCharBufferSize = <span class="number">8192</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedReader</span><span class="params">(Reader in)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(in, defaultCharBufferSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ul>
<ol start="2">
<li><code>BufferedReader(Reader in, int size)</code>：传入一个 Reader 对象和内部缓冲字符数组大小</li>
</ol>
<p>  新增方法：</p>
<ul>
<li><code>readLine()</code>：每次读取一行（会自动去寻找换行符）</li>
</ul>
<ul>
<li><p><strong>BufferedWriter</strong></p>
<p>构造方法：</p>
<ol>
<li><code>BufferedWriter(Writer out)</code>：类似 <strong>BufferedReader</strong></li>
<li><code>BufferedWriter(Writer out, int size)</code>：类似 <strong>BufferedReader</strong></li>
</ol>
</li>
</ul>
<p>  新增方法：</p>
<ul>
<li><code>newLine()</code>：换行，就不用在写的时候手动加 <code>\r\n</code> 了</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用字符缓冲流</span></span><br><span class="line">BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(src));</span><br><span class="line">BufferedWriter writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(dest));</span><br></pre></td></tr></table></figure>





<h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><p>如果字节流中的数据为纯字符时，可以使用转换流将字节流转换为字符流。</p>
<ul>
<li>InputStreamReader</li>
<li>OutpurStreamWriter</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用转换流</span></span><br><span class="line">BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(src)));</span><br><span class="line">BufferedWriter writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(dest)));</span><br></pre></td></tr></table></figure>





<h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p>使用数据流可以将保存基本数据类型的数据，存数据和取数据需要顺序一致</p>
<ul>
<li>DataInputStream</li>
<li>DataOutputStream</li>
</ul>
<h2 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h2><p>可以将 Java 中的对象序列化和反序列化</p>
<ul>
<li>ObjectInputStream</li>
<li>ObjectOutputStream</li>
</ul>
<h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><ul>
<li>PrintStream</li>
</ul>
<h2 id="Commons-IO"><a href="#Commons-IO" class="headerlink" title="Commons IO"></a>Commons IO</h2>]]></content>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 异常</title>
    <url>/2019/03/03/Java/1.Java%E5%9F%BA%E7%A1%80/Java%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<p>理想状态下，用户输入的数据以及格式永远是正确的,，选择的文件一定可以打开，并且永远不会出现bug。</p>
<p>然而，现实世界中却充满着不良的数据和带有问题的代码。</p>
<p>一个程序在运行中遇到内部或者外部的问题时，应该做到以下三点：</p>
<ul>
<li>像用户通报错误</li>
<li>保存所有工作结果</li>
<li>允许用户以妥善的形式退出程序</li>
</ul>
<p>要做到以上几点，就需要在程序中引入 异常处理 和 错误捕获机制。</p>
<a id="more"></a>

<h2 id="1-Java-异常基本概念"><a href="#1-Java-异常基本概念" class="headerlink" title="1. Java 异常基本概念"></a>1. Java 异常基本概念</h2><h3 id="1-1-异常基本结构"><a href="#1-1-异常基本结构" class="headerlink" title="1.1 异常基本结构"></a>1.1 异常基本结构</h3><p>Java 异常结构示意图：</p>
<p><img src="/images/Java%E5%BC%82%E5%B8%B8/image-20210426205927608.png" alt="image-20210426205927608"></p>
<p>Error 类：描述了 Java 运行时系统的内部错误和资源耗尽错误（Error 很少出现）</p>
<p>Exception 类：</p>
<ol>
<li>RuntimeException：由于程序错误导致的异常<ul>
<li>错误的类型转换</li>
<li>数组访问越界</li>
<li>访问 null 指针</li>
</ul>
</li>
<li>OtherException：程序本身没有问题，由于像 I/O 这类的问题导致的异常属于其他异常<ul>
<li>试图在文件尾部后面读取数据</li>
<li>试图打开一个不存在的文件</li>
<li>试图根据给定的字符串查找 Class 对象，但这个字符串表示的类不存在</li>
</ul>
</li>
</ol>
<blockquote>
<p>如果出现 RuntimeException 异常，那么就一定是自己的问题。</p>
</blockquote>
<h3 id="1-2-受查异常-和-非受查异常"><a href="#1-2-受查异常-和-非受查异常" class="headerlink" title="1.2 受查异常 和 非受查异常"></a>1.2 受查异常 和 非受查异常</h3><p>非受查（unchecked）异常：派生于 Error 类或 RuntimeException 类的所有异常。</p>
<p>受查（checked）异常：除了上面两种外，其他的异常。</p>
<blockquote>
<p>编译器将核查是否为所有的受查异常提供了异常处理器。</p>
</blockquote>
<h2 id="2-异常的声明、抛出和捕获"><a href="#2-异常的声明、抛出和捕获" class="headerlink" title="2. 异常的声明、抛出和捕获"></a>2. 异常的声明、抛出和捕获</h2><h3 id="2-1-声明异常"><a href="#2-1-声明异常" class="headerlink" title="2.1 声明异常"></a>2.1 声明异常</h3><p>方法应该在其首部声明所有可能抛出的<strong>受查异常</strong>，多个异常之间用逗号分隔。</p>
<p>使用 throws 关键字声明异常，下面是 FileInputStream 类的一个构造器的声明：</p>
<p><code>public FileInputStream(String name) throws FileNotFoundException</code></p>
<p>需要使用 throws 声明异常的情况：</p>
<ul>
<li>调用了一个抛出受查异常的方法</li>
<li>程序运行时发现错误，并使用 throw 语句抛出了一个受查异常</li>
</ul>
<blockquote>
<p>注意：</p>
<ol>
<li>如果子类中覆盖了超类的一个方法，子类方法中声明的受查异常不能比超类中声明的更通用。</li>
<li>如果超类没有抛出任何受查异常，子类也不能抛出任何受查异常。</li>
</ol>
</blockquote>
<h3 id="2-2-抛出异常"><a href="#2-2-抛出异常" class="headerlink" title="2.2 抛出异常"></a>2.2 抛出异常</h3><p>在方法体中使用 throw 关键字抛出异常</p>
<p>抛异常的步骤：</p>
<ol>
<li>找到一个合适的异常类</li>
<li>创建这个异常类的对象</li>
<li>将对象抛出</li>
</ol>
<h3 id="2-3-捕获异常"><a href="#2-3-捕获异常" class="headerlink" title="2.3 捕获异常"></a>2.3 捕获异常</h3><p>捕获异常的原则：捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递</p>
<blockquote>
<p>如果一个方法覆盖了超类的方法，而超类的方法又没有抛出异常，那么这个方法就必须捕获方法代码中出现的每一个受查异常</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  捕获异常的基本代码结构</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 可能存在异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(FileNotFoundException | UnknownHostException e)&#123;</span><br><span class="line">    <span class="comment">// 处理异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">    <span class="comment">// 处理异常的代码</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">// 无论是否存在异常都要执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上面的代码可以看出，try / catch 语句可以捕获多个异常，捕获多个异常有两种方式：</p>
<ol>
<li>使用多个 catch 子句捕获多个异常，可以对不同的异常做出不同的处理</li>
<li>使用一个 catch 子句捕获多个异常（多个异常类型之间不存在子类关系时才可以）</li>
</ol>
<blockquote>
<p>再次抛出异常：</p>
<p>在 catch 子句中可以抛出一个异常，这样做的目的是改变异常的类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">    Throwable se = <span class="keyword">new</span> ServletException(<span class="string">"database error"</span>);</span><br><span class="line">    se.initCause(e);  <span class="comment">// 把捕获到的异常作为要抛出的异常的“原因”</span></span><br><span class="line">    <span class="keyword">throw</span> se;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当在其他地方捕获到抛出的 ServletException 异常时，可以使用下面的语句获取到原始异常：</p>
<p><code>Throwable e = se.getCause();</code></p>
<p>使用这种包装技术，可以让用户抛出子系统中的高级异常的同时不会丢失原始异常的细节。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java 异常</tag>
      </tags>
  </entry>
  <entry>
    <title>数组</title>
    <url>/2019/02/28/Java/1.Java%E5%9F%BA%E7%A1%80/%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>数组</p>
<a id="more"></a>

<p><img src="/images/%E6%95%B0%E7%BB%84/2.28.jpg" alt="2.28"></p>
<h2 id="0、数组的特点"><a href="#0、数组的特点" class="headerlink" title="0、数组的特点"></a>0、数组的特点</h2><ol>
<li>数组的大小一旦定义，就不可改变。</li>
<li>数组中只能存放同一类型的元素。</li>
</ol>
<h2 id="1、数组的定义"><a href="#1、数组的定义" class="headerlink" title="1、数组的定义"></a>1、数组的定义</h2><p>定义数组的两种形式：</p>
<ol>
<li><code>int[] arr;</code>  中括号写在数组类型后面，常用</li>
<li><code>int arr[];</code>  中括号写在数组名称后面，不常用（最初是为了让 C 和 C++ 的程序员更好的上手 Java 而设计的）</li>
</ol>
<p>可以仅定义一个数组变量，也可以在定义的时候就初始化：</p>
<p><code>int[] arr1 = new int[3];</code></p>
<p>初始化有几种方式，详见下文。</p>
<h2 id="2、数组的内存状态"><a href="#2、数组的内存状态" class="headerlink" title="2、数组的内存状态"></a>2、数组的内存状态</h2><p>数组其实是一个对象，像其他对象一样：</p>
<p><code>int[] arr1 = new int[3];</code></p>
<ul>
<li><code>arr1</code> 是数组对象的引用，里面存放的是数组对象的地址值，引用在<strong>栈内存</strong>中</li>
<li><code>new int[3]</code> 是新建一个数组对象，对象在<strong>堆内存</strong>中</li>
</ul>
<h2 id="3、数组的初始化方式"><a href="#3、数组的初始化方式" class="headerlink" title="3、数组的初始化方式"></a>3、数组的初始化方式</h2><ul>
<li>默认初始化<br><code>int[] arr1 = new int[3];</code></li>
<li>静态初始化<br><code>int[] arr2 = {1,2,3};</code></li>
<li>动态初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr3 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">arr3[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">arr3[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">arr3[<span class="number">2</span>] = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>



<h2 id="4、数组的使用"><a href="#4、数组的使用" class="headerlink" title="4、数组的使用"></a>4、数组的使用</h2><p>获取数组中的元素（通过下标获取）：<code>arr[0]</code></p>
<p>获取数组的长度（通过数组的 length 属性）：<code>arr.length</code></p>
<p>遍历数组：</p>
<ul>
<li>利用 for 循环遍历</li>
<li>利用 for-each 循环遍历（只能把数组中的元素全部取出来，无法使用下标操作数组）</li>
</ul>
<h2 id="5、多维数组"><a href="#5、多维数组" class="headerlink" title="5、多维数组"></a>5、多维数组</h2><p>概念：多维数组是一个数组中的元素也是数组（数组的嵌套，几维数组就嵌套几层）</p>
<p>以二维数组为例：</p>
<p>定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个二维数组</span></span><br><span class="line"><span class="keyword">int</span>[][] twoDArray = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>取值：<code>twoDArray[0][1]</code> ==&gt; 2</p>
<p>遍历：使用双层 for 循环遍历</p>
<h2 id="6、数组的拷贝"><a href="#6、数组的拷贝" class="headerlink" title="6、数组的拷贝"></a>6、数组的拷贝</h2><p>数组拷贝的核心代码：<br><code>System.arraycopy(src, srcPos, dest, destPos, length);</code></p>
<ul>
<li>以下三种操作本质上都是使用数组的拷贝<ul>
<li>数组扩容</li>
<li>数组中插入元素</li>
<li>数组中删除元素</li>
</ul>
</li>
</ul>
<h2 id="7、Arrays工具类"><a href="#7、Arrays工具类" class="headerlink" title="7、Arrays工具类"></a>7、Arrays工具类</h2><p>导包：<code>inport java.util.Arrays;</code></p>
<p>常用方法：</p>
<ul>
<li><code>public static String toString(arr)</code> –&gt; 将数组变成字符串（格式：<code>[元素1, 元素2, 元素3]</code>）</li>
<li><code>public static void sort(arr)</code> –&gt; 按照升序对数组元素进行排序</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习笔记</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>request库的5个爬虫小框架</title>
    <url>/2018/08/12/Python/Python_old/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/Requests%E5%BA%935%E4%B8%AA%E7%88%AC%E8%99%AB%E5%B0%8F%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<ol>
<li><p>京东商品页面爬取</p>
</li>
<li><p>亚马逊商品页面爬取</p>
</li>
<li><p>百度搜索关键词提交</p>
</li>
<li><p>网络图片的爬取</p>
</li>
<li><p>IP地址归属地自动查询</p>
</li>
</ol>
<a id="more"></a>



<h3 id="京东商品页面爬取"><a href="#京东商品页面爬取" class="headerlink" title="京东商品页面爬取"></a>京东商品页面爬取</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">"https://item.jd.com/7629588.html"</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    r = requests.get(url)</span><br><span class="line">    r.raise_for_status()</span><br><span class="line">    r.encoding = r.apparent_encoding</span><br><span class="line">    print(r.text[:<span class="number">1000</span>])</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">"爬取失败"</span>)</span><br></pre></td></tr></table></figure>



<h3 id="亚马逊商品页面爬取"><a href="#亚马逊商品页面爬取" class="headerlink" title="亚马逊商品页面爬取"></a>亚马逊商品页面爬取</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">"https://www.amazon.cn/dp/B07896QS5D"</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    kv = &#123;<span class="string">'user-agent'</span>:<span class="string">'Mozilla/5.0'</span>&#125;</span><br><span class="line">    r = requests.get(url,headers=kv)</span><br><span class="line">    r.raise_for_status()</span><br><span class="line">    r.encoding = r.apparent_encoding</span><br><span class="line">    print(r.text[<span class="number">1000</span>:<span class="number">2000</span>])</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">"爬取失败"</span>)</span><br></pre></td></tr></table></figure>



<h3 id="百度搜索关键词提交"><a href="#百度搜索关键词提交" class="headerlink" title="百度搜索关键词提交"></a>百度搜索关键词提交</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">keyword = <span class="string">"Python"</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    kv = &#123;<span class="string">'wd'</span>:keybord&#125;</span><br><span class="line">    r = requests.get(<span class="string">"http://www.baidu.com/s"</span>,params = kv)</span><br><span class="line">    print(r.request.url)</span><br><span class="line">    r.raise_for_status()</span><br><span class="line">    print(len(r.text))</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">"爬取失败"</span>)</span><br></pre></td></tr></table></figure>



<h3 id="网络图片的爬取"><a href="#网络图片的爬取" class="headerlink" title="网络图片的爬取"></a>网络图片的爬取</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">url = <span class="string">"http://image.nationalgeographic.com.cn/2017/0928/20170928105418550.jpg"</span></span><br><span class="line">root = <span class="string">"D://"</span></span><br><span class="line">path = root + url.split(<span class="string">'/'</span>)[<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(root):</span><br><span class="line">        os.mkdir(root)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">        r = requests.get(url)</span><br><span class="line">        <span class="keyword">with</span> open(path,<span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(r.content)</span><br><span class="line">            f.close()</span><br><span class="line">            print(<span class="string">"文件保存成功"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"文件已存在"</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">"爬取失败"</span>)</span><br></pre></td></tr></table></figure>



<h3 id="IP-地址归属地自动查询"><a href="#IP-地址归属地自动查询" class="headerlink" title="IP 地址归属地自动查询"></a>IP 地址归属地自动查询</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">"http://m.ip138.com/ip.asp?ip="</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    r = requests.get(url + <span class="string">'202.204.80.112'</span>)</span><br><span class="line">    r.raise_for_ststus()</span><br><span class="line">    r.encoding = r.apparent_encoding</span><br><span class="line">    print(r.text[<span class="number">-500</span>:])</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">"爬去失败"</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>request库</title>
    <url>/2018/08/10/Python/Python_old/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/Requests%E5%BA%93/</url>
    <content><![CDATA[<p>requests 库为专业的爬虫第三方库</p>
<a id="more"></a>

<h2 id="requests-库主要有7个方法："><a href="#requests-库主要有7个方法：" class="headerlink" title="requests 库主要有7个方法："></a>requests 库主要有7个方法：</h2><pre><code>requests.request()        构造一个请求，支撑以下各方法的基础方法
requests.get()            获取HTML网页的主要方法，对应于HTTP的GET
requests.head()            获取HTML网页头信息的方法，对应于HTTP的HEAD
requests.post()            向HTML网页提交POST请求的方法，对应于HTTP的POST
requests.put()            向HTML网页提交PUT请求的方法，对应于HTTP的PUT
requests.patch()        向HTML网页提交局部修改请求，对应于HTTP的PATCH
requests.delete()        向HTML网页提交删除请求，对应于HTTP的DELETE</code></pre><h2 id="r-requests-get-url"><a href="#r-requests-get-url" class="headerlink" title="r = requests.get(url)"></a>r = requests.get(url)</h2><p>Requests 库的两个重要对象：Response 和 Request</p>
<p>Response 对象包含服务器返回的所有信息，也包含请求的 Request 信息</p>
<p>Response 对象的属性：</p>
<pre><code>r.status_code        HTTP请求的返回状态，200表示连接成功，404或其他表示失败
r.text               HTTP响应内容的字符串形式，即URL对应的页面内容
r.encoding           从HTTP header中猜测响应内容编码方式
r.apparent_encoding  从内容中分析出响应内容编码方式（备选编码方式）
r.content            HTTP响应内容的二进制形式</code></pre><h2 id="Requests-库的异常"><a href="#Requests-库的异常" class="headerlink" title="Requests 库的异常"></a>Requests 库的异常</h2><pre><code>requests.ConnectionError   网络连接错误异常
requests.HTTPError         HTTP错误异常
requests.URLRequired       URL缺失异常
requests.TooManyRedirects  超过最大重定向次数，产生重定向异常
requests.ConnectTimeout    连接远程服务器超时异常
requests.Timeout           请求URL超时，产生超时异常</code></pre><h2 id="爬取网页的通用代码框架"><a href="#爬取网页的通用代码框架" class="headerlink" title="爬取网页的通用代码框架"></a>爬取网页的通用代码框架</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    r = requests.get(url)</span><br><span class="line">    r.raise_for_status()</span><br><span class="line">    r.encoding = r.apparent_encoding</span><br><span class="line">    print(r.text)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">"爬取失败"</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Python标准库</title>
    <url>/2018/08/08/Python/Python_old/Python%E6%A0%87%E5%87%86%E5%BA%93/</url>
    <content><![CDATA[<p>time 库 &amp; random 库</p>
<a id="more"></a>

<h2 id="time-库"><a href="#time-库" class="headerlink" title="time 库"></a>time 库</h2><h3 id="time-库包括-3-类函数："><a href="#time-库包括-3-类函数：" class="headerlink" title="time 库包括 3 类函数："></a>time 库包括 3 类函数：</h3><ul>
<li>时间获取：<code>time()</code>, <code>ctime()</code>, <code>gmtime()</code></li>
<li>时间格式化：<code>strftime()</code>, <code>strptime()</code></li>
<li>程序计时：  <code>perf_counter()</code>, <code>sleep()</code></li>
</ul>
<h4 id="1-时间获取："><a href="#1-时间获取：" class="headerlink" title="1.时间获取："></a>1.时间获取：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">time.time()    <span class="comment"># 获取当前时间戳，即计算机内部时间值，返回浮点数</span></span><br><span class="line"><span class="comment"># 1600487832.4588485</span></span><br><span class="line"></span><br><span class="line">time.ctime()    <span class="comment"># 获取当前时间, 并以易读方式表示，返回字符串</span></span><br><span class="line"><span class="comment"># 'Sat Sep 19 11:57:39 2020'</span></span><br><span class="line"></span><br><span class="line">time.gmtime()    <span class="comment"># 获取当前时间，表示为计算机程序可处理的时间格式</span></span><br><span class="line"><span class="comment"># time.struct_time(tm_year=2020, tm_mon=9, tm_mday=19, tm_hour=3, tm_min=57, tm_sec=55, tm_wday=5, tm_yday=263, tm_isdst=0)</span></span><br></pre></td></tr></table></figure>

<h4 id="2-时间格式化："><a href="#2-时间格式化：" class="headerlink" title="2.时间格式化："></a>2.时间格式化：</h4><p><code>strftime(tpl,ts)</code></p>
<ul>
<li><code>tpl</code>是格式化模板字符串，用来定义输出效果</li>
<li><code>ts</code>是计算机内部时间类型变量,用 <code>gmtime()</code> / <code>localtime()</code>获取</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">t = time.gmtime()  <span class="comment"># gmtime()表示0时区标准时间</span></span><br><span class="line">time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>,t)</span><br><span class="line"><span class="comment"># '2020-09-19 04:00:12'</span></span><br><span class="line"></span><br><span class="line">t_local = time.localtime()  <span class="comment"># localtime()表示本地时间</span></span><br><span class="line">time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>,t_local)</span><br><span class="line"><span class="comment"># '2020-09-19 12:01:25'</span></span><br></pre></td></tr></table></figure>


<p>格式化控制符：    </p>
<table>
<thead>
<tr>
<th align="left">%Y</th>
<th align="left">%m</th>
<th align="left">%B</th>
<th align="left">%b</th>
<th align="left">%A</th>
<th align="left">%a</th>
</tr>
</thead>
<tbody><tr>
<td align="left">年份</td>
<td align="left">月份</td>
<td align="left">月份名称</td>
<td align="left">月份名称缩写</td>
<td align="left">星期</td>
<td align="left">星期缩写</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">%d</th>
<th align="left">%H</th>
<th align="left">%h</th>
<th align="left">%p</th>
<th align="left">%M</th>
<th align="left">%S</th>
</tr>
</thead>
<tbody><tr>
<td align="left">日期</td>
<td align="left">24小时制</td>
<td align="left">12小时制</td>
<td align="left">上下午</td>
<td align="left">分钟</td>
<td align="left">秒</td>
</tr>
</tbody></table>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">strptime(str,tpl)</span><br></pre></td></tr></table></figure>
<p>str 是字符串形式的时间值，<br>tpl 是格式化模板字符串，用来定义输出效果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">timestr = <span class="string">'2018-07-29 16:21:22'</span></span><br><span class="line">time.strptime(timestr,<span class="string">"%Y-%m-%d %H:%M:%S"</span>)</span><br></pre></td></tr></table></figure>

<h4 id="3-程序计时应用："><a href="#3-程序计时应用：" class="headerlink" title="3.程序计时应用："></a>3.程序计时应用：</h4><p>测量时间: perf_counter()    返回一个 CPU 级别的精确时间计数值，单位为秒</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">start = time.perf_counter()</span><br><span class="line">end = time.perf_counter()</span><br><span class="line">end-start</span><br></pre></td></tr></table></figure>

<p>产生时间: sleep(s)    s 为拟休眠时间，单位为秒，可为浮点数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wait</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">6.66</span>)</span><br><span class="line">wait()  <span class="comment">#  程序将暂停6.66秒</span></span><br></pre></td></tr></table></figure>

<h2 id="random库"><a href="#random库" class="headerlink" title="random库"></a>random库</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基本随机数函数</span></span><br><span class="line">random.seed()  <span class="comment">#初始化给定的随机数种子(种子相同, 产生的随机数序列就相同), 默认为当前系统时间</span></span><br><span class="line">random.random()  <span class="comment">#生成一个[0,1)之间的随机小数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 扩展随机数函数</span></span><br><span class="line">random.randint(a,b)  <span class="comment">#生成一个[a,b]之间的整数</span></span><br><span class="line">random.uniform(a,b)  <span class="comment">#生成一个[a,b]之间的小数</span></span><br><span class="line">random.getrandbits(k)  <span class="comment">#生成一个k比特长的随机整数</span></span><br><span class="line">random.randrange(m,n[,k])  <span class="comment">#生成一个[m,n)之间以k为步长的随机整数</span></span><br><span class="line">random.choice(seq)  <span class="comment">#从序列seq中随机选择一个元素</span></span><br><span class="line">random.shuffle(seq)  <span class="comment">#将序列seq中元素随机排列，返回打乱后的序列</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>time库</tag>
        <tag>random库</tag>
      </tags>
  </entry>
  <entry>
    <title>Python程序实例</title>
    <url>/2018/08/06/Python/Python_old/Python%E7%A8%8B%E5%BA%8F%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<p>7 个 python 程序设计的小例子</p>
<a id="more"></a>



<h2 id="实例1：Python温度转换实例代码"><a href="#实例1：Python温度转换实例代码" class="headerlink" title="实例1：Python温度转换实例代码"></a>实例1：Python温度转换实例代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#TenpConvert.py</span></span><br><span class="line">TempStr = input(<span class="string">"请输入带有符号的温度值："</span>)</span><br><span class="line"><span class="keyword">if</span> TempStr[<span class="number">-1</span>] <span class="keyword">in</span> [<span class="string">'F'</span>,<span class="string">'f'</span>]:</span><br><span class="line">	C = (eval(TempStr[<span class="number">0</span>:<span class="number">-1</span>])<span class="number">-32</span>)/<span class="number">1.8</span></span><br><span class="line">	print(<span class="string">"转换后的温度是&#123;:.2f&#125;C"</span>.format(C))</span><br><span class="line"><span class="keyword">elif</span> TempStr[<span class="number">-1</span>] <span class="keyword">in</span> [<span class="string">'C'</span>,<span class="string">'c'</span>]:</span><br><span class="line">	F = <span class="number">1.8</span>*eval(TempStr[<span class="number">0</span>:<span class="number">-1</span>])+<span class="number">32</span></span><br><span class="line">	print(<span class="string">"转换后的温度是&#123;:.2f&#125;F"</span>.format(F))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	print(<span class="string">"输入格式错误"</span>)</span><br></pre></td></tr></table></figure>



<h2 id="实例2：Python蟒蛇绘制"><a href="#实例2：Python蟒蛇绘制" class="headerlink" title="实例2：Python蟒蛇绘制"></a>实例2：Python蟒蛇绘制</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#PythonDraw.py</span></span><br><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line">turtle.setup(<span class="number">650</span>,<span class="number">350</span>,<span class="number">200</span>,<span class="number">200</span>)</span><br><span class="line">turtle.penup()</span><br><span class="line">turtle.fd(<span class="number">-250</span>)</span><br><span class="line">turtle.pendown()</span><br><span class="line">turtle.pensize(<span class="number">25</span>)</span><br><span class="line">turtle.pencolor(<span class="string">"purple"</span>)</span><br><span class="line">turtle.seth(<span class="number">-40</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    turtle.circle(<span class="number">40</span>,<span class="number">80</span>)</span><br><span class="line">    turtle.circle(<span class="number">-40</span>,<span class="number">80</span>)</span><br><span class="line">turtle.circle(<span class="number">40</span>,<span class="number">80</span>/<span class="number">2</span>)</span><br><span class="line">turtle.fd(<span class="number">40</span>)</span><br><span class="line">turtle.circle(<span class="number">16</span>,<span class="number">180</span>)</span><br><span class="line">turtle.fd(<span class="number">40</span> * <span class="number">2</span>/<span class="number">3</span>)</span><br><span class="line">turtle.done()</span><br></pre></td></tr></table></figure>



<h2 id="实例3：天天天向上的力量"><a href="#实例3：天天天向上的力量" class="headerlink" title="实例3：天天天向上的力量"></a>实例3：天天天向上的力量</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#DayDayUpQ1.py    每天进步千分之一</span></span><br><span class="line">dayup = pow(<span class="number">1.001</span>,<span class="number">365</span>)</span><br><span class="line">daydown = (pow(<span class="number">0.999</span>,<span class="number">365</span>)</span><br><span class="line">print(<span class="string">"向上:&#123;:.2f&#125;,向下:&#123;:.2f&#125;"</span>.format(dayup,daydown))</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#DayDayUpQ2    每天进步千分之五</span></span><br><span class="line">dayfactor = <span class="number">0.005</span>    <span class="comment">#使用变量的好处：一次修改即可</span></span><br><span class="line">dayup = pow(<span class="number">1</span>+dayfactor,<span class="number">365</span>)</span><br><span class="line">daydown = pow(<span class="number">1</span>-dayfactor,<span class="number">365</span>)</span><br><span class="line">print(<span class="string">"向上:&#123;:.2f&#125;,向下:&#123;:.2f&#125;"</span>.format(dayup,daydown)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#DayDayUpQ3    工作日的力量</span></span><br><span class="line">dayup = <span class="number">1.0</span></span><br><span class="line">dayfactory = <span class="number">0.01</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">365</span>):</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">7</span> <span class="keyword">in</span> [<span class="number">6</span>,<span class="number">0</span>]:</span><br><span class="line">        dayup = dayup*(<span class="number">1</span>-dayfactor)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        dayup = dayup*(<span class="number">1</span>+dayfactor)</span><br><span class="line">print(<span class="string">"工作日的力量:&#123;:.2f&#125;"</span>.format(dayup))</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#DayDayUpQ4    工作日要多努力才能与每天努力1%一样</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DayUp</span><span class="params">(df)</span>:</span></span><br><span class="line">    dayup = <span class="number">1.0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">365</span>):</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">7</span> <span class="keyword">in</span> [<span class="number">6</span>,<span class="number">0</span>]:</span><br><span class="line">            dayup = dayup*(<span class="number">1</span><span class="number">-0.01</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dayup = dayup*(<span class="number">1</span>+df)</span><br><span class="line">    <span class="keyword">return</span> dayup</span><br><span class="line">dayfactor = <span class="number">0.01</span></span><br><span class="line"><span class="keyword">while</span> DayUp(dayfactory) &lt; <span class="number">37.78</span>:</span><br><span class="line">    dayfactor += <span class="number">0.001</span></span><br><span class="line">print(<span class="string">"工作日的努力参数是:&#123;:.3f&#125;"</span>.format(dayfactor))</span><br></pre></td></tr></table></figure>



<h2 id="实例4：文本进度条"><a href="#实例4：文本进度条" class="headerlink" title="实例4：文本进度条"></a>实例4：文本进度条</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">scale = <span class="number">50</span></span><br><span class="line">print(<span class="string">"执行开始"</span>.center(scale//<span class="number">2</span>,<span class="string">"-"</span>))</span><br><span class="line">start = time.perf_counter()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(scale+<span class="number">1</span>):</span><br><span class="line">    a = <span class="string">"*"</span> * i</span><br><span class="line">    b = <span class="string">"."</span> * (scale - i)</span><br><span class="line">    c = (i/scale) * <span class="number">100</span></span><br><span class="line">    dur = time.perf_counter() - start</span><br><span class="line">    print(<span class="string">"\r&#123;:^3.0f&#125;%[&#123;&#125;-&gt;&#123;&#125;]&#123;:.2f&#125;s"</span>.format(c,a,b,dur),end = <span class="string">""</span>)</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">print(<span class="string">"/n"</span>+<span class="string">"执行开始"</span>.center(scale//<span class="number">2</span>,<span class="string">"-"</span>))</span><br></pre></td></tr></table></figure>



<h2 id="实例5：身体质量指数BMI"><a href="#实例5：身体质量指数BMI" class="headerlink" title="实例5：身体质量指数BMI"></a>实例5：身体质量指数BMI</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#BMI    #分支结构是程序的重要框架</span></span><br><span class="line">height,weight = eval(input(<span class="string">"请输入身高（米）和体重（公斤）[逗号隔开]:"</span>))</span><br><span class="line">bmi = weight / pow(height,<span class="number">2</span>)</span><br><span class="line">print(<span class="string">"BMI值为:&#123;:.2f&#125;"</span>.format(bmi))</span><br><span class="line">who,nat = <span class="string">""</span>,<span class="string">""</span></span><br><span class="line"><span class="keyword">if</span> bmi &lt; <span class="number">18.5</span>:</span><br><span class="line">    who, nat = <span class="string">"偏瘦"</span>,<span class="string">"偏瘦"</span></span><br><span class="line"><span class="keyword">elif</span> <span class="number">18.5</span> &lt;= bmi &lt;= <span class="number">24</span>:</span><br><span class="line">    who, nat = <span class="string">"正常"</span>,<span class="string">"正常"</span></span><br><span class="line"><span class="keyword">elif</span> <span class="number">24</span> &lt;= bmi &lt;= <span class="number">25</span>:    <span class="comment"># 多分支条件的覆盖是一个非常重要的问题</span></span><br><span class="line">    who, nat = <span class="string">"正常"</span>,<span class="string">"偏胖"</span></span><br><span class="line"><span class="keyword">elif</span> <span class="number">25</span> &lt;= bmi &lt;= <span class="number">28</span>:</span><br><span class="line">    who, nat = <span class="string">"偏胖"</span>,<span class="string">"偏胖"</span></span><br><span class="line"><span class="keyword">elif</span> <span class="number">28</span> &lt;= bmi &lt;= <span class="number">30</span>:</span><br><span class="line">    who, nat = <span class="string">"偏胖"</span>,<span class="string">"肥胖"</span></span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    who,nat = <span class="string">"肥胖"</span>,<span class="string">"肥胖"</span></span><br><span class="line">print(<span class="string">"BMI指标为：国际'&#123;&#125;',国内'&#123;&#125;'"</span>.format(who,nat))</span><br></pre></td></tr></table></figure>



<h2 id="七段数码管的绘制"><a href="#七段数码管的绘制" class="headerlink" title="七段数码管的绘制"></a>七段数码管的绘制</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#seven</span></span><br><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drawdrg</span><span class="params">()</span>:</span></span><br><span class="line">    turtle.penup()</span><br><span class="line">    turtle.fd(<span class="number">5</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drawline</span><span class="params">(draw)</span>:</span></span><br><span class="line">    drawdrg()</span><br><span class="line">    turtle.pendown() <span class="keyword">if</span> draw <span class="keyword">else</span> turtle.penup()</span><br><span class="line">    turtle.fd(<span class="number">40</span>)</span><br><span class="line">    drawdrg()</span><br><span class="line">    turtle.right(<span class="number">90</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drawdigit</span><span class="params">(digit)</span>:</span></span><br><span class="line">    drawline(<span class="literal">True</span>) <span class="keyword">if</span> digit <span class="keyword">in</span> [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>] <span class="keyword">else</span> drawline(<span class="literal">False</span>)</span><br><span class="line">    drawline(<span class="literal">True</span>) <span class="keyword">if</span> digit <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>] <span class="keyword">else</span> drawline(<span class="literal">False</span>)</span><br><span class="line">    drawline(<span class="literal">True</span>) <span class="keyword">if</span> digit <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>] <span class="keyword">else</span> drawline(<span class="literal">False</span>)</span><br><span class="line">    drawline(<span class="literal">True</span>) <span class="keyword">if</span> digit <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,] <span class="keyword">else</span> drawline(<span class="literal">False</span>)</span><br><span class="line">    turtle.left(<span class="number">90</span>)</span><br><span class="line">    drawline(<span class="literal">True</span>) <span class="keyword">if</span> digit <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>] <span class="keyword">else</span> drawline(<span class="literal">False</span>)</span><br><span class="line">    drawline(<span class="literal">True</span>) <span class="keyword">if</span> digit <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>] <span class="keyword">else</span> drawline(<span class="literal">False</span>)</span><br><span class="line">    drawline(<span class="literal">True</span>) <span class="keyword">if</span> digit <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>] <span class="keyword">else</span> drawline(<span class="literal">False</span>)</span><br><span class="line">    turtle.left(<span class="number">180</span>)</span><br><span class="line">    turtle.penup()</span><br><span class="line">    turtle.fd(<span class="number">40</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drawdata</span><span class="params">(data)</span>:</span></span><br><span class="line">    turtle.pencolor(<span class="string">'red'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">        <span class="keyword">if</span> i == <span class="string">'-'</span>:</span><br><span class="line">            turtle.write(<span class="string">"年"</span>,font=(<span class="string">"Arial"</span>,<span class="number">18</span>,<span class="string">"normal"</span>))</span><br><span class="line">            turtle.pencolor(<span class="string">"green"</span>)</span><br><span class="line">            turtle.fd(<span class="number">40</span>)</span><br><span class="line">        <span class="keyword">elif</span> i == <span class="string">'+'</span>:</span><br><span class="line">            turtle.write(<span class="string">"月"</span>,font=(<span class="string">"Arial"</span>,<span class="number">18</span>,<span class="string">"normal"</span>))</span><br><span class="line">            turtle.pencolor(<span class="string">"blue"</span>)</span><br><span class="line">            turtle.fd(<span class="number">40</span>)</span><br><span class="line">        <span class="keyword">elif</span> i == <span class="string">'='</span>:</span><br><span class="line">            turtle.write(<span class="string">"日"</span>,font=(<span class="string">"Arial"</span>,<span class="number">18</span>,<span class="string">"normal"</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            drawdigit(eval(i))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    turtle.setup(<span class="number">800</span>,<span class="number">500</span>,<span class="number">200</span>,<span class="number">200</span>)</span><br><span class="line">    turtle.penup()</span><br><span class="line">    turtle.fd(<span class="number">-300</span>)</span><br><span class="line">    turtle.pendown()</span><br><span class="line">    turtle.pensize(<span class="number">5</span>)</span><br><span class="line">    drawdata(time.strftime(<span class="string">'%Y-%m+%d='</span>,time.gmtime()))</span><br><span class="line">    turtle.hideturtle()</span><br><span class="line">    turtle.done()</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>



<h2 id="Hamlet词频统计"><a href="#Hamlet词频统计" class="headerlink" title="Hamlet词频统计"></a>Hamlet词频统计</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#calHamLet</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getText</span><span class="params">()</span>:</span></span><br><span class="line">    txt = open(<span class="string">"C:/Users/pikachu/AppData/Local/Programs/Python/Python36-32/hamlet.txt"</span>).read()</span><br><span class="line">    txt = txt.lower()</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> <span class="string">'!"#$%&amp;()*+,-./:;&lt;=&gt;?@[\\]^_‘&#123;|&#125;~'</span>:</span><br><span class="line">        txt.replace(ch,<span class="string">" "</span>)</span><br><span class="line">    <span class="keyword">return</span> txt</span><br><span class="line"></span><br><span class="line">hamlettxt = getText()</span><br><span class="line">words = hamlettxt.split()</span><br><span class="line">counts = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    counts[word] = counts.get(word,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">items = list(counts.items())</span><br><span class="line">items.sort(key = <span class="keyword">lambda</span> x:x[<span class="number">1</span>],reverse = <span class="literal">True</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>):</span><br><span class="line">    word,count = items[i]</span><br><span class="line">    print(<span class="string">"&#123;0:&lt;10&#125;&#123;1:&gt;5&#125;"</span>.format(word,count))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础语法</title>
    <url>/2018/08/02/Python/Python_old/Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>中国大学MOOC：《Python 语言程序设计》课堂笔记</p>
<a id="more"></a>



<blockquote>
<h3 id="编译与解释"><a href="#编译与解释" class="headerlink" title="编译与解释"></a>编译与解释</h3><p>源代码：采用某种编程语言编写的计算机程序</p>
<p>目标代码：计算机可直接执行，人类不可读</p>
<p>编译：将源代码<strong>一次性</strong>转换成目标代码的过程</p>
<p>编译需要<strong>编译器（compiler）</strong>,是一次性翻译，之后不再需要源代码（类似英文翻译）</p>
<p>解释：将源代码<strong>逐条</strong>转换成目标代码同时逐条运行的过程</p>
<p>解释需要<strong>解释器（interpreter）</strong>，每次程序运行时随翻译随执行（类似同声传译）</p>
<p>根据执行方式不同，编程语言分成两种：</p>
<ol>
<li><p>静态语言: C，C++，Java (编译)</p>
<p>特点: 执行时不需要源代码，优化更充分，程序运行速度更快。</p>
</li>
<li><p>脚本语言: Python，JavaScript，PHP (解释)</p>
<p>特点: 执行时需要源代码，维护更灵活。</p>
</li>
</ol>
</blockquote>
<blockquote>
<h3 id="Python的解释器"><a href="#Python的解释器" class="headerlink" title="Python的解释器"></a>Python的解释器</h3><ul>
<li>python –&gt; 官方解释器</li>
<li>CPython –&gt; C语言实现的官方解释器</li>
<li>Jython –&gt; 可以运行在 Java 平台的解释器</li>
<li>IronPython – 可以运行在 .NET 和 Mono 平台</li>
<li>PyPy – Python 实现的 Python 解释器，支持 JIT 即时编译</li>
</ul>
</blockquote>
<blockquote>
<h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><p>Python 语言采用严格的“缩进”来表明程序的格式框架。缩进表达了所属关系。<br>缩进可以使用空格或者 tab 来表示, 但是在一个程序中两者不能混用<br><strong>建议使用 4 个空格</strong></p>
</blockquote>
<blockquote>
<h3 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h3><p>python 共有33个保留字</p>
<table>
<thead>
<tr>
<th>一</th>
<th>二</th>
<th>三</th>
<th>四</th>
</tr>
</thead>
<tbody><tr>
<td>True</td>
<td>def</td>
<td>if</td>
<td>raise</td>
</tr>
<tr>
<td>False</td>
<td>del</td>
<td>import</td>
<td>return</td>
</tr>
<tr>
<td>None</td>
<td>elif</td>
<td>in</td>
<td>try</td>
</tr>
<tr>
<td>and</td>
<td>else</td>
<td>is</td>
<td>while</td>
</tr>
<tr>
<td>as</td>
<td>except</td>
<td>lambda</td>
<td>with</td>
</tr>
<tr>
<td>assert</td>
<td>finally</td>
<td>nonlocal</td>
<td>yield</td>
</tr>
<tr>
<td>break</td>
<td>for</td>
<td>not</td>
<td></td>
</tr>
<tr>
<td>calss</td>
<td>from</td>
<td>or</td>
<td></td>
</tr>
<tr>
<td>continue</td>
<td>global</td>
<td>pass</td>
<td></td>
</tr>
</tbody></table>
</blockquote>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h3><ol>
<li><p><strong>整数类型</strong></p>
<p>取值范围 : [-∞, ∞]</p>
<p>4 种进制表示形式 ：</p>
<ul>
<li><p>二进制 : 0b / 0B (引导符号)</p>
</li>
<li><p>八进制 : 0o / 0O</p>
</li>
<li><p>十进制</p>
</li>
<li><p>十六进制 : 0x / 0X</p>
</li>
</ul>
</li>
<li><p><strong>浮点数类型</strong></p>
<p>浮点数取值范围和精度都存在限制，但是常规计算中可以忽略</p>
<p>浮点数运算存在不确定尾数，不是 bug</p>
<p><code>9.5e2</code> : 浮点数的科学计数法，表示 $9.5*10^2$</p>
</li>
<li><p><strong>复数类型</strong></p>
<p>`z = a + bj</p>
<p><code>z.real</code> 获得实部</p>
<p><code>z.imag</code>  获得虚部</p>
</li>
</ol>
<h3 id="数字类型的操作"><a href="#数字类型的操作" class="headerlink" title="数字类型的操作"></a>数字类型的操作</h3><ol>
<li><p><strong>数值运算操作符</strong></p>
<ul>
<li><p>基本操作符</p>
<p><code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>//</code>(整数除)、<code>%</code>(取余)、<code>**</code>(幂)、</p>
</li>
<li><p>增强赋值操作符</p>
<p><code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>//=</code>、<code>%=</code>、<code>**=</code></p>
</li>
</ul>
</li>
<li><p><strong>内置数值运算函数</strong></p>
<ul>
<li><p><code>abs(x)</code>  绝对值</p>
</li>
<li><p><code>divmod(x,y)</code>  商余，(x//y，x%y)，同时输出商和余数(输出元组)</p>
</li>
<li><p><code>pow(x,y[,z])</code>  幂余，z为取余</p>
</li>
<li><p><code>round(x[,d])</code>  四舍五入, 保留 d 位小数, 省略 d 时返回四舍五入的整数值</p>
</li>
<li><p><code>max(x,y...)</code>  返回最大值</p>
</li>
<li><p><code>min(x,y...)</code>  返回最小值</p>
</li>
</ul>
</li>
<li><p><strong>内置数字类型转换函数</strong></p>
<ul>
<li><p><code>int(x)</code>  将 x 转换为整数，x 可以是<strong>浮点数</strong>(直接舍弃小数)或<strong>字符串</strong></p>
</li>
<li><p><code>float(x)</code>  将 x 转换为浮点数，x 可以是<strong>整数</strong>或<strong>字符串</strong></p>
</li>
</ul>
</li>
</ol>
<h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p><strong>表示形式:</strong> </p>
<ul>
<li><code>&#39;字符串&#39;</code></li>
<li><code>&quot;字符串&quot;</code></li>
<li><code>&#39;&#39;&#39;字符串&#39;&#39;&#39;</code> </li>
<li><code>&quot;&quot;&quot;字符串&quot;&quot;&quot;</code></li>
</ul>
<blockquote>
<p>  python中并没有多行注释的语法, 当三个单引号的字符串不赋给任何变量时, 就被当成是多行注释.</p>
</blockquote>
<p><strong>在字符串中表示单引号或双引号:</strong></p>
<ul>
<li><code>&quot;这里有个单引号(&#39;)&quot;</code> </li>
<li><code>&#39;这里有个双引号(&quot;)&#39;</code></li>
<li><code>&quot;&quot;&quot;这里同时有单引号(&#39;)和双引号(&quot;)&quot;&quot;&quot;</code></li>
</ul>
<p><strong>字符串的索引:</strong> </p>
<ul>
<li>正向递增序号: 从左至右，从 0 开始</li>
<li>反向递减序号: 从右至左，从 -1 开始</li>
</ul>
<p><strong>字符串切片:</strong> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">'pikachu'</span></span><br><span class="line">s[<span class="number">0</span>]      <span class="comment"># 'p'</span></span><br><span class="line">s[<span class="number">0</span>:<span class="number">2</span>]    <span class="comment"># 'pi'</span></span><br><span class="line">s[<span class="number">2</span>:]     <span class="comment"># 'kachu'</span></span><br><span class="line">s[:<span class="number">-1</span>]    <span class="comment"># 'pikach'</span></span><br><span class="line">s[<span class="number">0</span>:<span class="number">-1</span>:<span class="number">2</span>] <span class="comment"># 'pkc'</span></span><br><span class="line">s[::<span class="number">-1</span>]   <span class="comment"># 'uhcakip' (字符串逆序输出)</span></span><br></pre></td></tr></table></figure>

<p><strong>字符串操作符:</strong></p>
<ul>
<li><code>s1 + s2</code> : 连接两个字符串</li>
<li><code>s1 * 3</code> : 重复 s1 三次</li>
<li><code>s1 in s2</code> : 判断 s1 是否为 s2 的子串, 返回 <code>True / False</code></li>
</ul>
<blockquote>
<p>  转义符 <code>\</code> : 表达特定字符的本意<br>  <code>&quot;这里有个双引号(\&quot;)&quot;</code> –&gt;  <code>&quot;这里有个双引号(&quot;)&quot;</code></p>
</blockquote>
<p><strong>内置字符串处理函数：</strong></p>
<ul>
<li><p><code>len(x)</code>    # 返回字符串 x 的长度</p>
</li>
<li><p><code>str(x)</code>    # 将任何类型的 x 转换成字符串的形式。  和 <code>eval()</code>是一对对应的函数</p>
</li>
<li><p><code>hex(x)</code>    # 返回<strong>整数</strong> x 的十六进制小写形式字符串</p>
</li>
<li><p><code>oct(x)</code>    # 返回<strong>整数</strong> x 的八进制小写形式字符串</p>
</li>
<li><p><code>chr(u)</code>    # u 为 Unicode 编码，返回其对应的字符</p>
</li>
<li><p><code>ord(x)</code>    # x 为字符，返回其对应的 Unicode 编码</p>
</li>
</ul>
<p><strong>字符串处理方法：</strong></p>
<ul>
<li><code>str.lower()</code>    # 将字符串中的英文字母全变成小写</li>
<li><code>str.upper()</code>    # 将字符串中的英文字母全变成大写</li>
<li><code>str.split(sep=None)</code>    # 返回一个列表，由 str 根据 sep 被分割的部分组成<ul>
<li><code>&#39;A,B,C&#39;.split(&#39;,&#39;)</code>    输出结果为<code>[&#39;A&#39;,&#39;B&#39;,&#39;C&#39;]</code></li>
</ul>
</li>
<li><code>str.join(iterable)</code>    # 返回一个新字符串, 由 iterable 中的变量每个元素组成, 元素用 str 间隔<ul>
<li><code>&#39;,&#39;.join([a, b, c, d, e])</code>    输出为<code>&#39;a,b,c,d,e&#39;</code></li>
</ul>
</li>
<li><code>str.count(sub)</code>    # 返回子串 sub 在 str 中出现的次数</li>
<li><code>str.replace(old,new)</code>    # 返回字符串 str 副本，将所有 old 子串替换成 new</li>
<li><code>str.center(width[,fillchar])</code>    # 返回 width 长度的字符串, 字符串 str 居中显示，fillchar 为 str 两边的填充字符<ul>
<li><code>&#39;Pikachu&#39;.center(21,&#39;*&#39;)</code>    输出为<code>&#39;*******Piakchu*******&#39;</code></li>
</ul>
</li>
<li><code>str.strip(chars)</code>    # 从 str 左右两侧去掉 chars 中所列出的字符<ul>
<li><code>&#39; hello &#39;.strip(&#39; &#39;)</code> 输出为  <code>&#39;hello&#39;</code></li>
</ul>
</li>
</ul>
<p><strong>字符串类型格式化：</strong></p>
<p>字符串格式化采用 <code>.format()</code> 的方法    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"&#123;&#125;:计算机&#123;&#125;的CPU占用率为&#123;&#125;%"</span>.format(<span class="string">"李明"</span>,<span class="string">"C"</span>,<span class="string">"50"</span>)</span><br><span class="line"><span class="comment"># 上面语句输出为: "李明:计算机C的CPU占用率为50%"</span></span><br></pre></td></tr></table></figure>

<p>{} 称为槽。<br>槽内部对格式化的配置方式：{&lt;参数序号&gt;:&lt;格式控制标记&gt;}</p>
<table>
<thead>
<tr>
<th align="center">：</th>
<th align="center">&lt;填充&gt;</th>
<th align="center">&lt;对齐&gt;</th>
<th align="center">&lt;宽度&gt;</th>
<th align="center">&lt; , &gt;</th>
<th align="center">&lt;.精度&gt;</th>
<th align="center">&lt;类型&gt;</th>
</tr>
</thead>
<tbody><tr>
<td align="center">引导符号</td>
<td align="center">用于填充单个字符</td>
<td align="center">&lt;左对齐，&gt;右对齐，^居中</td>
<td align="center">槽设定的输出宽度</td>
<td align="center">数字的千位分隔符</td>
<td align="center">浮点数小数精度或字符串最大输出长度</td>
<td align="center">整数类型b,c,d,o,x,X  浮点数类型 e,E,f,%</td>
</tr>
</tbody></table>
<p>举个栗子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"&#123;0:=^20&#125;"</span>.format(<span class="string">"Python"</span>)    <span class="comment"># 输出为： '=======Python======='</span></span><br><span class="line"></span><br><span class="line"><span class="string">"&#123;0:,.2f&#125;"</span>.format(<span class="number">123456.789</span>)    <span class="comment"># 输出为:  '123,456.79'</span></span><br></pre></td></tr></table></figure>



<h2 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h2><p>分支结构分为: </p>
<ul>
<li>单分支结构</li>
<li>二分支结构</li>
<li>多分支结构</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单分支结构</span></span><br><span class="line"><span class="keyword">if</span> 条件:</span><br><span class="line">    语句块</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二分支结构</span></span><br><span class="line"><span class="keyword">if</span> 条件:</span><br><span class="line">    语句块<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    语句块<span class="number">2</span></span><br><span class="line"></span><br><span class="line">&lt;表达式<span class="number">1</span>&gt; <span class="keyword">if</span> &lt;条件&gt; <span class="keyword">else</span> &lt;表达式<span class="number">2</span>&gt;  <span class="comment">#二分支结构的紧凑形式</span></span><br><span class="line">guess = eval(input())</span><br><span class="line">print(<span class="string">"猜&#123;&#125;了"</span>.format(<span class="string">"对"</span> <span class="keyword">if</span> guess == <span class="number">99</span> <span class="keyword">else</span> <span class="string">"错"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多分支结构</span></span><br><span class="line"><span class="keyword">if</span> &lt;条件&gt;:    <span class="comment">#使用多分支结构时，要注意多条件之间的包含关系</span></span><br><span class="line">    &lt;语句块<span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">elif</span> &lt;条件&gt;:</span><br><span class="line">    &lt;语句块<span class="number">2</span>&gt;</span><br><span class="line">……</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;语句块N&gt;</span><br></pre></td></tr></table></figure>

<h3 id="条件判断及条件组合"><a href="#条件判断及条件组合" class="headerlink" title="条件判断及条件组合"></a>条件判断及条件组合</h3><p>条件判断</p>
<table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&lt;</td>
<td align="center">小于</td>
</tr>
<tr>
<td align="center">&lt;=</td>
<td align="center">小于等于</td>
</tr>
<tr>
<td align="center">&gt;=</td>
<td align="center">大于等于</td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="center">大于</td>
</tr>
<tr>
<td align="center">==</td>
<td align="center">等于</td>
</tr>
<tr>
<td align="center">!=</td>
<td align="center">不等于</td>
</tr>
</tbody></table>
<p>条件组合<br><code>and(&amp;)</code>，<code>or(|)</code>，<code>not</code></p>
<h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><p>遍历循环</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;循环变量&gt; <span class="keyword">in</span> &lt;遍历结构&gt;:  <span class="comment">#从遍历结构中逐一提取元素，放到循环变量中</span></span><br><span class="line">    &lt;语句块&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(N): <span class="comment">#计数循环N次</span></span><br><span class="line">    &lt;语句块&gt;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(M,N[,K]): <span class="comment">#计数循环特定次[,K为步长]</span></span><br><span class="line">    &lt;语句块&gt;</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> s: <span class="comment">#s为字符串，遍历字符串每个字符</span></span><br><span class="line">    &lt;语句块&gt;</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> ls: <span class="comment">#ls时列表，遍历列表的每个元素</span></span><br><span class="line">    &lt;语句块&gt;</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> fi: <span class="comment">#fi是一个文件标识符（一篇文章），遍历其每行</span></span><br><span class="line">    &lt;语句块&gt;</span><br></pre></td></tr></table></figure>

<p>无限循环</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> &lt;条件&gt;:</span><br><span class="line">    &lt;语句块&gt;</span><br></pre></td></tr></table></figure>

<p>循环控制保留字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">break</span>  <span class="comment">#跳出当前循环</span></span><br><span class="line"><span class="keyword">continue</span>  <span class="comment">#结束当次循环</span></span><br></pre></td></tr></table></figure>

<p>循环的拓展</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;循环变量&gt; <span class="keyword">in</span> &lt;遍历结构&gt;:</span><br><span class="line">    &lt;语句块<span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">else</span>:       <span class="comment">#当循环正常完成后，执行else语句块</span></span><br><span class="line">    &lt;语句块<span class="number">2</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> &lt;条件&gt;:</span><br><span class="line">    &lt;语句块<span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">else</span>:       <span class="comment">#如果循环被break跳出，不执行else语句块</span></span><br><span class="line">    &lt;语句块<span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure>



<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>形式1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    &lt;语句块<span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    &lt;语句块<span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure>
<p>形式2</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    &lt;语句块<span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">except</span>&lt;异常类型&gt;:    <span class="comment">#标注异常类型后，仅响应该异常</span></span><br><span class="line">    &lt;语句块<span class="number">2</span>&gt;       <span class="comment">#异常类型名字等同于变量</span></span><br></pre></td></tr></table></figure>
<p>异常处理的高级使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    &lt;语句块<span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    &lt;语句块<span class="number">2</span>&gt;</span><br><span class="line"><span class="keyword">else</span>:       <span class="comment">#else对应的语句块3在不发生异常时执行</span></span><br><span class="line">    &lt;语句块<span class="number">3</span>&gt;</span><br><span class="line"><span class="keyword">finally</span>:    <span class="comment">#finally对应的语句块4一定执行</span></span><br><span class="line">    &lt;语句块<span class="number">4</span>&gt;</span><br></pre></td></tr></table></figure>



<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数的作用：降低编程难度 和 代码复用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> &lt;函数名&gt;<span class="params">(&lt;参数<span class="params">(<span class="number">0</span>个或多个)</span>&gt;)</span>:</span></span><br><span class="line">    &lt;函数体&gt;</span><br><span class="line">    <span class="keyword">return</span> &lt;返回值&gt;    <span class="comment">#return可以有可以没有</span></span><br></pre></td></tr></table></figure>

<h3 id="函数参数类型"><a href="#函数参数类型" class="headerlink" title="函数参数类型"></a>函数参数类型</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可选参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> &lt;函数名&gt;<span class="params">(&lt;非可选参数&gt;，&lt;可选参数&gt;)</span>:</span> <span class="comment">#定义时需给可选参数一个默认值</span></span><br><span class="line">    &lt;函数体&gt;</span><br><span class="line">    <span class="keyword">return</span> &lt;返回值&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可变参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> &lt;函数名&gt;<span class="params">(&lt;参数&gt;,*b)</span>:</span></span><br><span class="line">    &lt;函数体&gt;</span><br><span class="line">    <span class="keyword">return</span> &lt;返回值&gt;</span><br></pre></td></tr></table></figure>
<p>函数调用时，参数传递的方式有<strong>位置传递</strong>和<strong>名称传递</strong></p>
<h3 id="局部变量的全局变量："><a href="#局部变量的全局变量：" class="headerlink" title="局部变量的全局变量："></a>局部变量的全局变量：</h3><ol>
<li><p>局部变量：函数中的变量</p>
</li>
<li><p>全局变量：函数外的变量</p>
</li>
<li><p>局部变量和全局变量可能重名但不同</p>
</li>
<li><p>函数运算结束后，局部变量被释放</p>
</li>
<li><p>可以使用 <code>global</code> 保留字在函数内部使用全局变量</p>
</li>
<li><p>如果局部变量为组合数据类型且未被真实创建时，等同于全局变量</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ls = [<span class="string">'F'</span>,<span class="string">'f'</span>]  <span class="comment">#通过使用[]真实创建了一个全局变量列表ls</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a)</span>:</span></span><br><span class="line">    ls.append(a)  <span class="comment">#此处ls为列表类型，未被真实创建，等同于全局变量</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">func(<span class="string">'C'</span>)</span><br><span class="line">print(ls)  <span class="comment">#结果为['F','f','C']</span></span><br></pre></td></tr></table></figure>

<h3 id="lambda-函数"><a href="#lambda-函数" class="headerlink" title="lambda 函数"></a>lambda 函数</h3><p>lambda 函数是一种匿名函数，即没有名字的函数</p>
<p>使用 <code>lambda</code> 保留字定义，返回值是函数名</p>
<p>lambda 用于定义简单的，可以在一行内表示的函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;函数名&gt; = <span class="keyword">lambda</span> &lt;参数&gt;:&lt;表达式&gt;</span><br><span class="line">f = <span class="keyword">lambda</span> x,y : x+y</span><br><span class="line">f(<span class="number">10</span>,<span class="number">15</span>)  <span class="comment">#结果为 25</span></span><br></pre></td></tr></table></figure>


<blockquote>
<p>  代码复用: <strong>函数</strong> 和 <strong>对象</strong> 是代码复用的两种主要形式</p>
<ul>
<li><p>函数：在代码层面建立了初步抽象</p>
</li>
<li><p>对象：在函数之上再次组织进行抽象</p>
<p>模块化设计：通过函数或对象封装将程序划分为模块及模块间的表达</p>
<p>模块内部<strong>紧耦合</strong>，模块之间<strong>松耦合</strong></p>
</li>
</ul>
</blockquote>
<h3 id="函数递归"><a href="#函数递归" class="headerlink" title="函数递归"></a>函数递归</h3><p>定义：函数定义中调用函数自身的方式</p>
<p>函数递归的两个特征：</p>
<ul>
<li>递归基例</li>
<li>递归链条</li>
</ul>
<p>函数递归的实现：函数 + 分支语句</p>
<h2 id="组合数据类型"><a href="#组合数据类型" class="headerlink" title="组合数据类型"></a>组合数据类型</h2><h2 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h2><p>集合类型的特点：</p>
<ul>
<li>集合是多个元素的无序组合</li>
<li>集合中没有相同的元素</li>
<li>集合类型是由不可变数据类型组成的</li>
</ul>
<p>集合用 <code>{}</code> 表示，元素中间用,分隔<br>集合用 <code>{}</code> 建立，也可用 <code>set()</code> 建立集合<br>建立空集合只能用 <code>set()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = &#123;<span class="string">"python"</span>,<span class="number">123</span>,(<span class="string">"python"</span>,<span class="number">123</span>)&#125;</span><br><span class="line">*&#123;<span class="number">123</span>,<span class="string">'python,("python",123)&#125;*</span></span><br><span class="line"><span class="string">B = set("pypy123")</span></span><br><span class="line"><span class="string">*&#123;'</span><span class="number">1</span><span class="string">','</span>P<span class="string">','</span><span class="number">2</span><span class="string">','</span><span class="number">3</span><span class="string">','</span>y<span class="string">'&#125;*</span></span><br></pre></td></tr></table></figure>

<h3 id="集合操作符"><a href="#集合操作符" class="headerlink" title="集合操作符"></a>集合操作符</h3><p>(并)S|T : 返回一个新集合，包括在集合 S 和 T 中的所有元素</p>
<p>(差)S-T : 返回一个新集合，包括在集合 S 但不在 T 中的元素</p>
<p>(交)S&amp;T : 返回一个新集合，包括同时在集合 S 和 T 中的元素</p>
<p>(补)S^T : 返回一个新集合，包括集合 S 和 T 中的非相同元素</p>
<p>4个增强操作符：</p>
<p><code>S|=T</code>：更新集合 S，包括在集合 S 和 T 中的所有元素</p>
<p><code>S-=T</code>：更新集合 S，包括在集合 S 但不在 T 中的元素</p>
<p><code>S&amp;=T</code>：更新集合 S，包括同时在集合 S 和 T 中的元素</p>
<p><code>S^=T</code>：更新集合 S，包括集合 S 和 T 中的非相同元素</p>
<h3 id="集合处理方法"><a href="#集合处理方法" class="headerlink" title="集合处理方法"></a>集合处理方法</h3><p><code>S.add(x)</code>  如果 x 不在集合中，将 x 添加到 S 中</p>
<p><code>S.discard(x)</code>  移除 S 中元素 x，如果 x 不在集合 S 中，不报错</p>
<p><code>S.remove(x)</code>  移除 S 中元素 x，如果 x 不在集合 S 中，则产生 KeyError 异常</p>
<p><code>S.clear()</code>  移除 S 中所有元素</p>
<p><code>S.pop()</code>  随机返回 S 中的一个元素，更新 S，如果 S 为空产生 KeyError 异常</p>
<p><code>S.copy()</code>  返回集合 S 的一个副本</p>
<p><code>len(S)</code>  返回集合 S 的元素个数</p>
<p><code>x in S</code>  判断 x 是否在集合 S 中，返回 True 或 False</p>
<p><code>x not in S</code>  判断 x 是否在集合 S 中，返回 True或 False</p>
<p><code>set(x)</code>  将其他数据变量 x 转变为集合类型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = &#123;<span class="string">"ha"</span>,<span class="string">"ha"</span>,<span class="number">666</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> A    <span class="comment">#一般情况下遍历集合用for  in  就可以</span></span><br><span class="line">    print(i,end=<span class="string">""</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(A.pop(),end=<span class="string">""</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h3 id="集合类型应用场景"><a href="#集合类型应用场景" class="headerlink" title="集合类型应用场景"></a>集合类型应用场景</h3><ol>
<li><p>包含关系比较</p>
</li>
<li><p><strong>数 据 去 重</strong>（集合类型最重要的应用）</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ls = [<span class="string">'p'</span>,<span class="string">'p'</span>,<span class="string">'y'</span>,<span class="number">123</span>]</span><br><span class="line">S = set(ls)  <span class="comment">#将列表类型转换成集合类型</span></span><br><span class="line"></span><br><span class="line">lt = list(S)  <span class="comment">#将集合转换为列表</span></span><br></pre></td></tr></table></figure>






<h1 id="文件及数据格式化"><a href="#文件及数据格式化" class="headerlink" title="文件及数据格式化"></a>文件及数据格式化</h1><h2 id="文件的类型"><a href="#文件的类型" class="headerlink" title="文件的类型"></a>文件的类型</h2><p>文本文件和二进制文件（文件的两种展示方式）</p>
<p>文本文件是由特定编码组成的文件，如 <code>.txt</code>、<code>.py</code>文件</p>
<p>二进制文件直接由 0 和 1 组成，如 <code>.avi</code>、<code>.png</code> 文件等</p>
<h2 id="文件的打开关闭"><a href="#文件的打开关闭" class="headerlink" title="文件的打开关闭"></a>文件的打开关闭</h2><p>1、文件的打开</p>
<p><code>变量名 = open(文件名, 打开模式)</code></p>
<p>2、文件的打开模式</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>‘r’</td>
<td>只读模式，默认值，若文件不存在，返回 FileNotFoundError</td>
</tr>
<tr>
<td>‘w’</td>
<td>覆盖写模式，文件不存在则创建，存在则完全覆盖</td>
</tr>
<tr>
<td>‘x’</td>
<td>创建写模式，文件不存在则创建，存在则返回 FileExistsError</td>
</tr>
<tr>
<td>‘a’</td>
<td>追加写模式，文件不存在则创建，存在则在文件最后追加内容</td>
</tr>
<tr>
<td>‘t’</td>
<td>文本文件模式，默认值</td>
</tr>
<tr>
<td>‘b’</td>
<td>二进制文件模式</td>
</tr>
<tr>
<td>‘+’</td>
<td>与 r/w/x/a 连用，在原功能基础上增加读写功能</td>
</tr>
</tbody></table>
<p>3、文件的关闭</p>
<p><code>变量名.close()</code></p>
<p>4、文件的读取</p>
<p><code>变量名.read(size)</code>    读入全部内容，如果给出参数，读入前 size 长度</p>
<p><code>变量名.rendline(size)</code>   读入一行内容，如果给出参数，读入该行前 size 长度</p>
<p><code>变量名.readlines(hint)</code>   读入所有行，以每行为元素形成列表，如果给出参数，读入前 hint 行</p>
<hr>
<p><code>a.wtite(s)</code>    向文件写入一个字符串或字节流</p>
<p><code>a.writelines(lines)</code>    将一个元素全为字符串的列表写入文件</p>
<p><code>a.seek(offset)</code>    改变当前文件操作指针的位置，0 - 文件开头； 1 - 当前位置； 2 - 文件结尾</p>
<p>5、一维数据</p>
<p>一维数据的表示：列表类型（有序）、集合类型（无序）</p>
<p>一维数据的存储：空格分隔，逗号分隔，或者特殊字符分隔</p>
<p>使用任何一种符号进行分隔都有缺点，就是无法控制文本中不出现与分隔符相同的字符</p>
<p>一维数据的处理：</p>
<p>从空格分隔的文件中读入数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">txt = open(fname).read()</span><br><span class="line">ls = txt.split()</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<p>从特殊符号分隔的文件中读入数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">txt = open(fname).read()</span><br><span class="line">ls = txt.split(<span class="string">"$"</span>)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<p>采用空格分隔方式将数据写入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ls = [<span class="string">'中国'</span>，<span class="string">'美国'</span>,<span class="string">'日本'</span>]</span><br><span class="line">f = open(fname,<span class="string">'w'</span>)</span><br><span class="line">f.write(<span class="string">' '</span>.join(ls))</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<p>采用特殊符号分隔方式将数据写入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ls = [<span class="string">'中国'</span>，<span class="string">'美国'</span>,<span class="string">'日本'</span>]</span><br><span class="line">f = open(fname,<span class="string">'w'</span>)</span><br><span class="line">f.write(<span class="string">'$'</span>.join(ls))</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法</title>
    <url>/2018/08/01/%E5%85%B6%E5%AE%83%E7%AC%94%E8%AE%B0/Markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>用 markdown 写笔记，简直爽歪歪</p>
<a id="more"></a>

<h1 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h1><pre><code># 这是一级标题
## 这是二级标题
### 这是三级标题
#### 这是四级标题
##### 这是五级标题
###### 这是六级标题

标题最多六级</code></pre><h1 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h1><pre><code>1.倾斜
    * 这样倾斜 *
2.加粗
    ** 这是加粗 **
3.倾斜加粗
    *** 这是倾斜加粗 ***
4.删除线
    ~~ 这是删除线 ~~</code></pre><h1 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h1><pre><code>&gt; 这是引用的内容
&gt;&gt; 这个也是引用的内容

引用可以嵌套</code></pre><h1 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h1><pre><code>三个或者三个以上的 - 或者 * 都可以
---
这个东西就是分割线
----
这个东西也是分割线</code></pre><h1 id="五、代码"><a href="#五、代码" class="headerlink" title="五、代码"></a>五、代码</h1><pre><code>单行代码  ` 代码内容 `</code></pre><hr>
<pre><code>多行代码

    这是三个 `

        代码内容

    这也是三个 `</code></pre><p>下面我就试一下单行代码和多行代码</p>
<pre><code>1.单行代码 </code></pre><p><code>print(&quot;Hello World&quot;)</code></p>
<pre><code>2.多行代码</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input(&quot;请输入我爱你:&quot;)</span><br><span class="line">print(&quot;I Love You&quot;)</span><br></pre></td></tr></table></figure>
<pre><code>2.多行代码(加高亮)</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">input(<span class="string">"请输入我爱你:"</span>)</span><br><span class="line">print(<span class="string">"I Love You"</span>)</span><br></pre></td></tr></table></figure>



<h1 id="六、超链接"><a href="#六、超链接" class="headerlink" title="六、超链接"></a>六、超链接</h1><p>书写格式：<code>[链接名称](链接网址)</code></p>
<p>例：<a href="https://www.baidu.com/" target="_blank" rel="noopener">百度一下</a></p>
<hr>
<pre><code>另外还有关于
    列表
    表格
    图片

    流程图
等内容，现在用到的不多，以后再做记录。</code></pre>]]></content>
      <categories>
        <category>其他技术</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
