<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JSON</title>
    <url>/2021/01/05/Java/JSON/</url>
    <content><![CDATA[<p>JSON：<strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation <code>JavaScript对象表示法</code></p>
<a id="more"></a>

<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>简介：</p>
<ul>
<li><p>JSON 是纯文本的信息</p>
</li>
<li><p>JSON 是存储和交换文本信息的语法，类似于XML</p>
</li>
<li><p>JSON 比 XML 更小，更快，更易解析</p>
</li>
</ul>
<h4 id="JSON定义："><a href="#JSON定义：" class="headerlink" title="JSON定义："></a>JSON定义：</h4><ul>
<li><p>对象形式 : <code>{&quot;name&quot;:&quot;jack&quot;, &quot;age&quot;:22, &quot;gender&quot;:true}</code></p>
<ul>
<li>键 : 只能是字符串</li>
<li>值:<ol>
<li>数字（整数或浮点数）</li>
<li>字符串（在双引号中）</li>
<li>逻辑值（true 或 false）</li>
<li>数组（在中括号中）</li>
<li>对象（在大括号中）</li>
<li>null</li>
</ol>
</li>
</ul>
</li>
<li><p>数组形式 : <code>[&quot;dog&quot;, &quot;cat&quot;]</code></p>
<ul>
<li>键: 数组索引(从0开始的数字)</li>
<li>值: 数组中的元素</li>
</ul>
</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本定义格式</span></span><br><span class="line">&#123;"name":"jack","age":22,"gender":true&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌套定义格式</span></span><br><span class="line">&#123;<span class="attr">"persons"</span>:[</span><br><span class="line">    &#123;<span class="attr">"name"</span>:<span class="string">"张三"</span>,<span class="attr">"age"</span>:<span class="number">22</span>,<span class="attr">"gender"</span>:<span class="literal">true</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">"name"</span>:<span class="string">"李四"</span>,<span class="attr">"age"</span>:<span class="number">23</span>,<span class="attr">"gender"</span>:<span class="literal">true</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">"name"</span>:<span class="string">"王五"</span>,<span class="attr">"age"</span>:<span class="number">24</span>,<span class="attr">"gender"</span>:<span class="literal">true</span>&#125;</span><br><span class="line">]&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="获取-JSON-中的数据"><a href="#获取-JSON-中的数据" class="headerlink" title="获取 JSON 中的数据"></a>获取 JSON 中的数据</h4><ol>
<li><code>JSON对象.键名</code></li>
<li><code>JSON对象[&quot;键名&quot;]</code></li>
</ol>
<hr>
<h4 id="JSON-和-Java对象-相互转换"><a href="#JSON-和-Java对象-相互转换" class="headerlink" title="JSON 和 Java对象 相互转换"></a>JSON 和 Java对象 相互转换</h4><ul>
<li><p>JSON 解析器：</p>
<ul>
<li>Jsonlib：官方提供</li>
<li>fastjson：阿里提供</li>
<li>Jackson：SpringMVC内置</li>
<li>Gson：谷歌提供</li>
</ul>
</li>
</ul>
<ul>
<li><p>JSON 转为 Java 对象 (使用 Jackson)</p>
<ol>
<li><p>导入 Jackson 的相关坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--以下【三个jar包紧密依赖】同时存在--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ul>
<ol start="2">
<li><p>创建 Jackson 核心对象 <code>ObjectMapper</code></p>
</li>
<li><p>调用 <code>ObjectMapper</code> 的相关方法进行转换 : <code>readValue( JSON 字符串数据,Class)</code></p>
</li>
</ol>
<ul>
<li><p>Java 对象转换 JSON</p>
<ol>
<li><p>导坐标 (同上)</p>
</li>
<li><p>创建 Jackson 核心对象 <code>ObjectMapper</code></p>
</li>
<li><p>调用 <code>ObjectMapper</code> 的相关方法进行转换</p>
<ol>
<li><code>writeValue(参数1，obj)</code> : 把 obj 对象转换为 JSON 字符串, 然后<pre><code>根据参数1不同：
    File：把 JSON 并保存到指定的文件
    Writer：把 JSON 放到字符输出流
    OutputStream：把 JSON 放到字节输出流</code></pre></li>
<li><code>writeValueAsString(obj)</code>：将对象转为 JSON 字符串</li>
</ol>
</li>
<li><p>注解：</p>
<ol>
<li><code>@JsonIgnore</code>：排除属性</li>
<li><code>@JsonFormat</code>：属性值的格式化<ul>
<li><code>@JsonFormat(pattern = &quot;yyyy-MM-dd&quot;)</code></li>
</ul>
</li>
</ol>
</li>
<li><p>复杂 Java 对象转换</p>
<ol>
<li>List: 转换后为 JSON 数组</li>
<li>Map: 转换后为 JSON 对象</li>
</ol>
</li>
</ol>
</li>
</ul>
]]></content>
      <tags>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 安装过程&amp;遇到的问题</title>
    <url>/2020/11/25/Java/Mysql%20%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B&amp;%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>MySQL安装过程及遇到的问题</p>
<a id="more"></a>



<h3 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h3><blockquote>
<p>安装方式:命令行安装的方式</p>
</blockquote>
<ol>
<li><p>把下载的压缩包解压到一个文件夹(<code>D:\develop\MySQL</code>)里面, 此时文件夹中没有<code>data目录</code>和<code>ini文件</code></p>
</li>
<li><p>在MySQL目录下新建 <code>my.ini</code> 文件, 并复制以下内容</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#设置3306端</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">port</span> = <span class="number">3306</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 设置mysql的安装目录</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">basedir</span>=D:\develop\MySQL</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 设置mysql数据库的数据的存放目录</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">datadir</span>=D:\develop\MySQL\data</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 允许最大连接数</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">max_connections</span>=<span class="number">200</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 服务端使用的字符集默认为8比特编码的latin1字符集</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">character-set-server</span>=utf8</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建新表时将使用的默认存储引擎</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">default-storage-engine</span>=INNODB</span><br><span class="line"> </span><br><span class="line"><span class="attr">sql_mode</span>=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</span><br><span class="line"> </span><br><span class="line"><span class="section">[mysql]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 设置mysql客户端默认字符集</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">default-character-set</span>=utf8</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置MySQL的环境变量</p>
<ul>
<li>在系统变量中新建:<ul>
<li>变量名: <code>MySQL_HOME</code> </li>
<li>变量值: <code>D:\develop\MySQL</code></li>
</ul>
</li>
<li>在系统变量 –&gt; Path 中新建: <code>D:\develop\MySQL\bin</code></li>
</ul>
</li>
<li><p>以管理员身份打开cmd</p>
<ol>
<li>cd 到 <code>D:\develop\MySQL\bin</code></li>
<li>运行 <code>mysqld --install</code> , 提示 <code>Services successfully installed</code> 说明安装成功, 如果提示已存在, 先运行 <code>mysqld --remove</code>, 再运行 <code>mysqld --install</code></li>
<li>运行 <code>mysqld --initialize</code>, 生成 <code>data</code> 目录</li>
<li>运行 <code>net start mysql</code> 启动服务</li>
</ol>
</li>
<li><p>修改MySQL密码</p>
<ol>
<li>运行 <code>net stop mysql</code> 停止服务</li>
<li>运行 <code>mysqld --skip-grant-tables</code> 开启无密码的mysql</li>
<li>以管理员身份打开另一个cmd窗口, 运行 <code>mysql -u root -p</code> 回车, 不用输入密码, 直接回车</li>
<li>运行 <code>update mysql.user set authentication_string=password(&quot;root&quot;) where user=&quot;root&quot;;</code> 更新root账户的密码为root</li>
<li>运行 <code>flush privileges;</code> 执行刷新权限</li>
<li>运行 <code>quit;</code> 结束本次操作</li>
</ol>
</li>
<li><p>在密码的情况下修改密码</p>
<ol>
<li>运行 <code>mysql -u root -p</code>, 输入密码 root, 进入mysql操作界面</li>
<li>依次运行下面命令, 就把密码更新成了 123456<ol>
<li><code>SET PASSWORD = PASSWORD(&#39;123456&#39;);</code></li>
<li><code>ALTER USER &#39;root&#39;@&#39;localhost&#39; PASSWORD EXPIRE NEVER;</code></li>
<li><code>flush privileges;</code></li>
</ol>
</li>
<li>运行 <code>quit;</code> 退出, 大功告成!</li>
</ol>
</li>
</ol>
<h3 id="遇到的问题及解决方案"><a href="#遇到的问题及解决方案" class="headerlink" title="遇到的问题及解决方案:"></a>遇到的问题及解决方案:</h3><ol>
<li><p>运行 <code>mysqld --install</code> 时弹窗提示</p>
<ul>
<li>“无法启动此程序，因为计算机丢失<code>MSVCP120.dll</code>“;  </li>
<li>“无法启动此程序，因为计算机丢失<code>MSVCR120.dll</code>“;</li>
</ul>
<p>解决方案:</p>
<ul>
<li>这种错误是由于未安装<code>vcredist</code>引起的（而且版本是 2013版，32位/64位）；</li>
<li>从微软官网下载 <code>vcredist 2013</code>: <a href="https://www.microsoft.com/zh-CN/download/details.aspx?id=40784" target="_blank" rel="noopener">https://www.microsoft.com/zh-CN/download/details.aspx?id=40784</a></li>
<li>根据电脑选择 32 or 64 位进行安装</li>
<li>然后重新运行<code>mysqld --install</code>，成功解决.</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>bugfix</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Python第三方库</title>
    <url>/2020/09/22/Python/Python_old/Python%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/</url>
    <content><![CDATA[<a id="more"></a>



<h2 id="pyinstaller"><a href="#pyinstaller" class="headerlink" title="pyinstaller"></a>pyinstaller</h2><p>将<code>.py</code>文件打包成可执行文件(<code>.exe</code>)的库</p>
<blockquote>
<p>  不只是windows平台, linux 和 macos 平台都可以使用</p>
</blockquote>
<p>基本使用方法: </p>
<ol>
<li>在<code>.py</code>文件所在的目录打开<code>cmd</code></li>
<li>使用命令: <code>pyinstaller -F 文件名</code></li>
</ol>
<p>pyinstaller库常用参数:</p>
<ul>
<li><code>-h</code> : 查看帮助</li>
<li><code>--clean</code> : 清理</li>
<li><code>-D, --onedir</code> : 默认值, 生成dist文件夹</li>
<li><code>-F, --onefile</code> : 在dist文件夹中只生成独立的打包文件</li>
<li><code>-i&lt;图标文件名.ico&gt;</code> : 指定打包文件使用的图标(icon)文件</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>pyinstaller库</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC_请求</title>
    <url>/2020/07/25/Java/3.SSM%E6%A1%86%E6%9E%B6/SpringMVC_%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<p>SpringMVC 请求参数的绑定 &amp; 处理请求常用注解</p>
<a id="more"></a>



<h1 id="SpringMVC-请求"><a href="#SpringMVC-请求" class="headerlink" title="SpringMVC_请求"></a>SpringMVC_请求</h1><h2 id="请求参数的绑定"><a href="#请求参数的绑定" class="headerlink" title="请求参数的绑定"></a>请求参数的绑定</h2><p><strong>绑定机制：</strong></p>
<ul>
<li><strong>请求参数 ==&gt; Controller中相关方法的参数</strong></li>
</ul>
<p><strong>支持的数据类型：</strong></p>
<ul>
<li><p>基本数据类型 / String类型</p>
<ul>
<li><code>请求参数名称</code> 和 <code>方法中参数名</code>相同</li>
<li>区分大小写</li>
</ul>
</li>
<li><p>实体类（JavaBean）</p>
</li>
<li><p>Controller中方法的参数类型为JavaBean的类型</p>
<ul>
<li><p><code>请求参数名称</code> 和 <code>JavaBean的属性名称</code>需要一致</p>
</li>
<li><p>如果一个JavaBean类中包含其他的引用类型，那么请求参数名称要写成：<code>对象.属性</code> 例如：<br><code>address.name</code></p>
</li>
</ul>
</li>
<li><p>集合数据类型（List、map集合等）</p>
<ul>
<li>如果集合是JavaBean的一个属性, 请求参数名和集合属性名相同</li>
</ul>
</li>
</ul>
<hr>
<p><strong>请求参数中文乱码的解决</strong>：</p>
<p>在web.xml中配置一个filter</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置过滤器，解决中文乱码的问题 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 指定字符集 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>自定义类型转换器：</strong></p>
<blockquote>
<p>表单提交的任何数据类型全部都是字符串类型，但是后台定义Integer类型，数据也可以封装上，说明Spring框架内部会默认进行数据类型转换。</p>
<p>但是并不是所有的字符串都可以被成功转换, 有些时候需要自定义类型转换器</p>
</blockquote>
<p>1、自己写一个类，并<strong>实现Converter的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 把字符串转换成日期的转换器</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> pika</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToDateConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Date</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 进行类型转换的方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        <span class="keyword">if</span>(source == <span class="keyword">null</span>) &#123;</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数不能为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">            <span class="comment">// 解析字符串</span></span><br><span class="line">            Date date = df.parse(source);</span><br><span class="line">            <span class="keyword">return</span> date;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"类型转换错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2、注册自定义的类型转换器，在springmvc.xml配置文件中编写配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注册自定义类型转换器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conversionService"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"converters"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"cn.pika.utils.StringToDateConverter"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启Spring对MVC注解的支持 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">"conversionService"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>在控制器中使用原生的ServletAPI对象</strong></p>
<ul>
<li>只需要在控制器的方法参数定义<code>HttpServletRequest</code>和<code>HttpServletResponse</code>对象即可</li>
</ul>
<h2 id="SpringMVC常用注解"><a href="#SpringMVC常用注解" class="headerlink" title="SpringMVC常用注解"></a>SpringMVC常用注解</h2><p> <strong>RequestParam 注解</strong></p>
<ul>
<li><p>作用：把请求中的指定名称的参数传递给控制器中的形参赋值</p>
</li>
<li><p>属性</p>
<ul>
<li>value<strong>/</strong>name：请求参数的名称, 不写则默认为形参的名称</li>
<li>required：请求参数中是否必须提供此参数，默认值是true，必须提供</li>
</ul>
</li>
<li><p>defaultValue：参数的默认值</p>
</li>
<li><p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 接收请求</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(path=<span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(@RequestParam(value=<span class="string">"username"</span>,required=<span class="keyword">false</span>)</span>String name) </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"aaaa"</span>);</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p><strong>RequestBody 注解</strong></p>
<ul>
<li><p>作用：用于获取请求体的内容（注意：get方法不可以）</p>
</li>
<li><p>属性</p>
<ul>
<li>required：是否必须有请求体，默认值是true</li>
</ul>
</li>
<li><p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 接收请求</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(path=<span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(@RequestBody String body)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"aaaa"</span>);</span><br><span class="line">    System.out.println(body);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p><strong>PathVariable 注解</strong></p>
<ul>
<li><p>作用：拥有绑定url中的占位符的。例如：url中有/delete/{id}，{id}就是占位符</p>
</li>
<li><p>属性</p>
<ul>
<li>value：指定url中的占位符名称</li>
</ul>
</li>
<li><p>Restful风格的URL</p>
<ul>
<li>请求路径一样，可以根据不同的请求方式去执行后台的不同方法</li>
<li>restful风格的URL优点<ul>
<li>结构清晰</li>
<li>符合标准</li>
<li>易于理解</li>
<li>扩展方便</li>
</ul>
</li>
</ul>
</li>
<li><p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;a href="user/hello/1"&gt;入门案例&lt;/a&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 接收请求</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(path=<span class="string">"/hello/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(@PathVariable(value=<span class="string">"id"</span>)</span> String id) </span>&#123;</span><br><span class="line">    System.out.println(id);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p><strong>RequestHeader 注解</strong></p>
<ul>
<li><p>作用：获取指定请求头的值</p>
</li>
<li><p>属性</p>
<ul>
<li>value：请求头的名称</li>
</ul>
</li>
<li><p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path=<span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(@RequestHeader(value=<span class="string">"Accept"</span>)</span> String header) </span>&#123;</span><br><span class="line">    System.out.println(header);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p><strong>CookieValue 注解</strong></p>
<ul>
<li><p>作用：用于获取指定cookie的名称的值</p>
</li>
<li><p>属性</p>
</li>
<li><p>value：cookie的名称</p>
</li>
<li><p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path=<span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(@CookieValue(value=<span class="string">"JSESSIONID"</span>)</span> String cookieValue) </span>&#123;</span><br><span class="line">    System.out.println(cookieValue);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p> <strong>ModelAttribute 注解</strong></p>
<ul>
<li><p>作用</p>
<ul>
<li>出现在方法上：表示当前方法会在控制器方法执行前执行。</li>
<li>出现在参数上：获取指定的数据给参数赋值。</li>
</ul>
</li>
<li><p>应用场景</p>
<ul>
<li>当提交表单数据不是完整的实体数据时，保证没有提交的字段使用数据库原来的数据。</li>
</ul>
</li>
<li><p>具体的代码</p>
<p>1、修饰的方法有返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 作用在方法，先执行</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">showUser</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"showUser执行了..."</span>);</span><br><span class="line">    <span class="comment">// 模拟从数据库中查询对象</span></span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setName(<span class="string">"哈哈"</span>);</span><br><span class="line">    user.setPassword(<span class="string">"123"</span>);</span><br><span class="line">    user.setMoney(<span class="number">100</span>d);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 修改user的方法</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> cookieValue</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(path=<span class="string">"/updateUser"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">updateUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、修饰的方法没有返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 作用在方法，先执行</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showUser</span><span class="params">(String name,Map&lt;String, User&gt; map)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"showUser执行了..."</span>);</span><br><span class="line">    <span class="comment">// 模拟从数据库中查询对象</span></span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setName(<span class="string">"哈哈"</span>);</span><br><span class="line">    user.setPassword(<span class="string">"123"</span>);</span><br><span class="line">    user.setMoney(<span class="number">100</span>d);</span><br><span class="line">    map.put(<span class="string">"abc"</span>, user);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 修改用户的方法</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> cookieValue</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(path=<span class="string">"/updateUser"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">updateUser</span><span class="params">(@ModelAttribute(value=<span class="string">"abc"</span>)</span> User user) </span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p><strong>SessionAttributes 注解</strong></p>
<ul>
<li><p>作用：用于多次执行控制器方法间的参数共享</p>
</li>
<li><p>属性</p>
<ul>
<li>value：指定存入属性的名称</li>
</ul>
</li>
<li><p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(path=<span class="string">"/user"</span>)</span><br><span class="line"><span class="meta">@SessionAttributes</span>(value= &#123;<span class="string">"username"</span>,<span class="string">"password"</span>,<span class="string">"age"</span>&#125;,types=</span><br><span class="line">&#123;String<span class="class">.<span class="keyword">class</span>,<span class="title">Integer</span>.<span class="title">class</span>&#125;) // 把数据存入到<span class="title">session</span>域对象中</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 向session中存入值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(path=<span class="string">"/save"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">save</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"向session域中保存数据"</span>);</span><br><span class="line">        model.addAttribute(<span class="string">"username"</span>, <span class="string">"root"</span>);</span><br><span class="line">        model.addAttribute(<span class="string">"password"</span>, <span class="string">"123"</span>);</span><br><span class="line">        model.addAttribute(<span class="string">"age"</span>, <span class="number">20</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 从session中获取值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(path=<span class="string">"/find"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">find</span><span class="params">(ModelMap modelMap)</span> </span>&#123;</span><br><span class="line">        String username = (String) modelMap.get(<span class="string">"username"</span>);</span><br><span class="line">        String password = (String) modelMap.get(<span class="string">"password"</span>);</span><br><span class="line">        Integer age = (Integer) modelMap.get(<span class="string">"age"</span>);</span><br><span class="line">        System.out.println(username + <span class="string">" : "</span>+password +<span class="string">" : "</span>+age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 清除值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(path=<span class="string">"/delete"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">delete</span><span class="params">(SessionStatus status)</span> </span>&#123;</span><br><span class="line">        status.setComplete();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Filter &amp; Listener</title>
    <url>/2020/06/29/Java/2.JavaWeb/Filter%20&amp;%20Listener/</url>
    <content><![CDATA[<p>Filter 和 LIstener 是 JavaWeb 的两个重要组成部分</p>
<a id="more"></a>

<h1 id="Filter-amp-Listener"><a href="#Filter-amp-Listener" class="headerlink" title="Filter &amp; Listener"></a>Filter &amp; Listener</h1><blockquote>
<p>Filter： 过滤器</p>
<p>Listener：监听器</p>
</blockquote>
<h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p><strong>概念：</strong>在web中，当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能</p>
<p><strong>作用：</strong>一般用于完成一些通用的操作，如：登录验证，统一编码处理，敏感字符过滤…</p>
<p><strong>快速入门：</strong>(基于注解)</p>
<ol>
<li><p>新建一个java文件，实现 <code>Filter</code> 接口（<code>javax.Servlet</code>包），实现方法（<code>init()</code>, <code>doFilter()</code>, <code>destroy()</code>）</p>
</li>
<li><p>然后用 <code>@WebFilter(&quot;/*&quot;)</code> 注解标识这个类是一个过滤器，并配置过滤资源路径</p>
</li>
<li><p>在 <code>doFilter()</code> 方法里面添加过滤器的功能，并使用 <code>filterChain.doFilter()</code> 执行<strong>放行</strong></p>
</li>
</ol>
<h4 id="Filter细节"><a href="#Filter细节" class="headerlink" title="Filter细节"></a>Filter细节</h4><p><strong>Filter的xml配置：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filterDemo1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>cn.pika.FilterDemo1<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filterDemo1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>Filter的执行流程：</strong></p>
<ol>
<li>执行过滤器放行前代码</li>
<li>执行放行后访问的资源</li>
<li>执行过滤器放行代码下面的代码</li>
</ol>
<p><strong>Filter的生命周期：</strong></p>
<ol>
<li>init：服务器启动，init方法执行，创建Filter对象</li>
<li>doFilter：每一次访问被该拦截器拦截的资源时，都会执行</li>
<li>destroy：服务器正常关闭时，执行destroy方法，销毁Filter对象</li>
</ol>
<p><strong>Filter配置详解：</strong></p>
<ol>
<li>拦截路径的配置：<ul>
<li>具体资源路径：<code>/index.jsp</code>  只有访问index.jsp 时，过滤器才会执行 （一般不常用）</li>
<li>目录拦截：<code>/user/*</code>  访问user下的所有资源时，过滤器都会执行</li>
<li>后缀名拦截：<code>*.jsp</code> 访问所有后缀名为 jsp 的资源时，过滤器都会执行</li>
<li>拦截所有资源：<code>/*</code>  访问所有资源时，过滤器都会执行</li>
</ul>
</li>
<li>拦截方式的配置：资源被访问的方式<ul>
<li>注解配置：设置 <code>dispatcherTypes</code> 属性<ol>
<li><code>REQUEST</code>: 默认值， 浏览器直接请求资源</li>
<li><code>FORWARD</code>: 转发访问资源</li>
<li><code>INCLUDE</code>: 包含访问资源</li>
<li><code>ERROR</code>: 错误跳转资源</li>
<li><code>ASYNC</code>: 异步访问资源</li>
</ol>
</li>
<li>web.xml配置<ul>
<li>设置<code>&lt;dispatcher&gt;&lt;/dispatcher&gt;</code>标签</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>过滤器链（配置多个过滤器）</strong></p>
<ol>
<li>执行过程：如果有两个过滤器（过滤器1 和 过滤器2）<ol>
<li>过滤器1</li>
<li>过滤器2</li>
<li>资源执行</li>
<li>过滤器2</li>
<li>过滤器1</li>
</ol>
</li>
<li>执行顺序：<ul>
<li>注解配置：按照过滤器的类名字符串比较规则比较，值小的先执行</li>
<li>web.xml 配置：按照<code>&lt;filter-mapping&gt;</code>的定义顺序执行, 写在上面的先执行</li>
</ul>
</li>
</ol>
<h2 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h2><blockquote>
<p>Listener 是 JavaWeb 的三大组件之一</p>
</blockquote>
<p>事件监听机制:</p>
<ul>
<li>事件: 一件事情</li>
<li>事件源: 事件发生的地方</li>
<li>监听器: 事件发生时执行的动作</li>
<li>注册监听: 将事件, 事件源, 监听器绑定在一块. 当事件源上发生某件事情后, 执行监听器代码</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Filter</tag>
        <tag>Listener</tag>
      </tags>
  </entry>
  <entry>
    <title>Python高级变量类型</title>
    <url>/2020/05/15/Python/Python_new/14_%E9%AB%98%E7%BA%A7%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>列表 / 元组 / 字典/ 字符串</p>
<a id="more"></a>



<h1 id="高级变量类型"><a href="#高级变量类型" class="headerlink" title="高级变量类型"></a>高级变量类型</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>列表</li>
<li>元组</li>
<li>字典</li>
<li>字符串</li>
<li>公共方法</li>
<li>变量高级</li>
</ul>
<h3 id="知识点回顾"><a href="#知识点回顾" class="headerlink" title="知识点回顾"></a>知识点回顾</h3><ul>
<li><p>Python 中数据类型可以分为 <strong>数字型</strong> 和 <strong>非数字型</strong></p>
</li>
<li><p>数字型</p>
<ul>
<li>整型 (<code>int</code>)</li>
<li>浮点型（<code>float</code>）</li>
<li>布尔型（<code>bool</code>） <ul>
<li>真 <code>True</code> <code>非 0 数</code> —— <strong>非零即真</strong></li>
<li>假 <code>False</code> <code>0</code></li>
</ul>
</li>
<li>复数型 (<code>complex</code>)<ul>
<li>主要用于科学计算，例如：平面场问题、波动问题、电感电容等问题</li>
</ul>
</li>
</ul>
</li>
<li><p>非数字型</p>
<ul>
<li>字符串</li>
<li>列表</li>
<li>元组</li>
<li>字典</li>
</ul>
</li>
<li><p>在 <code>Python</code> 中，所有 <strong>非数字型变量</strong> 都支持以下特点：</p>
<ol>
<li>都是一个 <strong>序列</strong> <code>sequence</code>，也可以理解为 <strong>容器</strong></li>
<li><strong>取值</strong> <code>[]</code></li>
<li><strong>遍历</strong> <code>for in</code></li>
<li><strong>计算长度</strong>、<strong>最大/最小值</strong>、<strong>比较</strong>、<strong>删除</strong></li>
<li><strong>链接</strong> <code>+</code> 和 <strong>重复</strong> <code>*</code></li>
<li><strong>切片</strong></li>
</ol>
</li>
</ul>
<h2 id="01-列表"><a href="#01-列表" class="headerlink" title="01. 列表"></a>01. 列表</h2><h3 id="1-1-列表的定义"><a href="#1-1-列表的定义" class="headerlink" title="1.1 列表的定义"></a>1.1 列表的定义</h3><ul>
<li><code>List</code>（列表） 是 <code>Python</code> 中使用 <strong>最频繁</strong> 的数据类型，在其他语言中通常叫做 <strong>数组</strong></li>
<li>专门用于存储 <strong>一串 信息</strong></li>
<li>列表用 <code>[]</code> 定义，<strong>数据</strong> 之间使用 <code>,</code> 分隔</li>
<li>列表的 <strong>索引</strong> 从 <code>0</code> 开始<ul>
<li><strong>索引</strong> 就是数据在 <strong>列表</strong> 中的位置编号，<strong>索引</strong> 又可以被称为 <strong>下标</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：从列表中取值时，如果 <strong>超出索引范围</strong>，程序会报错</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">"zhangsan"</span>, <span class="string">"lisi"</span>, <span class="string">"wangwu"</span>]</span><br></pre></td></tr></table></figure>

<p><img src="./images/014/001_%E5%88%97%E8%A1%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="001_列表示意图"></p>
<h3 id="1-2-列表常用操作"><a href="#1-2-列表常用操作" class="headerlink" title="1.2 列表常用操作"></a>1.2 列表常用操作</h3><ul>
<li>在 <code>ipython3</code> 中定义一个 <strong>列表</strong>，例如：<code>name_list = []</code></li>
<li>输入 <code>name_list.</code> 按下 <code>TAB</code> 键，<code>ipython</code> 会提示 <strong>列表</strong> 能够使用的 <strong>方法</strong> 如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [1]: name_list.</span><br><span class="line">name_list.append   name_list.count    name_list.insert   name_list.reverse</span><br><span class="line">name_list.clear    name_list.extend   name_list.pop      name_list.sort</span><br><span class="line">name_list.copy     name_list.index    name_list.remove</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>序号</th>
<th>分类</th>
<th>关键字 / 函数 / 方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>增加</td>
<td>列表.insert(索引, 数据)</td>
<td>在指定位置插入数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td>列表.append(数据)</td>
<td>在末尾追加数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td>列表.extend(列表2)</td>
<td>将列表2 的数据追加到列表</td>
</tr>
<tr>
<td>2</td>
<td>修改</td>
<td>列表[索引] = 数据</td>
<td>修改指定索引的数据</td>
</tr>
<tr>
<td>3</td>
<td>删除</td>
<td>del 列表[索引]</td>
<td>删除指定索引的数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td>列表.remove[数据]</td>
<td>删除第一个出现的指定数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td>列表.pop</td>
<td>删除末尾数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td>列表.pop(索引)</td>
<td>删除指定索引数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td>列表.clear</td>
<td>清空列表</td>
</tr>
<tr>
<td>4</td>
<td>统计</td>
<td>len(列表)</td>
<td>列表长度</td>
</tr>
<tr>
<td></td>
<td></td>
<td>列表.count(数据)</td>
<td>数据在列表中出现的次数</td>
</tr>
<tr>
<td>5</td>
<td>排序</td>
<td>列表.sort()</td>
<td>升序排序</td>
</tr>
<tr>
<td></td>
<td></td>
<td>列表.sort(reverse=True)</td>
<td>降序排序</td>
</tr>
<tr>
<td></td>
<td></td>
<td>列表.reverse()</td>
<td>逆序、反转</td>
</tr>
</tbody></table>
<h4 id="del-关键字（科普）"><a href="#del-关键字（科普）" class="headerlink" title="del 关键字（科普）"></a>del 关键字（科普）</h4><ul>
<li>使用 <code>del</code> 关键字(<code>delete</code>) 同样可以删除列表中元素</li>
<li><code>del</code> 关键字本质上是用来 <strong>将一个变量从内存中删除的</strong></li>
<li>如果使用 <code>del</code> 关键字将变量从内存中删除，后续的代码就不能再使用这个变量了</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> name_list[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在日常开发中，要从列表删除数据，建议 <strong>使用列表提供的方法</strong></p>
</blockquote>
<h4 id="关键字、函数和方法（科普）"><a href="#关键字、函数和方法（科普）" class="headerlink" title="关键字、函数和方法（科普）"></a>关键字、函数和方法（科普）</h4><ul>
<li><strong>关键字</strong> 是 Python 内置的、具有特殊意义的标识符</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> keyword</span><br><span class="line">In [<span class="number">2</span>]: print(keyword.kwlist)</span><br><span class="line">In [<span class="number">3</span>]: print(len(keyword.kwlist))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关键字后面不需要使用括号</p>
</blockquote>
<ul>
<li><strong>函数</strong> 封装了独立功能，可以直接调用</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">函数名(参数)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>函数需要死记硬背</p>
</blockquote>
<ul>
<li><strong>方法</strong> 和函数类似，同样是封装了独立的功能</li>
<li><strong>方法</strong> 需要通过 <strong>对象</strong> 来调用，表示针对这个 <strong>对象</strong> 要做的操作</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">对象.方法名(参数)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在变量后面输入 <code>.</code>，然后选择针对这个变量要执行的操作，记忆起来比函数要简单很多</p>
</blockquote>
<h3 id="1-3-循环遍历"><a href="#1-3-循环遍历" class="headerlink" title="1.3 循环遍历"></a>1.3 循环遍历</h3><ul>
<li><p><strong>遍历</strong> 就是 <strong>从头到尾</strong> <strong>依次</strong> 从 <strong>列表</strong> 中获取数据</p>
<ul>
<li>在 <strong>循环体内部</strong> 针对 <strong>每一个元素</strong>，执行相同的操作</li>
</ul>
</li>
<li><p>在 <code>Python</code> 中为了提高列表的遍历效率，专门提供的 <strong>迭代 iteration 遍历</strong></p>
</li>
<li><p>使用 <code>for</code> 就能够实现迭代遍历</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># for 循环内部使用的变量 in 列表</span></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> name_list:</span><br><span class="line"></span><br><span class="line">    循环内部针对列表元素进行操作</span><br><span class="line">    print(name)</span><br></pre></td></tr></table></figure>

<p><img src="./images/014/002_forin%E5%BE%AA%E7%8E%AF%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="002_forin循环流程图-w420"></p>
<h3 id="1-4-应用场景"><a href="#1-4-应用场景" class="headerlink" title="1.4 应用场景"></a>1.4 <strong>应用场景</strong></h3><ul>
<li>尽管 <code>Python</code> 的 <strong>列表</strong> 中可以 <strong>存储不同类型的数据</strong></li>
<li>但是在开发中，更多的应用场景是<ol>
<li><strong>列表</strong> 存储相同类型的数据</li>
<li>通过 <strong>迭代遍历</strong>，在循环体内部，针对列表中的每一项元素，执行相同的操作</li>
</ol>
</li>
</ul>
<h2 id="02-元组"><a href="#02-元组" class="headerlink" title="02. 元组"></a>02. 元组</h2><h3 id="2-1-元组的定义"><a href="#2-1-元组的定义" class="headerlink" title="2.1 元组的定义"></a>2.1 元组的定义</h3><ul>
<li><code>Tuple</code>（元组）与列表类似，不同之处在于元组的 <strong>元素不能修改</strong><ul>
<li><strong>元组</strong> 表示多个元素组成的序列</li>
<li><strong>元组</strong> 在 <code>Python</code> 开发中，有特定的应用场景</li>
</ul>
</li>
<li>用于存储 <strong>一串 信息</strong>，<strong>数据</strong> 之间使用 <code>,</code> 分隔</li>
<li>元组用 <code>()</code> 定义</li>
<li>元组的 <strong>索引</strong> 从 <code>0</code> 开始<ul>
<li><strong>索引</strong> 就是数据在 <strong>元组</strong> 中的位置编号</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">info_tuple = (<span class="string">"zhangsan"</span>, <span class="number">18</span>, <span class="number">1.75</span>)</span><br></pre></td></tr></table></figure>

<h4 id="创建空元组"><a href="#创建空元组" class="headerlink" title="创建空元组"></a>创建空元组</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">info_tuple = ()</span><br></pre></td></tr></table></figure>

<h4 id="元组中-只包含一个元素-时，需要-在元素后面添加逗号"><a href="#元组中-只包含一个元素-时，需要-在元素后面添加逗号" class="headerlink" title="元组中 只包含一个元素 时，需要 在元素后面添加逗号"></a>元组中 <strong>只包含一个元素</strong> 时，需要 <strong>在元素后面添加逗号</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">info_tuple = (<span class="number">50</span>, )</span><br></pre></td></tr></table></figure>

<p><img src="./images/014/003_%E5%85%83%E7%BB%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="003_元组示意图-w500"></p>
<h3 id="2-2-元组常用操作"><a href="#2-2-元组常用操作" class="headerlink" title="2.2 元组常用操作"></a>2.2 元组常用操作</h3><ul>
<li>在 <code>ipython3</code> 中定义一个 <strong>元组</strong>，例如：<code>info = ()</code></li>
<li>输入 <code>info.</code> 按下 <code>TAB</code> 键，<code>ipython</code> 会提示 <strong>元组</strong> 能够使用的函数如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">info.count  info.index</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有关 <strong>元组</strong> 的 <strong>常用操作</strong> 可以参照上图练习</p>
</blockquote>
<h3 id="2-3-循环遍历"><a href="#2-3-循环遍历" class="headerlink" title="2.3 循环遍历"></a>2.3 循环遍历</h3><ul>
<li><strong>取值</strong> 就是从 <strong>元组</strong> 中获取存储在指定位置的数据</li>
<li><strong>遍历</strong> 就是 <strong>从头到尾</strong> <strong>依次</strong> 从 <strong>元组</strong> 中获取数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># for 循环内部使用的变量 in 元组:</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> info:</span><br><span class="line"></span><br><span class="line">    循环内部针对元组元素进行操作</span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>在 <code>Python</code> 中，可以使用 <code>for</code> 循环遍历所有非数字型类型的变量：<strong>列表</strong>、<strong>元组</strong>、<strong>字典</strong> 以及 <strong>字符串</strong></li>
<li>提示：在实际开发中，除非 <strong>能够确认元组中的数据类型</strong>，否则针对元组的循环遍历需求并不是很多</li>
</ul>
</blockquote>
<h3 id="2-4-应用场景"><a href="#2-4-应用场景" class="headerlink" title="2.4 应用场景"></a>2.4 应用场景</h3><ul>
<li>尽管可以使用 <code>for in</code> 遍历 <strong>元组</strong></li>
<li>但是在开发中，更多的应用场景是：<ul>
<li><strong>函数的 参数 和 返回值</strong>，一个函数可以接收 <strong>任意多个参数</strong>，或者 <strong>一次返回多个数据</strong><ul>
<li>有关 <strong>函数的参数 和 返回值</strong>，在后续 <strong>函数高级</strong> 给大家介绍</li>
</ul>
</li>
<li><strong>格式字符串</strong>，格式化字符串后面的 <code>()</code> 本质上就是一个元组</li>
<li><strong>让列表不可以被修改</strong>，以保护数据安全</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">info = (<span class="string">"zhangsan"</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"%s 的年龄是 %d"</span> % info)</span><br></pre></td></tr></table></figure>

<h4 id="元组和列表之间的转换"><a href="#元组和列表之间的转换" class="headerlink" title="元组和列表之间的转换"></a>元组和列表之间的转换</h4><ul>
<li>使用 <code>list</code> 函数可以把元组转换成列表</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list(元组)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>tuple</code> 函数可以把列表转换成元组</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuple(列表)</span><br></pre></td></tr></table></figure>

<h2 id="03-字典"><a href="#03-字典" class="headerlink" title="03. 字典"></a>03. 字典</h2><h3 id="3-1-字典的定义"><a href="#3-1-字典的定义" class="headerlink" title="3.1 字典的定义"></a>3.1 字典的定义</h3><ul>
<li><code>dictionary</code>（字典） 是 <strong>除列表以外</strong> <code>Python</code> 之中 <strong>最灵活</strong> 的数据类型</li>
<li>字典同样可以用来 <strong>存储多个数据</strong><ul>
<li>通常用于存储 <strong>描述一个 <code>物体</code> 的相关信息</strong> </li>
</ul>
</li>
<li>和列表的区别<ul>
<li><strong>列表</strong> 是 <strong>有序</strong> 的对象集合</li>
<li><strong>字典</strong> 是 <strong>无序</strong> 的对象集合</li>
</ul>
</li>
<li>字典用 <code>{}</code> 定义</li>
<li>字典使用 <strong>键值对</strong> 存储数据，键值对之间使用 <code>,</code> 分隔<ul>
<li><strong>键</strong> <code>key</code> 是索引</li>
<li><strong>值</strong> <code>value</code> 是数据</li>
<li><strong>键</strong> 和 <strong>值</strong> 之间使用 <code>:</code> 分隔</li>
<li><strong>键必须是唯一的</strong></li>
<li><strong>值</strong> 可以取任何数据类型，但 <strong>键</strong> 只能使用 <strong>字符串</strong>、<strong>数字</strong>或 <strong>元组</strong></li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xiaoming = &#123;<span class="string">"name"</span>: <span class="string">"小明"</span>,</span><br><span class="line">            <span class="string">"age"</span>: <span class="number">18</span>,</span><br><span class="line">            <span class="string">"gender"</span>: <span class="literal">True</span>,</span><br><span class="line">            <span class="string">"height"</span>: <span class="number">1.75</span>&#125;</span><br></pre></td></tr></table></figure>

<p><img src="./images/014/002_%E5%AD%97%E5%85%B8%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="002_字典示意图"></p>
<h3 id="3-2-字典常用操作"><a href="#3-2-字典常用操作" class="headerlink" title="3.2 字典常用操作"></a>3.2 字典常用操作</h3><ul>
<li>在 <code>ipython3</code> 中定义一个 <strong>字典</strong>，例如：<code>xiaoming = {}</code></li>
<li>输入 <code>xiaoming.</code> 按下 <code>TAB</code> 键，<code>ipython</code> 会提示 <strong>字典</strong> 能够使用的函数如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [1]: xiaoming.</span><br><span class="line">xiaoming.clear       xiaoming.items       xiaoming.setdefault</span><br><span class="line">xiaoming.copy        xiaoming.keys        xiaoming.update</span><br><span class="line">xiaoming.fromkeys    xiaoming.pop         xiaoming.values</span><br><span class="line">xiaoming.get         xiaoming.popitem</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有关 <strong>字典</strong> 的 <strong>常用操作</strong> 可以参照上图练习</p>
</blockquote>
<h3 id="3-3-循环遍历"><a href="#3-3-循环遍历" class="headerlink" title="3.3 循环遍历"></a>3.3 循环遍历</h3><ul>
<li><strong>遍历</strong> 就是 <strong>依次</strong> 从 <strong>字典</strong> 中获取所有键值对</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># for 循环内部使用的 `key 的变量` in 字典</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> xiaoming:</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"%s: %s"</span> % (k, xiaoming[k]))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：在实际开发中，由于字典中每一个键值对保存数据的类型是不同的，所以针对字典的循环遍历需求并不是很多</p>
</blockquote>
<h3 id="3-4-应用场景"><a href="#3-4-应用场景" class="headerlink" title="3.4 应用场景"></a>3.4 <strong>应用场景</strong></h3><ul>
<li>尽管可以使用 <code>for in</code> 遍历 <strong>字典</strong></li>
<li>但是在开发中，更多的应用场景是：<ul>
<li>使用 <strong>多个键值对</strong>，存储 <strong>描述一个 <code>物体</code> 的相关信息</strong> —— 描述更复杂的数据信息</li>
<li>将 <strong>多个字典</strong> 放在 <strong>一个列表</strong> 中，再进行遍历，在循环体内部针对每一个字典进行 <strong>相同的处理</strong></li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">card_list = [&#123;<span class="string">"name"</span>: <span class="string">"张三"</span>,</span><br><span class="line">              <span class="string">"qq"</span>: <span class="string">"12345"</span>,</span><br><span class="line">              <span class="string">"phone"</span>: <span class="string">"110"</span>&#125;,</span><br><span class="line">             &#123;<span class="string">"name"</span>: <span class="string">"李四"</span>,</span><br><span class="line">              <span class="string">"qq"</span>: <span class="string">"54321"</span>,</span><br><span class="line">              <span class="string">"phone"</span>: <span class="string">"10086"</span>&#125;</span><br><span class="line">             ]</span><br></pre></td></tr></table></figure>


<h2 id="04-字符串"><a href="#04-字符串" class="headerlink" title="04. 字符串"></a>04. 字符串</h2><h3 id="4-1-字符串的定义"><a href="#4-1-字符串的定义" class="headerlink" title="4.1 字符串的定义"></a>4.1 字符串的定义</h3><ul>
<li><strong>字符串</strong> 就是 <strong>一串字符</strong>，是编程语言中表示文本的数据类型</li>
<li>在 Python 中可以使用 <strong>一对双引号</strong> <code>&quot;</code> 或者 <strong>一对单引号</strong> <code>&#39;</code> 定义一个字符串<ul>
<li>虽然可以使用 <code>\&quot;</code> 或者 <code>\&#39;</code> 做字符串的转义，但是在实际开发中：<ul>
<li>如果字符串内部需要使用 <code>&quot;</code>，可以使用 <code>&#39;</code> 定义字符串</li>
<li>如果字符串内部需要使用 <code>&#39;</code>，可以使用 <code>&quot;</code> 定义字符串</li>
</ul>
</li>
</ul>
</li>
<li>可以使用 <strong>索引</strong> 获取一个字符串中 <strong>指定位置的字符</strong>，索引计数从 <strong>0</strong> 开始</li>
<li>也可以使用 <code>for</code> <strong>循环遍历</strong> 字符串中每一个字符</li>
</ul>
<blockquote>
<p>大多数编程语言都是用 <code>&quot;</code> 来定义字符串</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">string = <span class="string">"Hello Python"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> string:</span><br><span class="line">    print(c)</span><br></pre></td></tr></table></figure>

<p><img src="./images/014/005_%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="005_字符串示意图-w500"></p>
<h3 id="4-2-字符串的常用操作"><a href="#4-2-字符串的常用操作" class="headerlink" title="4.2 字符串的常用操作"></a>4.2 字符串的常用操作</h3><ul>
<li>在 <code>ipython3</code> 中定义一个 <strong>字符串</strong>，例如：<code>hello_str = &quot;&quot;</code></li>
<li>输入 <code>hello_str.</code> 按下 <code>TAB</code> 键，<code>ipython</code> 会提示 <strong>字符串</strong> 能够使用的 <strong>方法</strong> 如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [1]: hello_str.</span><br><span class="line">hello_str.capitalize    hello_str.isidentifier  hello_str.rindex</span><br><span class="line">hello_str.casefold      hello_str.islower       hello_str.rjust</span><br><span class="line">hello_str.center        hello_str.isnumeric     hello_str.rpartition</span><br><span class="line">hello_str.count         hello_str.isprintable   hello_str.rsplit</span><br><span class="line">hello_str.encode        hello_str.isspace       hello_str.rstrip</span><br><span class="line">hello_str.endswith      hello_str.istitle       hello_str.split</span><br><span class="line">hello_str.expandtabs    hello_str.isupper       hello_str.splitlines</span><br><span class="line">hello_str.find          hello_str.join          hello_str.startswith</span><br><span class="line">hello_str.format        hello_str.ljust         hello_str.strip</span><br><span class="line">hello_str.format_map    hello_str.lower         hello_str.swapcase</span><br><span class="line">hello_str.index         hello_str.lstrip        hello_str.title</span><br><span class="line">hello_str.isalnum       hello_str.maketrans     hello_str.translate</span><br><span class="line">hello_str.isalpha       hello_str.partition     hello_str.upper</span><br><span class="line">hello_str.isdecimal     hello_str.replace       hello_str.zfill</span><br><span class="line">hello_str.isdigit       hello_str.rfind</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：正是因为 python 内置提供的方法足够多，才使得在开发时，能够针对字符串进行更加灵活的操作！应对更多的开发需求！</p>
</blockquote>
<h4 id="1-判断类型-9"><a href="#1-判断类型-9" class="headerlink" title="1) 判断类型 - 9"></a>1) 判断类型 - 9</h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>string.isspace()</td>
<td>如果 string 中只包含空格，则返回 True</td>
</tr>
<tr>
<td>string.isalnum()</td>
<td>如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True</td>
</tr>
<tr>
<td>string.isalpha()</td>
<td>如果 string 至少有一个字符并且所有字符都是字母则返回 True</td>
</tr>
<tr>
<td>string.isdecimal()</td>
<td>如果 string 只包含数字则返回 True，<code>全角数字</code></td>
</tr>
<tr>
<td>string.isdigit()</td>
<td>如果 string 只包含数字则返回 True，<code>全角数字</code>、<code>⑴</code>、<code>\u00b2</code></td>
</tr>
<tr>
<td>string.isnumeric()</td>
<td>如果 string 只包含数字则返回 True，<code>全角数字</code>，<code>汉字数字</code></td>
</tr>
<tr>
<td>string.istitle()</td>
<td>如果 string 是标题化的(每个单词的首字母大写)则返回 True</td>
</tr>
<tr>
<td>string.islower()</td>
<td>如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True</td>
</tr>
<tr>
<td>string.isupper()</td>
<td>如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True</td>
</tr>
</tbody></table>
<h4 id="2-查找和替换-7"><a href="#2-查找和替换-7" class="headerlink" title="2) 查找和替换 - 7"></a>2) 查找和替换 - 7</h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>string.startswith(str)</td>
<td>检查字符串是否是以 str 开头，是则返回 True</td>
</tr>
<tr>
<td>string.endswith(str)</td>
<td>检查字符串是否是以 str 结束，是则返回 True</td>
</tr>
<tr>
<td>string.find(str, start=0, end=len(string))</td>
<td>检测 str 是否包含在 string 中，如果 start 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回 <code>-1</code></td>
</tr>
<tr>
<td>string.rfind(str, start=0, end=len(string))</td>
<td>类似于 find()，不过是从右边开始查找</td>
</tr>
<tr>
<td>string.index(str, start=0, end=len(string))</td>
<td>跟 find() 方法类似，不过如果 str 不在 string 会报错</td>
</tr>
<tr>
<td>string.rindex(str, start=0, end=len(string))</td>
<td>类似于 index()，不过是从右边开始</td>
</tr>
<tr>
<td>string.replace(old_str, new_str, num=string.count(old))</td>
<td>把 string 中的 old_str 替换成 new_str，如果 num 指定，则替换不超过 num 次</td>
</tr>
</tbody></table>
<h4 id="3-大小写转换-5"><a href="#3-大小写转换-5" class="headerlink" title="3) 大小写转换 - 5"></a>3) 大小写转换 - 5</h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>string.capitalize()</td>
<td>把字符串的第一个字符大写</td>
</tr>
<tr>
<td>string.title()</td>
<td>把字符串的每个单词首字母大写</td>
</tr>
<tr>
<td>string.lower()</td>
<td>转换 string 中所有大写字符为小写</td>
</tr>
<tr>
<td>string.upper()</td>
<td>转换 string 中的小写字母为大写</td>
</tr>
<tr>
<td>string.swapcase()</td>
<td>翻转 string 中的大小写</td>
</tr>
</tbody></table>
<h4 id="4-文本对齐-3"><a href="#4-文本对齐-3" class="headerlink" title="4) 文本对齐 - 3"></a>4) 文本对齐 - 3</h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>string.ljust(width)</td>
<td>返回一个原字符串左对齐，并使用空格填充至长度 width 的新字符串</td>
</tr>
<tr>
<td>string.rjust(width)</td>
<td>返回一个原字符串右对齐，并使用空格填充至长度 width 的新字符串</td>
</tr>
<tr>
<td>string.center(width)</td>
<td>返回一个原字符串居中，并使用空格填充至长度 width 的新字符串</td>
</tr>
</tbody></table>
<h4 id="5-去除空白字符-3"><a href="#5-去除空白字符-3" class="headerlink" title="5) 去除空白字符 - 3"></a>5) 去除空白字符 - 3</h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>string.lstrip()</td>
<td>截掉 string 左边（开始）的空白字符</td>
</tr>
<tr>
<td>string.rstrip()</td>
<td>截掉 string 右边（末尾）的空白字符</td>
</tr>
<tr>
<td>string.strip()</td>
<td>截掉 string 左右两边的空白字符</td>
</tr>
</tbody></table>
<h4 id="6-拆分和连接-5"><a href="#6-拆分和连接-5" class="headerlink" title="6) 拆分和连接 - 5"></a>6) 拆分和连接 - 5</h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>string.partition(str)</td>
<td>把字符串 string 分成一个 3 元素的元组 (str前面, str, str后面)</td>
</tr>
<tr>
<td>string.rpartition(str)</td>
<td>类似于 partition() 方法，不过是从右边开始查找</td>
</tr>
<tr>
<td>string.split(str=””, num)</td>
<td>以 str 为分隔符拆分 string，如果 num 有指定值，则仅分隔 num + 1 个子字符串，str 默认包含 ‘\r’, ‘\t’, ‘\n’ 和空格</td>
</tr>
<tr>
<td>string.splitlines()</td>
<td>按照行(‘\r’, ‘\n’, ‘\r\n’)分隔，返回一个包含各行作为元素的列表</td>
</tr>
<tr>
<td>string.join(seq)</td>
<td>以 string 作为分隔符，将 seq 中所有的元素（的字符串表示）合并为一个新的字符串</td>
</tr>
</tbody></table>
<h3 id="4-3-字符串的切片"><a href="#4-3-字符串的切片" class="headerlink" title="4.3 字符串的切片"></a>4.3 字符串的切片</h3><ul>
<li><strong>切片</strong> 方法适用于 <strong>字符串</strong>、<strong>列表</strong>、<strong>元组</strong><ul>
<li><strong>切片</strong> 使用 <strong>索引值</strong> 来限定范围，从一个大的 <strong>字符串</strong> 中 <strong>切出</strong> 小的 <strong>字符串</strong></li>
<li><strong>列表</strong> 和 <strong>元组</strong> 都是 <strong>有序</strong> 的集合，都能够 <strong>通过索引值</strong> 获取到对应的数据</li>
<li><strong>字典</strong> 是一个 <strong>无序</strong> 的集合，是使用 <strong>键值对</strong> 保存数据</li>
</ul>
</li>
</ul>
<p><img src="./images/014/006_%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B4%A2%E5%BC%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="006_字符串索引示意图"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字符串[开始索引:结束索引:步长]</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：</p>
<ol>
<li>指定的区间属于 <strong>左闭右开</strong> 型 <code>[开始索引,  结束索引)</code> =&gt; <code>开始索引 &gt;= 范围 &lt; 结束索引</code><ul>
<li>从 <code>起始</code> 位开始，到 <strong><code>结束</code>位的前一位</strong> 结束（<strong>不包含结束位本身</strong>)</li>
</ul>
</li>
<li>从头开始，<strong>开始索引</strong> <strong>数字可以省略，冒号不能省略</strong></li>
<li>到末尾结束，<strong>结束索引</strong> <strong>数字可以省略，冒号不能省略</strong></li>
<li>步长默认为 <code>1</code>，如果连续切片，<strong>数字和冒号都可以省略</strong></li>
</ol>
<h4 id="索引的顺序和倒序"><a href="#索引的顺序和倒序" class="headerlink" title="索引的顺序和倒序"></a>索引的顺序和倒序</h4><ul>
<li>在 Python 中不仅支持 <strong>顺序索引</strong>，同时还支持 <strong>倒序索引</strong></li>
<li>所谓倒序索引就是 <strong>从右向左</strong> 计算索引<ul>
<li>最右边的索引值是 <strong>-1</strong>，依次递减</li>
</ul>
</li>
</ul>
<p><strong>演练需求</strong></p>
<ul>
<li><ol>
<li>截取从 2 ~ 5 位置 的字符串</li>
</ol>
</li>
<li><ol start="2">
<li>截取从 2 ~ <code>末尾</code> 的字符串</li>
</ol>
</li>
<li><ol start="3">
<li>截取从 <code>开始</code> ~ 5 位置 的字符串</li>
</ol>
</li>
<li><ol start="4">
<li>截取完整的字符串</li>
</ol>
</li>
<li><ol start="5">
<li>从开始位置，每隔一个字符截取字符串</li>
</ol>
</li>
<li><ol start="6">
<li>从索引 1 开始，每隔一个取一个</li>
</ol>
</li>
<li><ol start="7">
<li>截取从 2 ~ <code>末尾 - 1</code> 的字符串</li>
</ol>
</li>
<li><ol start="8">
<li>截取字符串末尾两个字符</li>
</ol>
</li>
<li><ol start="9">
<li>字符串的逆序（面试题）</li>
</ol>
</li>
</ul>
<p><strong>答案</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">num_str &#x3D; &quot;0123456789&quot;</span><br><span class="line"></span><br><span class="line"># 1. 截取从 2 ~ 5 位置 的字符串</span><br><span class="line">print(num_str[2:6])</span><br><span class="line"></span><br><span class="line"># 2. 截取从 2 ~ &#96;末尾&#96; 的字符串</span><br><span class="line">print(num_str[2:])</span><br><span class="line"></span><br><span class="line"># 3. 截取从 &#96;开始&#96; ~ 5 位置 的字符串</span><br><span class="line">print(num_str[:6])</span><br><span class="line"></span><br><span class="line"># 4. 截取完整的字符串</span><br><span class="line">print(num_str[:])</span><br><span class="line"></span><br><span class="line"># 5. 从开始位置，每隔一个字符截取字符串</span><br><span class="line">print(num_str[::2])</span><br><span class="line"></span><br><span class="line"># 6. 从索引 1 开始，每隔一个取一个</span><br><span class="line">print(num_str[1::2])</span><br><span class="line"></span><br><span class="line"># 倒序切片</span><br><span class="line"># -1 表示倒数第一个字符</span><br><span class="line">print(num_str[-1])</span><br><span class="line"></span><br><span class="line"># 7. 截取从 2 ~ &#96;末尾 - 1&#96; 的字符串</span><br><span class="line">print(num_str[2:-1])</span><br><span class="line"></span><br><span class="line"># 8. 截取字符串末尾两个字符</span><br><span class="line">print(num_str[-2:])</span><br><span class="line"></span><br><span class="line"># 9. 字符串的逆序（面试题）</span><br><span class="line">print(num_str[::-1])</span><br></pre></td></tr></table></figure>

<h2 id="05-公共方法"><a href="#05-公共方法" class="headerlink" title="05. 公共方法"></a>05. 公共方法</h2><h3 id="5-1-Python-内置函数"><a href="#5-1-Python-内置函数" class="headerlink" title="5.1 Python 内置函数"></a>5.1 Python 内置函数</h3><p>Python 包含了以下内置函数：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>len(item)</td>
<td>计算容器中元素个数</td>
<td></td>
</tr>
<tr>
<td>del(item)</td>
<td>删除变量</td>
<td>del 有两种方式</td>
</tr>
<tr>
<td>max(item)</td>
<td>返回容器中元素最大值</td>
<td>如果是字典，只针对 key 比较</td>
</tr>
<tr>
<td>min(item)</td>
<td>返回容器中元素最小值</td>
<td>如果是字典，只针对 key 比较</td>
</tr>
</tbody></table>
<p><strong>注意</strong></p>
<ul>
<li><strong>字符串</strong> 比较符合以下规则： “0” &lt; “A” &lt; “a”</li>
</ul>
<h3 id="5-2-切片"><a href="#5-2-切片" class="headerlink" title="5.2 切片"></a>5.2 切片</h3><p>| 描述 | Python 表达式 | 结果 | 支持的数据类型 |<br>| :—: | — | — | — | — |<br>| 切片 | “0123456789”[::-2] | “97531” | 字符串、列表、元组 |</p>
<ul>
<li><strong>切片</strong> 使用 <strong>索引值</strong> 来限定范围，从一个大的 <strong>字符串</strong> 中 <strong>切出</strong> 小的 <strong>字符串</strong></li>
<li><strong>列表</strong> 和 <strong>元组</strong> 都是 <strong>有序</strong> 的集合，都能够 <strong>通过索引值</strong> 获取到对应的数据</li>
<li><strong>字典</strong> 是一个 <strong>无序</strong> 的集合，是使用 <strong>键值对</strong> 保存数据</li>
</ul>
<h3 id="5-3-运算符"><a href="#5-3-运算符" class="headerlink" title="5.3 运算符"></a>5.3 运算符</h3><table>
<thead>
<tr>
<th align="center">运算符</th>
<th>Python 表达式</th>
<th>结果</th>
<th>描述</th>
<th>支持的数据类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td>[1, 2] + [3, 4]</td>
<td>[1, 2, 3, 4]</td>
<td>合并</td>
<td>字符串、列表、元组</td>
</tr>
<tr>
<td align="center">*</td>
<td>[“Hi!”] * 4</td>
<td>[‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’]</td>
<td>重复</td>
<td>字符串、列表、元组</td>
</tr>
<tr>
<td align="center">in</td>
<td>3 in (1, 2, 3)</td>
<td>True</td>
<td>元素是否存在</td>
<td>字符串、列表、元组、字典</td>
</tr>
<tr>
<td align="center">not in</td>
<td>4 not in (1, 2, 3)</td>
<td>True</td>
<td>元素是否不存在</td>
<td>字符串、列表、元组、字典</td>
</tr>
<tr>
<td align="center">&gt; &gt;= == &lt; &lt;=</td>
<td>(1, 2, 3) &lt; (2, 2, 3)</td>
<td>True</td>
<td>元素比较</td>
<td>字符串、列表、元组</td>
</tr>
</tbody></table>
<p><strong>注意</strong></p>
<ul>
<li><code>in</code> 在对 <strong>字典</strong> 操作时，判断的是 <strong>字典的键</strong></li>
<li><code>in</code> 和 <code>not in</code> 被称为 <strong>成员运算符</strong></li>
</ul>
<h4 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h4><p>成员运算符用于 <strong>测试</strong> 序列中是否包含指定的 <strong>成员</strong></p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>in</td>
<td>如果在指定的序列中找到值返回 True，否则返回 False</td>
<td><code>3 in (1, 2, 3)</code> 返回 <code>True</code></td>
</tr>
<tr>
<td>not in</td>
<td>如果在指定的序列中没有找到值返回 True，否则返回 False</td>
<td><code>3 not in (1, 2, 3)</code> 返回 <code>False</code></td>
</tr>
</tbody></table>
<p>注意：在对 <strong>字典</strong> 操作时，判断的是 <strong>字典的键</strong></p>
<h3 id="5-4-完整的-for-循环语法"><a href="#5-4-完整的-for-循环语法" class="headerlink" title="5.4 完整的 for 循环语法"></a>5.4 完整的 for 循环语法</h3><ul>
<li>在 <code>Python</code> 中完整的 <code>for 循环</code> 的语法如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> 集合:</span><br><span class="line">    </span><br><span class="line">    循环体代码</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    没有通过 <span class="keyword">break</span> 退出循环，循环结束后，会执行的代码</span><br></pre></td></tr></table></figure>

<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>在 <strong>迭代遍历</strong> 嵌套的数据类型时，例如 <strong>一个列表包含了多个字典</strong></li>
<li>需求：要判断 某一个字典中 是否存在 指定的 值 <ul>
<li>如果 <strong>存在</strong>，提示并且退出循环</li>
<li>如果 <strong>不存在</strong>，在 <strong>循环整体结束</strong> 后，希望 <strong>得到一个统一的提示</strong></li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">students = [</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"阿土"</span>,</span><br><span class="line">     <span class="string">"age"</span>: <span class="number">20</span>,</span><br><span class="line">     <span class="string">"gender"</span>: <span class="literal">True</span>,</span><br><span class="line">     <span class="string">"height"</span>: <span class="number">1.7</span>,</span><br><span class="line">     <span class="string">"weight"</span>: <span class="number">75.0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"小美"</span>,</span><br><span class="line">     <span class="string">"age"</span>: <span class="number">19</span>,</span><br><span class="line">     <span class="string">"gender"</span>: <span class="literal">False</span>,</span><br><span class="line">     <span class="string">"height"</span>: <span class="number">1.6</span>,</span><br><span class="line">     <span class="string">"weight"</span>: <span class="number">45.0</span>&#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">find_name = <span class="string">"阿土"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> stu_dict <span class="keyword">in</span> students:</span><br><span class="line"></span><br><span class="line">    print(stu_dict)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断当前遍历的字典中姓名是否为find_name</span></span><br><span class="line">    <span class="keyword">if</span> stu_dict[<span class="string">"name"</span>] == find_name:</span><br><span class="line">        print(<span class="string">"找到了"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果已经找到，直接退出循环，就不需要再对后续的数据进行比较</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"没有找到"</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"循环结束"</span>)</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python列表</tag>
        <tag>python元组</tag>
        <tag>python字典</tag>
        <tag>python字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Cookie &amp; Session</title>
    <url>/2020/04/26/Java/2.JavaWeb/10.Cookie&amp;Session/</url>
    <content><![CDATA[<p>会话：浏览器第一次给服务器发送请求，会话建立，直到有一方断开为止</p>
<p>功能：在<strong>一次会话的多次请求</strong>中<strong>共享数据</strong></p>
<p>Cookie：客户端会话技术</p>
<p>Session：服务器端会话技术</p>
<a id="more"></a>


<h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p><strong>概念：</strong>客户端会话技术，将数据保存在客户端</p>
<p><strong>使用：</strong></p>
<ol>
<li><p>创建Cookie对象</p>
<p><code>Cookie cookie = new Cookie(&quot;msg&quot;, &quot;hellocookie&quot;);</code></p>
<blockquote>
<p>发现一个小问题：</p>
<p>Cookie对象的 value 字符串中不能有空格，不知缘由。。。</p>
</blockquote>
</li>
<li><p>发送Cookie到客户端</p>
<p><code>response.addCookie(cookie);</code></p>
</li>
<li><p>接收其它请求中携带的Cookie，</p>
<p><code>Cookie[] cookies = request.getCookies();</code></p>
</li>
</ol>
<p><strong>原理：</strong></p>
<blockquote>
<p>Cookie是基于响应头 <code>Set-Cookie</code> 和请求头 <code>Cookie</code> 来实现的</p>
</blockquote>
<p>发送Cookie到客户端：</p>
<ul>
<li>在响应头里面有：<code>Set-Cookie: msg=hellocookie</code></li>
<li>当浏览器看到 Set-Cookie 响应头时，会把该响应头的内容存到浏览器中</li>
</ul>
<p>再次发送其它请求时会携带浏览器中存储的所有Cookie</p>
<ul>
<li>请求头中有：<code>Cookie: msg=hellocookie</code></li>
</ul>
<p><strong>Cookie 细节：</strong></p>
<ol>
<li><p>一次可不可以发送多个Cookie</p>
<p>可以，创建多个Cookie对象，多次调用<code>response.addCookie(cookie);</code></p>
</li>
<li><p>Cookie在浏览器的存活时间</p>
<ul>
<li><p>默认情况下，浏览器关闭，Cookie数据销毁</p>
</li>
<li><p>持久化存储</p>
<ul>
<li><p><code>cookie.setMaxAge(int seconds)</code></p>
<p>正数：Cookie存储到文件中，文件存在的时间（秒）</p>
<p>负数：默认情况，浏览器关闭，Cookie数据销毁</p>
<p>0：删除Cookie</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Cookie可不可以存中文</p>
<ul>
<li>在tomcat 8 之前，不能直接存储中文<ul>
<li>需要将中文数据转码，一般转为url编码</li>
</ul>
</li>
<li>在tomcat 8 之后，可以直接存储中文</li>
</ul>
</li>
<li><p>Cookie共享数据的范围</p>
<ul>
<li><p>在一个tomcat服务器中部署的多个项目中共享数据？</p>
<ul>
<li><p>默认情况下不能</p>
</li>
<li><p><code>setPath(String path)</code>设置同一个服务器中cookie的获取范围，默认为当前虚拟目录</p>
<p><code>setPath(&quot;/&quot;)</code> –&gt; 设置获取范围为当前服务器</p>
</li>
</ul>
</li>
<li><p>在不同的tomcat服务器中共享数据</p>
<p><code>setDomain(String path)</code> –&gt; 设置一级域名相同，多个服务器之间的cookie可以共享</p>
</li>
</ul>
</li>
</ol>
<p><strong>Cookie的特点及作用：</strong></p>
<ul>
<li>特点：<ul>
<li>cookie存储在浏览器中（不安全）</li>
<li>浏览器对 <strong>单个cookie的大小</strong> 及 <strong>同一域名下cookie的总数量</strong> 都有限制</li>
</ul>
</li>
<li>作用：<ul>
<li>存储少量不敏感的数据</li>
<li>在不登录的情况下，完成服务器对客户端的身份识别</li>
</ul>
</li>
</ul>
<h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><p>概念：服务器端会话技术，在<strong>一次会话</strong>的<strong>多次请求</strong>间共享数据，将数据保存在服务器的 <strong>HttpSession 对象</strong>中</p>
<p>使用：</p>
<ul>
<li><p>获取 HttpSession 对象：</p>
<p><code>HttpSession session = request.getSession();</code></p>
</li>
<li><p>使用 HttpSession 对象：</p>
<ul>
<li>存储数据：<code>setAttribute(String name, Object Value);</code></li>
<li>获取数据：<code>getSttribute(String name);</code></li>
<li>移除数据：<code>removeAttribute(String name);</code></li>
</ul>
</li>
</ul>
<p>原理：</p>
<p>Session是<strong>依赖于Cookie</strong>实现的：</p>
<ol>
<li>使用 request.getSession() 获取Session对象</li>
<li>服务器通过 HTTP 响应头 <code>Set-Cookie: JSESSIONID=8E56ADBC35</code></li>
<li>同一次对话的其他请求访问服务器时，请求头 <code>Cookie: JSESSIONID=8E56ADBC35</code></li>
</ol>
<blockquote>
<p>session 在服务器中是 <strong>单例</strong> 的</p>
<p>单例也是通过 cookie 来实现的</p>
</blockquote>
<p>Session的细节：</p>
<ol>
<li><p>客户端关闭，服务器不关闭，两次获取的session是否为同一个？</p>
<ul>
<li><p>默认情况下不是同一个，因为不是同一次会话了</p>
</li>
<li><p>如果想要是同一个，可以单独创建cookie，键名为 <code>JSESSIONID</code>，值为 <code>session.getId()</code>，并设置 <code>cookie.setMaxAge(int second)</code></p>
<p><code>Cookie cookie = new Cookie(&quot;JSESSIONID&quot;, session.getId())</code></p>
<p><code>cookie.setMaxAge(int second)</code></p>
</li>
</ul>
</li>
<li><p>客户端不关闭，服务器关闭，两次获取的session是同一个吗</p>
<p>两次获取的session对象不是同一个，但是要确保两个对象中的数据是一致的</p>
<ul>
<li>session的钝化：在服务器正常关闭之前，将session对象序列化到硬盘上</li>
<li>session的活化：在服务器启动后，将硬盘上的session文件转化为内存中的session对象</li>
</ul>
<blockquote>
<p>Tomcat可以自动完成session的钝化和活化，但是idea不可以</p>
</blockquote>
</li>
<li><p>session对象的销毁时机：</p>
<ul>
<li><p>服务器关闭</p>
</li>
<li><p>session对象调用 <code>invalidate()</code>方法</p>
</li>
<li><p>session的默认失效时间为 30min</p>
<p>可以自定义session的失效时间：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ol>
<blockquote>
<p>session 和 cookie 的区别</p>
<ol>
<li>session数据存储在服务器，cookie存储在客户端</li>
<li>session数据大小没有限制，cookie有限制</li>
<li>session数据安全，cookie相对来说不太安全</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Cookie</tag>
        <tag>Session</tag>
      </tags>
  </entry>
  <entry>
    <title>Python异常</title>
    <url>/2020/04/25/Python/Python_new/python%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<p>Python处理异常以及捕获异常</p>
<a id="more"></a>

<h1 id="Python异常"><a href="#Python异常" class="headerlink" title="Python异常"></a>Python异常</h1><h3 id="处理异常的基础语法："><a href="#处理异常的基础语法：" class="headerlink" title="处理异常的基础语法："></a>处理异常的基础语法：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 要执行的代码，可能存在异常</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="comment"># 出现异常时，要执行的操作</span></span><br></pre></td></tr></table></figure>



<h3 id="按照错误类型捕获异常："><a href="#按照错误类型捕获异常：" class="headerlink" title="按照错误类型捕获异常："></a>按照错误类型捕获异常：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 要执行的代码，可能存在异常</span></span><br><span class="line"><span class="keyword">except</span> 错误类型<span class="number">1</span>:</span><br><span class="line">    <span class="comment"># 出现这种类型异常时，要执行的操作</span></span><br><span class="line"><span class="keyword">except</span> 错误类型<span class="number">2</span>:</span><br><span class="line">    <span class="comment"># 出现这种类型异常时，要执行的操作</span></span><br></pre></td></tr></table></figure>



<h3 id="捕获未知异常："><a href="#捕获未知异常：" class="headerlink" title="捕获未知异常："></a>捕获未知异常：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 要执行的代码，可能存在异常</span></span><br><span class="line"><span class="keyword">except</span> 错误类型:</span><br><span class="line">    <span class="comment"># 出现这种类型异常时，要执行的操作</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">    print(<span class="string">"未知错误：%s"</span> % result)</span><br></pre></td></tr></table></figure>



<h3 id="处理异常的完整语法："><a href="#处理异常的完整语法：" class="headerlink" title="处理异常的完整语法："></a>处理异常的完整语法：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 要执行的代码，可能存在异常</span></span><br><span class="line"><span class="keyword">except</span> 错误类型<span class="number">1</span>:</span><br><span class="line">    <span class="comment"># 出现这种类型异常时，要执行的操作</span></span><br><span class="line"><span class="keyword">except</span> (错误类型<span class="number">2</span>, 错误类型<span class="number">3</span>):</span><br><span class="line">    <span class="comment"># 出现这2种类型异常时，要执行的操作</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">    print(<span class="string">"未知错误：%s"</span> % result)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 没有异常才会执行 else 中的代码</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># 无论是否有异常，都会执行的代码</span></span><br></pre></td></tr></table></figure>



<h3 id="异常的传递性："><a href="#异常的传递性：" class="headerlink" title="异常的传递性："></a>异常的传递性：</h3><ul>
<li><p>当函数出现异常时，程序不会立即终止，异常会被<strong>传递到调用函数</strong>的地方</p>
</li>
<li><p>如果异常传递到主程序，仍然没有被处理，程序才会终止</p>
</li>
</ul>
<h3 id="主动抛出异常："><a href="#主动抛出异常：" class="headerlink" title="主动抛出异常："></a>主动抛出异常：</h3><p>Python中的异常类：<code>Exception</code></p>
<p>抛出异常关键字：<code>raise</code></p>
<p>主动抛出异常实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个 Exception 对象</span></span><br><span class="line">ex = Exception(<span class="string">"自定义异常"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 raise 抛出异常</span></span><br><span class="line"><span class="keyword">raise</span> ex</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python异常</tag>
      </tags>
  </entry>
  <entry>
    <title>Python文件操作</title>
    <url>/2020/04/25/Python/Python_new/Python%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>Python操作文件的步骤: 打开文件 –&gt; 读/写 –&gt; 关闭文件</p>
<a id="more"></a>



<h1 id="Python文件操作"><a href="#Python文件操作" class="headerlink" title="Python文件操作"></a>Python文件操作</h1><h3 id="Python-操作文件的步骤："><a href="#Python-操作文件的步骤：" class="headerlink" title="Python 操作文件的步骤："></a>Python 操作文件的步骤：</h3><ol>
<li><p>打开文件</p>
<ul>
<li><code>file = open(&quot;filename&quot;, &quot;访问方式&quot;)</code></li>
<li><code>open()</code>函数打开文件，会返回文件操作对象</li>
</ul>
</li>
<li><p>操作文件</p>
<ul>
<li><p>读</p>
<ul>
<li><p><code>file.read()</code></p>
</li>
<li><p><code>read()</code>方法可以一次性读入并返回<strong>文件的全部内容</strong></p>
</li>
</ul>
</li>
<li><p>写 <code>file.write()</code></p>
</li>
</ul>
</li>
<li><p>关闭文件</p>
<ul>
<li><code>file.close()</code></li>
</ul>
</li>
</ol>
<h3 id="文件指针"><a href="#文件指针" class="headerlink" title="文件指针"></a>文件指针</h3><p>读取文件的时候，会有一个指针标记从哪个位置开始读取数据</p>
<p>第一次打开文件时，文件指针会指向文件的开始位置</p>
<p>执行了<code>read</code>方法后，文件指针会移动到文件末尾</p>
<h3 id="文件的访问方式"><a href="#文件的访问方式" class="headerlink" title="文件的访问方式"></a>文件的访问方式</h3><blockquote>
<p>open 默认以<strong>只读</strong>方式打开文件</p>
</blockquote>
<table>
<thead>
<tr>
<th>访问方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>以<strong>只读</strong>方式打开文件，如果文件不存在，则报错</td>
</tr>
<tr>
<td>w</td>
<td>以<strong>只写</strong>方式打开文件，如果文件存在，则会被覆盖；如果文件不存在，则会创建新的文件</td>
</tr>
<tr>
<td>a</td>
<td>以<strong>追加写</strong>方式打开文件，如果文件存在，则从文件末尾追加写入，如果文件不存在，则创建新文件</td>
</tr>
<tr>
<td>r+</td>
<td>以<strong>读写</strong>方式打开文件，其他同 r</td>
</tr>
<tr>
<td>w+</td>
<td>以<strong>读写</strong>方式打开文件，其他同 w</td>
</tr>
<tr>
<td>a+</td>
<td>以<strong>读写</strong>方式打开文件，其他同 a</td>
</tr>
</tbody></table>
<blockquote>
<p>开发中常用只读，只写的方式操作文件</p>
</blockquote>
<h3 id="按行读取文件"><a href="#按行读取文件" class="headerlink" title="按行读取文件"></a>按行读取文件</h3><p><code>file.readline()</code></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python文件</tag>
      </tags>
  </entry>
  <entry>
    <title>Python模块&amp;包</title>
    <url>/2020/04/24/Python/Python_new/Python%E6%A8%A1%E5%9D%97&amp;%E5%8C%85/</url>
    <content><![CDATA[<p>模块是工具的集合, 包是模块的集合</p>
<a id="more"></a>

<h1 id="Python模块-amp-包"><a href="#Python模块-amp-包" class="headerlink" title="Python模块 &amp; 包"></a>Python模块 &amp; 包</h1><p>模块的概念:</p>
<p>导入模块:</p>
<ul>
<li><p><code>import 模块名</code></p>
<p>直接导入模块 (会导入模块中的全部工具)</p>
<p>使用: <code>模块名.工具名</code></p>
</li>
<li><p><code>import 模块名 as 别名</code></p>
<p>直接导入模块,并给模块起别名</p>
<p>使用: <code>别名.工具名</code></p>
</li>
</ul>
<ul>
<li><p><code>from 模块名 import 工具名</code></p>
<p>从模块中导入指定工具</p>
<p>使用: <code>工具名</code></p>
</li>
<li><p><code>from 模块名 import *</code>  (<strong>不推荐使用</strong>, 导入多个模块时, 无法提示重名情况)</p>
<p>从模块中导入全部工具</p>
<p>使用: <code>工具名</code></p>
</li>
</ul>
<p>模块的搜索顺序:</p>
<ol>
<li>会根据模块名, 先在 <strong>当前目录</strong> 找指定文件, 如果有则直接导入</li>
<li>如果当前目录没有, 会到 <strong>系统目录</strong> 中搜索</li>
</ol>
<blockquote>
<p>给文件起名时, 不要与系统模块重名</p>
<p><code>模块名.__file__</code> (内置属性) 可以查看模块的完整路径</p>
</blockquote>
<p><code>__name__</code> 属性:</p>
<p><code>__name__</code> 属性是Python的一个内置属性, 其中记录着一个字符串</p>
<p>字符串会有两种值: </p>
<ul>
<li>如果是当前执行的程序: <code>__name__ == &quot;__main__&quot;</code></li>
<li>如果是被其他文件导入: <code>__name__ == 模块名</code></li>
</ul>
<p>通常用法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入模块</span></span><br><span class="line"><span class="comment"># 定义全局变量</span></span><br><span class="line"><span class="comment"># 定义函数</span></span><br><span class="line"><span class="comment"># 定义类</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 测试相关代码</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 __name__ 判断,如果是当前文件执行,则调用测试代码</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>





<h3 id="安装第三方模块"><a href="#安装第三方模块" class="headerlink" title="安装第三方模块"></a>安装第三方模块</h3><p><code>pip install 模块名</code></p>
<h3 id="Python包"><a href="#Python包" class="headerlink" title="Python包"></a>Python包</h3><p><strong>概念：</strong></p>
<ul>
<li>包是一个包含<strong>多个模块</strong>的<strong>特殊目录</strong></li>
<li>包目录中必须有一个文件：<code>__init__.py</code></li>
<li>包名的命名方式和变量名一致</li>
</ul>
<p>包相较于模块的<strong>优势</strong>：</p>
<p>可以使用 <code>import 包名</code> 一次性导入包中的<strong>所有模块</strong></p>
<p><code>__init__.py</code> 文件：</p>
<p>在 <code>__init__.py</code> 文件中指定要对外界提供的模块的列表</p>
<p>写法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> 模块名<span class="number">1</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> 模块名<span class="number">2</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>



<p>外界使用包：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> 包名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过包调用模块中的相关函数</span></span><br><span class="line">包名.模块名.函数名()</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python模块</tag>
      </tags>
  </entry>
  <entry>
    <title>Python面向对象</title>
    <url>/2020/04/22/Python/Python_new/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>只有一些入门, 待后续深入…</p>
<a id="more"></a>



<h1 id="Python面向对象"><a href="#Python面向对象" class="headerlink" title="Python面向对象"></a>Python面向对象</h1><blockquote>
<p>dir内置函数：</p>
<p>Python中的一切皆对象，像变量、函数等都是对象</p>
<p><code>dir(标识符/数据)</code> 可以查看对象内的所有属性和方法</p>
<p><code>__方法/属性名__</code> ：在方法/属性名前面和后面都有<strong>两个下划线</strong>的格式，是Python为该对象提供的<strong>内置</strong>方法/属性</p>
</blockquote>
<h3 id="定义类-amp-创建对象"><a href="#定义类-amp-创建对象" class="headerlink" title="定义类&amp;创建对象"></a>定义类&amp;创建对象</h3><p>定义类：</p>
<ul>
<li>类名的命名规则：大驼峰</li>
<li>类中定义方法时，第一个参数必须是 <code>self</code>（相当于 <code>this</code>）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> 方法1<span class="params">(self, 参数列表)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> 方法2<span class="params">(self, 参数列表)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>



<p>创建对象：</p>
<p><code>对象变量 = 类名()</code></p>
<p>创建对象的过程：</p>
<ol>
<li>在内存中为对象 分配空间</li>
<li>自动调用 <code>__init__</code> 方法（相当于 <u>构造函数</u>），为属性设置初始值</li>
</ol>
<h3 id="对象的内置方法"><a href="#对象的内置方法" class="headerlink" title="对象的内置方法"></a>对象的内置方法</h3><p><code>__del__</code> 方法，对象销毁之前自动调用的方法 (相当于 Java <code>destroy</code>)</p>
<p><code>__str__</code> 方法，使用该方法可以自定义 <code>print(对象)</code> 输出的内容 (相当于 Java <code>toString</code>)</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Python高级</title>
    <url>/2020/04/20/Python/Python_new/Python%E9%AB%98%E7%BA%A7/</url>
    <content><![CDATA[<p>变量\返回值\参数</p>
<a id="more"></a>



<h1 id="Python高级"><a href="#Python高级" class="headerlink" title="Python高级"></a>Python高级</h1><h3 id="可变类型和不可变类型："><a href="#可变类型和不可变类型：" class="headerlink" title="可变类型和不可变类型："></a>可变类型和不可变类型：</h3><ol>
<li>不可变类型：<ul>
<li>数字</li>
<li>字符串</li>
<li>元组</li>
</ul>
</li>
<li>可变类型：<ul>
<li>列表</li>
<li>字典</li>
</ul>
</li>
</ol>
<ul>
<li><p>可变类型调用方法时，改变的是自身（如：列表）</p>
</li>
<li><p>不可变类型调用方法时，自身不变，生成一个新的（如：字符串）</p>
</li>
</ul>
<blockquote>
<p>字典的 <code>key</code> 只能使用不可变类型的数据</p>
</blockquote>
<h3 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h3><ul>
<li><p>全局变量：定义在函数外部的变量</p>
<ul>
<li><p>在所有的函数中都可以使用全局变量</p>
</li>
<li><p>在Python中，函数内部不能修改全局变量</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">()</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 这里的 num 只是定义的一个局部变量，并不是修改全局变量</span></span><br><span class="line">    <span class="comment"># 如果想在函数内部修改全局变量，使用 global 关键字声明一下全局变量</span></span><br><span class="line">    <span class="comment"># global num</span></span><br><span class="line">    num = <span class="number">66</span></span><br><span class="line">    print(num)  <span class="comment"># 输出 66</span></span><br></pre></td></tr></table></figure>

<ul>
<li>所有的全局变量 定义在 所有的函数 上方</li>
<li>全局变量命名时一般会有一些特殊规则，如变量名前加 <code>g_</code> 或 <code>gl_</code></li>
</ul>
</li>
<li><p>局部变量：定义在函数内部的变量</p>
</li>
</ul>
<h3 id="函数的返回值："><a href="#函数的返回值：" class="headerlink" title="函数的返回值："></a>函数的返回值：</h3><p>函数如果要返回多个数据时，可以使用元组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">measure</span><span class="params">()</span>:</span></span><br><span class="line">    temp = <span class="number">23</span></span><br><span class="line">    wetness = <span class="number">50</span></span><br><span class="line">    <span class="comment"># 如果返回值为元组，小括号可以省略</span></span><br><span class="line">    <span class="keyword">return</span> temp, wetness</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果函数的返回值是元组，可以使用 多个变量（数量与元组元素数量一致）来接收函数的返回结果</span></span><br><span class="line">gl_temp, gl_wetness = measure()</span><br><span class="line">print(gl_temp)</span><br><span class="line">print(gl_wetness)</span><br></pre></td></tr></table></figure>



<h3 id="函数的参数："><a href="#函数的参数：" class="headerlink" title="函数的参数："></a>函数的参数：</h3><blockquote>
<p>在函数中修改参数对外部变量的影响：</p>
<ol>
<li>在函数内部对参数赋值，不会影响外部变量</li>
<li>如果传入的参数是可变类型数据，在函数内部使用方法修改了数据的内容，会影响到外部变量</li>
</ol>
<blockquote>
<p>列表变量使用 <code>+=</code> ,相当于调用了列表的 <code>extend</code> 方法，同样会影响外部变量</p>
</blockquote>
</blockquote>
<h4 id="缺省参数："><a href="#缺省参数：" class="headerlink" title="缺省参数："></a>缺省参数：</h4><p>定义函数时，可以个某个参数指定一个默认值，<strong>具有默认值</strong>的参数就叫缺省参数</p>
<p><strong>缺省参数的注意事项：</strong></p>
<ul>
<li>缺省参数，应该使用<strong>最常见的值</strong>作为默认值</li>
<li>缺省参数必须定义在参数列表的末尾</li>
<li>调用含有多个缺省参数的函数时，需要指定参数名</li>
</ul>
<h4 id="多值参数：（-Java中的可变参数-）"><a href="#多值参数：（-Java中的可变参数-）" class="headerlink" title="多值参数：（ Java中的可变参数 ）"></a>多值参数：（ Java中的可变参数 ）</h4><p>Python中有两种多值参数：</p>
<ul>
<li>参数名前增加  <code>*</code> ，可以接收<strong>元组</strong>  –&gt;  <code>*args</code></li>
<li>参数名前增加  <code>**</code> ，可以接收<strong>字典</strong>  –&gt;  <code>**kwargs</code></li>
</ul>
<p><strong>元组和字典的拆包：</strong></p>
<p>在调用带有多值参数的函数时，如果希望：</p>
<ul>
<li>将一个 元组变量，直接传递给 <code>args</code></li>
<li>将一个 字典变量，直接传递给 <code>kwargs</code></li>
</ul>
<p>就需要使用拆包，拆包方式：</p>
<ul>
<li>在元组变量前，增加 <code>*</code></li>
<li>在字典变量前，增加 <code>**</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    </span><br><span class="line">    print(args)</span><br><span class="line">    print(kwargs)</span><br><span class="line">    </span><br><span class="line">gl_nums = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">gl_people = &#123;<span class="string">"name"</span>:<span class="string">"zhangsan"</span>, <span class="string">"age"</span>:<span class="number">18</span>&#125;</span><br><span class="line"></span><br><span class="line">demo(*gl_num, **gl_people)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python高级</tag>
      </tags>
  </entry>
  <entry>
    <title>Request &amp; Response</title>
    <url>/2020/03/26/Java/2.JavaWeb/9.Request&amp;Response/</url>
    <content><![CDATA[<p>request对象和response对象是由<strong>服务器创建</strong>，我们直接使用<br>request对象用来获取<strong>请求消息</strong>；response对象用来设置<strong>响应消息</strong></p>
<a id="more"></a>


<h1 id="request对象"><a href="#request对象" class="headerlink" title="request对象"></a>request对象</h1><h3 id="Ⅰ-request对象的继承结构："><a href="#Ⅰ-request对象的继承结构：" class="headerlink" title="Ⅰ. request对象的继承结构："></a>Ⅰ. request对象的继承结构：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ServletRequest(接口) </span><br><span class="line">		↑</span><br><span class="line">HttpRequest(接口) </span><br><span class="line">		↑</span><br><span class="line">RequestFacade(实现类 --&gt; Tomcat提供)</span><br></pre></td></tr></table></figure>

<h3 id="Ⅱ-request对象获取请求消息："><a href="#Ⅱ-request对象获取请求消息：" class="headerlink" title="Ⅱ. request对象获取请求消息："></a>Ⅱ. request对象获取请求消息：</h3><ol>
<li><p>获取请求行中的数据：</p>
<ul>
<li><p>获取请求方式：<code>String getMethod()</code></p>
</li>
<li><p>★获取虚拟目录：<code>String getContextPath()</code></p>
</li>
<li><p>★获取Servlet路径：<code>String getServletPath()</code></p>
</li>
<li><p>获取get请求方式的请求参数：<code>String getQueryString()</code></p>
</li>
<li><p>★获取URI/URL：</p>
<p><code>String getRequestURI()</code></p>
<p><code>StringBuffer getRequestURL()</code></p>
</li>
<li><p>获取协议及版本：<code>String getProtocol()</code></p>
</li>
<li><p>获取客户端的IP地址：<code>String getRemoteAddr()</code></p>
</li>
</ul>
</li>
<li><p>获取请求头中的数据</p>
<ul>
<li>★<code>String getHeader(String name)</code>：根据请求头名称获取请求头的值</li>
<li><code>Enumeration&lt;String&gt; getHeaderNames()</code>：获取所有请求头名称</li>
</ul>
</li>
<li><p>获取请求体中的数据</p>
<blockquote>
<p>只有POST请求才有请求体，在请求体中封装了POST请求的请求参数</p>
</blockquote>
<p>获取数据的步骤：</p>
<ol>
<li>获取流对象<ul>
<li><code>BufferReader getReader()</code>: 获取字符输入流，只能操作字符数据</li>
<li><code>ServletInputStream getInputStream()</code>: 获取字节输入流，可以操作所有类型数据</li>
</ul>
</li>
<li>再从流中拿数据</li>
</ol>
</li>
</ol>
<h3 id="Ⅲ-request对象获取请求参数的通用方法："><a href="#Ⅲ-request对象获取请求参数的通用方法：" class="headerlink" title="Ⅲ. request对象获取请求参数的通用方法："></a>Ⅲ. request对象获取请求参数的通用方法：</h3><blockquote>
<p><strong>页面参数的传递：</strong></p>
<p><code>url?key1=value1&amp;key2=value2</code></p>
<p>参数是以<code>键值对</code>的方式进行提交（get和post都是）</p>
<p>两者不同的是：get使用 <code>?</code> 将参数挂在url后面，post则是隐式提交</p>
</blockquote>
<ul>
<li><code>String getParameter(String name)</code>: 根据参数名称获取<strong>参数值</strong></li>
<li><code>String[] getParameter(String name)</code>: 根据参数名称获取参数<strong>值的数组</strong>(多选框)</li>
<li><code>Enumeration&lt;String&gt; getParameterNames()</code>: 获取所有请求参数的<strong>名称</strong></li>
<li><code>Map&lt;String, String[]&gt; getParameterMap()</code>: 获取所有请求<strong>参数的map集合</strong></li>
</ul>
<blockquote>
<p>请求参数中有中文，乱码问题：</p>
<ul>
<li>get方式：Tomcat 8 就已经解决了 get 方式中文乱码的问题</li>
<li>post方式：获取请求参数之前，设置 request 的编码：<ul>
<li><code>request.setCharacterEncoding(&quot;utf-8&quot;)</code></li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="Ⅳ-转发"><a href="#Ⅳ-转发" class="headerlink" title="Ⅳ. 转发"></a>Ⅳ. 转发</h3><p><strong>原理：</strong>转发是服务器内部进行资源访问，一次请求，一次响应</p>
<p><strong>语法：</strong><code>request.getRequestDispatcher(&quot;路径&quot;).forward(request,response);</code></p>
<p><strong>注意：</strong></p>
<ul>
<li>转发中的路径为绝对路径去掉 <strong>/项目名</strong>，又称<strong>内部路径</strong></li>
<li>转发后，浏览器地址栏中的<strong>地址不发生变化</strong></li>
<li>转发可以访问到 <strong>WEB-INF</strong> 下的资源</li>
<li>转发只能访问<strong>当前服务器</strong>下的资源</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转发到普通页面</span></span><br><span class="line">request.getRequestDisPatcher(<span class="string">"/index.html"</span>).forward(request,response);</span><br><span class="line"><span class="comment">// 转发到 WEB-INF 下的资源</span></span><br><span class="line">request.getRequestDispatcher(<span class="string">"/WEB-INF/html/index.html"</span>).forward(request,response);</span><br><span class="line"><span class="comment">// 转发到另一个 servlet</span></span><br><span class="line">request.getRequestDispatcher(<span class="string">"/Myservlet2.do"</span>).forward(request,response);</span><br></pre></td></tr></table></figure>



<h3 id="Ⅴ-共享数据"><a href="#Ⅴ-共享数据" class="headerlink" title="Ⅴ. 共享数据"></a>Ⅴ. 共享数据</h3><p><strong>域对象：</strong>一个有作用范围的对象，可以在作用范围内共享数据</p>
<p><strong>request域对象</strong>：代表一次请求的范围，一般用于请求转发的多个资源中共享数据</p>
<p>方法：</p>
<ul>
<li><code>setAttribute(String name, Object obj)</code>: 存储数据（键值对形式）</li>
<li><code>getAttribute(String name)</code>: 通过键获取值</li>
<li><code>removeAttribute(String name)</code>: 通过键删除数据</li>
</ul>
<h3 id="Ⅵ-获取-ServletContext-对象"><a href="#Ⅵ-获取-ServletContext-对象" class="headerlink" title="Ⅵ. 获取 ServletContext 对象"></a>Ⅵ. 获取 ServletContext 对象</h3><p><code>ServletContext context = request.getServletContext()</code></p>
<br/>

<h1 id="response对象"><a href="#response对象" class="headerlink" title="response对象"></a>response对象</h1><h3 id="Ⅰ-response对象设置响应消息："><a href="#Ⅰ-response对象设置响应消息：" class="headerlink" title="Ⅰ. response对象设置响应消息："></a>Ⅰ. response对象设置响应消息：</h3><ol>
<li><p>设置响应行</p>
<p>设置状态码：<code>setStatus(int sc)</code></p>
</li>
<li><p>设置响应头</p>
<p><code>setHeader(String name, String value)</code></p>
</li>
<li><p>设置响应体</p>
<ul>
<li><p>获取输出流</p>
<ul>
<li><p>字符输出流：<code>PrintWriter getWriter()</code></p>
</li>
<li><p>字节输出流：<code>ServletOutputStream getOutputStream()</code></p>
</li>
</ul>
</li>
<li><p>使用输出流，将数据输出到浏览器</p>
</li>
</ul>
</li>
</ol>
<h3 id="Ⅱ-重定向"><a href="#Ⅱ-重定向" class="headerlink" title="Ⅱ. 重定向"></a>Ⅱ. 重定向</h3><p><strong>原理：</strong> 重定向是服务器响应重定向资源的路径，浏览器再根据响应的路径访问资源，<strong>两次请求，两次响应</strong></p>
<blockquote>
<p>第一次请求时，服务器返回给浏览器的内容：</p>
<ol>
<li>状态码：302，告诉浏览器进行重定向</li>
<li>响应头：<code>location:重定向资源的路径</code></li>
</ol>
</blockquote>
<p><strong>语法：</strong><code>response.sendRedirect(&quot;路径&quot;);</code></p>
<p><strong>注意：</strong></p>
<ul>
<li>重定向的路径为传统的<strong>绝对路径</strong></li>
<li>重定向后，浏览器地址栏中的地址会变为<strong>重定向后的地址</strong></li>
<li>重定向<strong>不能</strong>够访问 WEB-INF 下的资源</li>
<li>重定向可以访问到<strong>其他服务器</strong>的资源</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重定向到普通页面</span></span><br><span class="line">response.sendRedirect(<span class="string">"/2_Servlet/index.html"</span>);</span><br><span class="line"><span class="comment">// 重定向到另一个 servlet</span></span><br><span class="line">response.sendRedirect(<span class="string">"/2_servlet/Myservlet4.do"</span>);</span><br></pre></td></tr></table></figure>


<blockquote>
<p>绝对路径和相对路径: （一般情况下都是使用 绝对路径）</p>
<ul>
<li><p>相对路径（通过相对路径不可以确定唯一资源）</p>
<ul>
<li><p>如：<code>./index.html</code></p>
</li>
<li><p>不以 <code>/</code> 开头，以 <code>.</code> 开头</p>
</li>
<li><p>书写技巧：找到当前资源和目标资源的相对位置关系</p>
<ul>
<li><code>./</code>: 当前目录</li>
<li><code>../</code>: 后退一级目录</li>
</ul>
</li>
</ul>
</li>
<li><p>绝对路径（通过绝对路径可以确定唯一资源）</p>
<ul>
<li>如：<code>/day01/responseDemo02</code></li>
<li>以 <code>/</code> 开头</li>
<li>书写技巧：判断定义的路径是谁使用（判断请求从哪发出）<ul>
<li>浏览器使用(浏览器发出请求)：需要加虚拟目录（重定向，html中 a标签，form表单，）</li>
<li>服务器使用(服务器发出请求)：不需要加虚拟目录（转发操作）</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="Ⅲ-response-输出数据"><a href="#Ⅲ-response-输出数据" class="headerlink" title="Ⅲ. response 输出数据"></a>Ⅲ. response 输出数据</h3><p>在创建流之前，可以加一行<strong>字符编码设置信息</strong>，预防字符乱码</p>
<p><code>response.setContentType(&quot;text/html;charset=utf-8&quot;);</code></p>
<p><strong>使用步骤：</strong></p>
<ol>
<li>输出字符数据</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取字符输出流(流名称: out 约定俗成)</span></span><br><span class="line">PrintWriter out = response.getWriter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用流 输出信息</span></span><br><span class="line">out.write(<span class="string">"要输出的字符信息"</span>);</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>输出字节数据</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取字节输出流</span></span><br><span class="line">ServletOutputStream out = response.getOutputStream();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出信息</span></span><br><span class="line">out.write(<span class="string">"要输出的字节信息"</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>Request</tag>
        <tag>Response</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP</title>
    <url>/2020/03/24/Java/2.JavaWeb/6.HTTP/</url>
    <content><![CDATA[<p>互联网三大基石之一</p>
<a id="more"></a>

<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p><strong>概念：</strong>超文本传输协议（Hyper Text Transfer Protocol）</p>
<p><strong>作用：</strong>规范了浏览器和服务器的数据交互的格式</p>
<p><strong>特点：</strong></p>
<ul>
<li>基于TCP/IP的高级协议</li>
<li>默认端口号为 80</li>
<li>基于请求/响应模型：一次请求对应一次响应</li>
<li>无状态：每次请求之间相互独立</li>
</ul>
<p>历史版本：</p>
<ul>
<li>1.0：每一次请求都会建立一个新的连接</li>
<li>1.1：连接可复用</li>
</ul>
<p><strong>HTTP的交互流程：</strong></p>
<ol>
<li><p>客户端与服务器端建立连接</p>
</li>
<li><p>客户端发送<strong>请求</strong>数据到服务器端</p>
</li>
<li><p>服务器端接收到请求后进行处理，然后将处理结果<strong>响应</strong>客户端</p>
</li>
<li><p>关闭客户端与服务器端的连接（HTTP1.1之后不会马上关闭）</p>
</li>
</ol>
<h4 id="HTTP协议-–-请求格式："><a href="#HTTP协议-–-请求格式：" class="headerlink" title="HTTP协议 – 请求格式："></a>HTTP协议 – 请求格式：</h4><p>结构：</p>
<ul>
<li><p><strong>请求行：</strong>请求方式、请求地址(url)、HTTP协议版本</p>
<p>请求方式：HTTP协议有7种请求方式，主要还是get和post</p>
<ul>
<li>get请求：<ul>
<li>请求参数会以?的形式隔开拼接在请求行中，相对不安全</li>
<li>因为浏览器对URL的长度有限制，所以get请求不能携带大量数据</li>
<li>没有请求体</li>
</ul>
</li>
<li>post请求：<ul>
<li>请求数据在请求体中进行发送，相对安全</li>
<li>可以携带大量数据</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>请求头</strong>：消息报头，浏览器告诉服务器的一些信息</p>
<p>常见请求头：</p>
<ul>
<li><p><code>User-Agent</code>：浏览器的版本信息</p>
<p>可以在服务器端获取User-Agent的信息，来解决浏览器兼容性的问题</p>
</li>
<li><p><code>Referer</code>：告诉服务器，当前请求从哪里来</p>
<p>作用：防盗链、做相关统计</p>
</li>
</ul>
</li>
<li><p><strong>空行：</strong>用于分隔请求头和请求体，必须要有</p>
</li>
<li><p><strong>请求体：</strong>get方式没有，post方式有</p>
</li>
</ul>
<h4 id="HTTP协议-–-响应格式："><a href="#HTTP协议-–-响应格式：" class="headerlink" title="HTTP协议 – 响应格式："></a>HTTP协议 – 响应格式：</h4><p>结构：</p>
<ul>
<li><p>响应行：HTTP版本，状态码，状态消息</p>
</li>
<li><p>响应头：消息报头，客户端使用的附加信息</p>
<p>常见响应头：</p>
<ul>
<li><code>Content-Type</code>: 响应体数据格式 及 字符编码</li>
<li><code>Content-disposition</code>: 打开响应体数据的位置<ul>
<li><code>in-line</code>: 默认值，在当前页面打开响应体</li>
<li><code>attachment; filename=xxx</code>: 以附件形式打开响应体（文件下载）</li>
</ul>
</li>
</ul>
</li>
<li><p>空行：响应行和响应实体之间，必须要有</p>
</li>
<li><p>响应体（数据）：正文，服务器返回给浏览器的信息</p>
</li>
</ul>
<p><strong>HTTP常见响应状态码含义：</strong></p>
<p>HTTP状态码都是三位数，共分为5种类型：</p>
<ul>
<li>1**：信息，服务器收到请求，需要请求者继续执行操作</li>
<li>2**：成功，操作被成功接收并处理</li>
<li>3**：重定向，需要进一步的操作以完成请求</li>
<li>4**：客户端错误，请求包含语法错误或无法完成请求</li>
<li>5**：服务器错误，服务器在处理请求的过程中发生了错误</li>
</ul>
<p>常见状态码：</p>
<ul>
<li>200 OK ：客户请求成功</li>
<li>302：重定向</li>
<li>400 Bad Request ：客户端请求有语法错误</li>
<li>401 Unauthorized ：请求未经授权</li>
<li>403 Forbidden ：服务器收到请求，但是拒绝提供服务</li>
<li>404 Not Found ：请求资源找不到了</li>
<li>500 Interval Server Error ：服务器内部出现了错误</li>
<li>503 Server Unavailable：服务器当前不能处理请求，一段时间后可能恢复正常</li>
</ul>
]]></content>
      <categories>
        <category>其他技术</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>idea中使用maven遇到的一些小问题</title>
    <url>/2020/03/20/Java/idea%E4%B8%AD%E4%BD%BF%E7%94%A8maven%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在pom.xml 中导坐标没有提示, 点击<strong>阅读全文</strong>看看如何解决吧.</p>
<a id="more"></a>

<h2 id="idea中使用maven遇到的一些小问题"><a href="#idea中使用maven遇到的一些小问题" class="headerlink" title="idea中使用maven遇到的一些小问题"></a>idea中使用maven遇到的一些小问题</h2><p>idea版本：2019.3.2，maven版本：3.6.1（idea内置maven）</p>
<p>在使用idea构建maven项目，在项目的pom.xml文件中导坐标时，发现<strong>输入之后没有提示了</strong>，之前使用idea的时候没有遇到过这种情况。</p>
<p>首先想到的是maven的问题，因为之前都是使用自己的maven，所以我就去maven官网自己下载了maven 3.6.3版本，但是在idea中配置了自己的maven之后并没有作用，还是不提示。。</p>
<p>去百度，关于没有提示，是因为没有maven索引造成的，大家给出的解决方案都是在idea–&gt;file–&gt;settings–&gt;maven–&gt;repository 中把两个仓库update一下就好了，这是一个建立索引的过程，索引文件夹在 ${用户目录}.IntelliJIdea2019.1\system\Maven\Indices 中。</p>
<p>点击update，local直接完成，<strong>remote一直error，检查发现，是在maven的setting.xml文件中配置了仓库的mirror</strong>，需要先把mirror注释掉，然后再更新remote仓库（需要网络环境良好）</p>
<p>local和remote都update完成之后，再次尝试是否有提示了，发现在手动 ctrl+shift+space 提示，可以出现提示，但是过程非常卡。。。</p>
<p>这时候就又去百度了，看到大家说idea 2019.2 和 maven 的兼容性出了一些问题，导致idea–&gt;file–&gt;settings–&gt;maven–&gt;repository 中没有内容，local和remote都没有。有人也是和我一样的问题，确定是idea版本的问题，大家都说2019.2.x 和2019.3.x bug甚多。</p>
<p>更换版本：idea 2019.3.4，最新的一个release版本（截止2019.3.19），以为idea会把这个小问题给干掉了，结果。。。</p>
<p>更换版本：<strong>idea 2019.1.4</strong>，2019.2 之前的最后一个版本，<strong>一切OK</strong>（这个版本很多朋友都推荐，完全没有maven相关的问题）</p>
]]></content>
      <categories>
        <category>bugfix</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL学习知识点总结</title>
    <url>/2020/03/01/Java/MySQL%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>MySQL知识点的总结, 让学习更有方向</p>
<a id="more"></a>



<h1 id="MySQL学习知识点总结"><a href="#MySQL学习知识点总结" class="headerlink" title="MySQL学习知识点总结"></a>MySQL学习知识点总结</h1><ol>
<li>数据库的基本概念,关系型数据库的基本概念</li>
<li>MySQL的基本使用(安装，卸载，启动服务，登录、退出数据库)</li>
<li>SQL的学习（DDL, DML, DQL, DCL）</li>
<li>增，删，改</li>
<li>查<ul>
<li>基础查询</li>
<li>where</li>
<li>like  _ %</li>
<li>between  and </li>
<li>in</li>
<li>order by</li>
<li>聚合函数</li>
<li>group by having</li>
<li>分页查询</li>
</ul>
</li>
<li>表的约束：主键，非空，唯一，自增，外键</li>
<li>关系型数据库的三大范式</li>
<li>多表查询：内连接，外连接（左外，右外），子查询</li>
<li>数据库的事务：<ul>
<li>开启事务，提交，回滚</li>
<li>事务的四大特征</li>
<li>事务的隔离级别</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC学习知识点总结</title>
    <url>/2020/03/01/Java/1.Java%E5%9F%BA%E7%A1%80/JDBC%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>JDBC的学习中比较重要的点</p>
<a id="more"></a>

<h1 id="JDBC学习知识点总结"><a href="#JDBC学习知识点总结" class="headerlink" title="JDBC学习知识点总结"></a>JDBC学习知识点总结</h1><p>使用 JDBC 的步骤：</p>
<ol>
<li>注册驱动</li>
<li>获取连接对象</li>
<li>书写SQL语句</li>
<li>获取执行SQL的对象</li>
<li>执行SQL</li>
<li>[ 封装结果集 ] – 查询</li>
</ol>
<p>相关对象</p>
<p>Connection</p>
<p>Statement</p>
<p>PreparedStatement</p>
<p>ResultSet</p>
<p>JDBC事务</p>
<p>数据库连接池</p>
<p>Spring的 JDBCTemplate</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>学习中遇到的问题</title>
    <url>/2020/02/06/%E5%85%B6%E5%AE%83%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<a id="more"></a>
<ol>
<li><p><strong>在Mac中配置maven环境变量</strong></p>
<ol>
<li><p>maven下载tar.gz 格式压缩包 下载完成会自动解压</p>
</li>
<li><p>将解压后的maven拖入终端可以得到maven解压后的路径</p>
</li>
<li><p>在终端输入 vim ~/.bash_profile</p>
</li>
<li><p>按 i 进入编辑</p>
</li>
<li><p>输入以下命令</p>
<p>MAVEN_HOME=/Users/qiuzhijie/Downloads/apache-maven-3.5.4  （这里是自己的maven路径）PATH=$JAVA_HOME/bin:$MAVEN_HOME/bin:$PATH:</p>
<p>export MAVEN_HOME PATH</p>
</li>
<li><p>按esc  :wq  保存编辑</p>
</li>
<li><p>终端输入source .bash_profile</p>
</li>
<li><p>mvn -v 如果有maven的信息则说明配置成功</p>
</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title>Python数据分析</title>
    <url>/2019/12/10/Python/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>用Python做数据分析</p>
<a id="more"></a>

<h1 id="Python数据分析"><a href="#Python数据分析" class="headerlink" title="Python数据分析"></a>Python数据分析</h1><p>python做数据分析的几个常用库：numpy，pandas</p>
<h2 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h2><p>Anaconda是一个基于conda的<strong>整合框架</strong>，其中包含了<strong>Spyder</strong> 和 <strong>IPython</strong></p>
<ul>
<li><p>conda：包管理和环境管理工具</p>
</li>
<li><p>Spyder：一个python的IDE</p>
</li>
<li><p>IPython：python的交互式shell</p>
<ul>
<li><p>变量<strong>前面</strong>或<strong>后面</strong>加上 <code>?</code>，可以显示变量的一些通用信息，如果是函数会显示源代码</p>
</li>
<li><p><code>%run</code>：运行python程序（在一个空的命名空间内运行python程序）</p>
<p><code>%run demo.py</code></p>
</li>
<li><p><code>%</code>魔术命令：</p>
<ul>
<li><code>%magic</code>：显示所有魔术命令</li>
<li><code>%hist</code>：显示IPython的输入历史</li>
<li><code>pdb</code>：异常发生后自动进入调试器</li>
<li><code>%reset</code>：删除当前命名空间中所有变量或名称</li>
<li><code>%time 执行语句</code>：给出代码的执行时间</li>
<li><code>%timeit 执行语句</code>：多次执行代码，计算综合平均执行时间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="NumPy"><a href="#NumPy" class="headerlink" title="NumPy"></a>NumPy</h2><p><strong>简介</strong>：NumPy是一个开源的python科学计算基础库</p>
<p>NumPy包含：</p>
<ul>
<li>一个强大的N维<strong>数组对象</strong> ndarray</li>
<li>广播功能函数</li>
<li>整合C/C++/Fortran代码的工具</li>
<li>线性代数、傅里叶变换、随机数生成等功能</li>
</ul>
<p>NumPy是SciPy、Pandas等科学计算及数据处理库的基础</p>
<h3 id="ndarray"><a href="#ndarray" class="headerlink" title="ndarray"></a>ndarray</h3><p>ndarray是一个<strong>N维数组对象</strong>，由两部分组成：</p>
<ul>
<li>实际的数据</li>
<li>描述这些数据的<strong>元数据</strong>（数据维度、数据类型等）</li>
</ul>
<blockquote>
<ul>
<li>ndarray数组一般要求所有的<strong>元素的类型相同</strong>（<strong>同质</strong>）</li>
<li>ndarray数组可以由非同质元素组成，但是由非同质元素组成的时候，数组中的每个元素都会被看成 object 类型。</li>
<li>非同质元素组成的ndarray数组无法发挥NumPy的优势，尽量避免使用</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><p>ndarray在程序中的别名是：<code>array</code>，所以在程序中使用 <code>np.array()</code> 来创建一个数组</p>
</li>
<li><p><code>np.array()</code> 输出成 <code>[]</code> 形式，元素由空格分隔</p>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>轴（axis）：保存数据的<strong>维度</strong></li>
<li>秩（rank）：轴的<strong>数量</strong> / 有几个维度</li>
</ul>
</blockquote>
<p><strong>ndarray数组对象的属性</strong>：</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">.ndim</td>
<td align="left">秩，即轴的数量或维度的数量</td>
</tr>
<tr>
<td align="left">.shape</td>
<td align="left">数组的尺度，对于矩阵，n行m列</td>
</tr>
<tr>
<td align="left">.size</td>
<td align="left">数组中元素的个数</td>
</tr>
<tr>
<td align="left">.dtype</td>
<td align="left">数组中数据的类型</td>
</tr>
<tr>
<td align="left">.itemsize</td>
<td align="left">每个元素所占内存空间大小，以字节为单位</td>
</tr>
</tbody></table>
<p><strong>ndarray数组的创建方法：</strong></p>
<ul>
<li>从python中的列表、元组等类型创建ndarray数组<ul>
<li><code>x = np.array(list/tuple)</code></li>
<li><code>x = np.array(list/tuple, dtype = np.float32)</code></li>
</ul>
</li>
<li>使用NumPy中的相关函数创建ndarray数组</li>
</ul>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>np.arange(n)</code></td>
<td align="left">类似 <code>range()</code> 函数，返回 <code>ndarray</code> 类型，元素从 <code>0</code> 到 <code>n-1</code></td>
</tr>
<tr>
<td align="left"><code>np.ones(shape)</code></td>
<td align="left">根据 <code>shape</code> 生成一个全 <code>1</code> 的数组，shape是<strong>元组类型</strong></td>
</tr>
<tr>
<td align="left"><code>np.zeros(shape)</code></td>
<td align="left">根据 shape 生成一个全0的数组，shape是<strong>元组类型</strong></td>
</tr>
<tr>
<td align="left"><code>np.full(shape, val)</code></td>
<td align="left">根据 shape 生成一个数组，每个元素的值都是 val</td>
</tr>
<tr>
<td align="left"><code>np.eye(n)</code></td>
<td align="left">创建一个n*n的矩阵，对角线元素为1，其余全为0</td>
</tr>
<tr>
<td align="left"><code>np.ones_like(a)</code></td>
<td align="left">根据数组 a的形状创建一个全1的数组</td>
</tr>
<tr>
<td align="left"><code>np.zeros_like(a)</code></td>
<td align="left">根据数组a的形状创建一个全0的数组</td>
</tr>
<tr>
<td align="left"><code>np.full_like(a, val)</code></td>
<td align="left">根据数组a的形状创建一个全val的数组</td>
</tr>
<tr>
<td align="left"><code>np.linspace()</code></td>
<td align="left">根据起止数据等间距的填充数据，形成数组</td>
</tr>
<tr>
<td align="left"><code>np.concatenate()</code></td>
<td align="left">将两个或多个数组合并成一个新的数组</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不指定dtype，默认为浮点数</span></span><br><span class="line">In[<span class="number">24</span>]: np.ones((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">Out[<span class="number">24</span>]: </span><br><span class="line">array([[<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>]])</span><br></pre></td></tr></table></figure>

<ul>
<li>从字节流中创建ndarray数组</li>
<li>从文件中读取特定格式，创建ndarray数组</li>
</ul>
<p><strong>ndarray数组的变换：</strong></p>
<p>对于创建后的ndarray数组，可以对其进行<strong>维度变换</strong>和<strong>元素类型变换</strong></p>
<ul>
<li>维度变换 (<code>a=np.array(list)</code>)</li>
</ul>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>a.reshape(shape)</code></td>
<td align="left">不改变原数组，返回一个shape形状的数组，shape为元祖</td>
</tr>
<tr>
<td align="left"><code>a.resize(shape)</code></td>
<td align="left">将原数组修改，然后返回</td>
</tr>
<tr>
<td align="left"><code>a.swapaxes(ax1, ax2)</code></td>
<td align="left">将数组n个维度中两个维度进行调换</td>
</tr>
<tr>
<td align="left"><code>a.flatten()</code></td>
<td align="left">不改变原数组，返回降维后的一维数组</td>
</tr>
</tbody></table>
<ul>
<li><p>类型变换</p>
<p><code>new_a = a.astype(new_type)</code></p>
</li>
</ul>
<p>ndarray数组转换为列表：</p>
<p> <code>ls = a.tolist()</code></p>
<p><strong>ndarray数组的 索引 和切片</strong></p>
<p>一维数组的索引：<code>a[2]</code></p>
<p>一维数组的切片：<code>a[1:4:2]</code></p>
<p>多维数组的索引：<code>a[2,1,3]</code></p>
<p>多维数组的切片：<code>a[:,1:3,:3]</code></p>
<p><strong>ndarray数组的运算</strong></p>
<ol>
<li><p>数组与标量之间的运算作用于数组的每一个元素</p>
</li>
<li><p>使用函数对ndarray数组进行运算</p>
<ol>
<li><p>一元函数：（使用一元函数，都不会修改原数组）</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>np.abs(x)</code> \ <code>np.fabs(x)</code></td>
<td>计算 数组各元素的<strong>绝对值</strong></td>
</tr>
<tr>
<td><code>np.sqrt(x)</code></td>
<td>计算 数组各元素的<strong>平方根</strong></td>
</tr>
<tr>
<td><code>np.square(x)</code></td>
<td>计算 数组各元素的<strong>平方</strong></td>
</tr>
<tr>
<td><code>np.log(x)</code> \ <code>np.log10(x)</code> \ <code>np.log2(x)</code></td>
<td>计算 数组各元素的自然<strong>对数</strong>、10为底的对数、2为底的对数</td>
</tr>
<tr>
<td><code>np.ceil(x)</code> \ <code>np.floor(x)</code></td>
<td>计算 数组各元素的 <strong>ceiling</strong> 值、<strong>floor</strong>值</td>
</tr>
<tr>
<td><code>np.rint(x)</code></td>
<td>计算 数组各元素的<strong>四舍五入</strong>值</td>
</tr>
<tr>
<td><code>np.modf(x)</code></td>
<td>将数组各元素的小数部分和整数部分以两个独立数组形式返回</td>
</tr>
<tr>
<td><code>np.exp(x)</code></td>
<td>计算 数组各元素的<strong>指数值</strong></td>
</tr>
<tr>
<td><code>np.sign(x)</code></td>
<td>计算 数组各元素的<strong>符号值</strong>，1， 0， -1</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<ol start="2">
<li><p>二元函数：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>+  -  *  /  **</code></td>
<td>两个数组各元素进行对应计算</td>
</tr>
<tr>
<td><code>np.maximum(x,y)</code> \ <code>np.minimum(x,y)</code></td>
<td>两个数组各元素进行对应比较，返回最大、最小值</td>
</tr>
<tr>
<td><code>np.mod(x,y)</code></td>
<td>元素级模运算</td>
</tr>
<tr>
<td><code>np.copysign(x,y)</code></td>
<td>将数组y中各元素值的符号赋值给数组x对应元素</td>
</tr>
<tr>
<td><code>&gt;  &lt;  &gt;=  &lt;=  ==  !=</code></td>
<td>算术比较，产生布尔型数组</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="数据的CSV文件的存取"><a href="#数据的CSV文件的存取" class="headerlink" title="数据的CSV文件的存取"></a>数据的CSV文件的存取</h3><blockquote>
<p> CSV:(Comma-Separated Value, 逗号分隔值)</p>
</blockquote>
<p>将数组保存到文件中：</p>
<ol>
<li><p>np.savetxt(frame, array, fmt=’%.18e’, delimiter=None)</p>
<ul>
<li>frame: 要存入的文件，可以是.gz或.bz2的压缩文件</li>
<li>array: 要存入文件的数组</li>
<li>fmt: 写入文件的格式，如：%d，%.2f，%.18e</li>
<li>delimiter: 分隔字符串，默认是空格</li>
</ul>
</li>
</ol>
<p>读取文件到数组中：</p>
<p>np.loadtxt(frame, dtype=np.float, delimiter=None, unpack=False)</p>
<ul>
<li>frame: 要读取的文件，可以是.gz或.bz2的压缩文件</li>
<li>dtype: 数据类型，可选</li>
<li>delimiter: 分隔字符串，默认为空格</li>
<li>unpack: 如果是True，读入属性将分别写入不同变量</li>
</ul>
<p>csv文件的局限性：</p>
<ul>
<li><p>csv文件只能有效的存储一维和二维数组</p>
</li>
<li><p>np.savetxt() &amp; np.loadtxt() 只能有效存取一维和二维数组</p>
</li>
</ul>
<h3 id="多维数据的存取"><a href="#多维数据的存取" class="headerlink" title="多维数据的存取"></a>多维数据的存取</h3><p>存多维数据</p>
<p><code>np.tofile(frame, sep=&#39;&#39;, format=&#39;%s&#39;)</code></p>
<ul>
<li>frame: 文件，字符串</li>
<li>sep: 数据分隔字符串，如果是空串，则写入为二进制文件</li>
<li>format: 写入数据格式</li>
</ul>
<p>读多维数据</p>
<p><code>np.fromfile(frame, dtype=float, count=-1, sep=&#39;&#39;)</code></p>
<ul>
<li>frame: 文件，字符串</li>
<li>dtype: 读入的数据类型</li>
<li>count: 读入元素的个数，-1代表读入整个文件</li>
<li>: 数据分隔字符串，如果为空串，读入的为二进制文件</li>
</ul>
<blockquote>
<p>上面的存取多维数据的方法无法存取维度信息</p>
<p>要想读取的时候复原维度信息，需要使用reshape</p>
</blockquote>
<p>Numpy提供的便捷文件存取</p>
<p><code>np.save(fname, array)</code>或<code>np.savez(fname, array)</code></p>
<ul>
<li>fname: 文件名，扩展名为.npy，压缩扩展名为npz</li>
<li>array: 数组变量</li>
</ul>
<p><code>np.load(fname)</code></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>yaml</title>
    <url>/2019/10/14/yaml/</url>
    <content><![CDATA[<p>Yaml 主要用于配置文件</p>
<a id="more"></a>

<h1 id="yaml"><a href="#yaml" class="headerlink" title="yaml"></a>yaml</h1><h3 id="基本介绍："><a href="#基本介绍：" class="headerlink" title="基本介绍："></a>基本介绍：</h3><p>是一种以<strong>数据</strong>为核心的语言</p>
<h3 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h3><p>k:(空格)v  –&gt; 表示一堆键值对（空格必须要有）</p>
<p>以<strong>空格的缩进</strong>来控制层级关系，只要一列数据左对齐，它们就属于同一个层级</p>
<p>k，v 都是大小写敏感的</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span> </span><br><span class="line">    <span class="attr">port:</span> <span class="number">8090</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/hello</span></span><br></pre></td></tr></table></figure>



<h4 id="值的类型："><a href="#值的类型：" class="headerlink" title="值的类型："></a>值的类型：</h4><ul>
<li><p>字面量(数字，字符串，布尔)</p>
<ul>
<li>直接写，字符串不需要加引号</li>
</ul>
</li>
<li><p>对象，map</p>
</li>
<li><p>集合(list, set) : 用 - 表示集合中的元素</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">fruits:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">apple</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">orange</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">banana</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="获取配置文件中的值："><a href="#获取配置文件中的值：" class="headerlink" title="获取配置文件中的值："></a>获取配置文件中的值：</h3><p>在Javabean中获取yaml配置文件中的值：使用@ConfigurationProperties注解</p>
<ul>
<li>Javabean</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>  <span class="comment">// 将Javabean添加到容器中</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"people"</span>)  <span class="comment">// 获取yaml中值的注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isman;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// Getter &amp; Setter (必须要有)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>yaml配置文件</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">people:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">lisi</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line">  <span class="attr">isman:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">dog:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">niuer</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">list:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">haha</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">hehe</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">heihei</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">xixi</span></span><br></pre></td></tr></table></figure>



<h4 id="Value获取值和-ConfigurationProperties获取值的区别"><a href="#Value获取值和-ConfigurationProperties获取值的区别" class="headerlink" title="@Value获取值和@ConfigurationProperties获取值的区别"></a>@Value获取值和@ConfigurationProperties获取值的区别</h4><table>
<thead>
<tr>
<th></th>
<th>@ConfigurationProperties</th>
<th>@Value</th>
</tr>
</thead>
<tbody><tr>
<td>获取方式</td>
<td>批量注入配置文件中的属性</td>
<td>一个个注入</td>
</tr>
<tr>
<td>松散绑定</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>SpEL</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>JSR303数据校验</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>复杂类型封装</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<p><strong>使用哪一个？</strong></p>
<ul>
<li>如果只是在业务逻辑中获取配置文件中的某个值，用@Value</li>
<li>如果专门写了一个Javabean来和配置文件进行映射时，用@ConfigurationProperties</li>
</ul>
]]></content>
      <tags>
        <tag>yaml</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot</title>
    <url>/2019/10/09/Java/springboot/</url>
    <content><![CDATA[<p>springboot入门</p>
<a id="more"></a>

<h1 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h1><p>Springboot项目的快速创建：使用 <strong>idea</strong> 里面的 *<em>Spring Initializr *</em></p>
<h2 id="Spring中常用注解："><a href="#Spring中常用注解：" class="headerlink" title="Spring中常用注解："></a>Spring中常用注解：</h2><p><strong>@ConfigurationProperties(prefix = “people”)</strong>：获取主配置文件中people层级下的值，并把它赋给注解所在类。</p>
<ul>
<li><p>与 @Bean 结合为属性赋值</p>
</li>
<li><p>与 @PropertySource() 结合读取指定配置文件（只能是properties配置文件）中的值</p>
</li>
</ul>
<p><strong>@ImportResource()</strong>：导入Spring的配置文件，让配置文件中的内容生效（因为Spring Boot里面没有Spring的配置文件，自己写的话就需要用这个注解导入使其生效）</p>
<ul>
<li>需要标注在主配置类上</li>
<li><u>这个并不常用，因为Spring Boot中一般使用全注解的方式</u></li>
</ul>
<p>Spring Boot 推荐的给容器中添加组件的方式：在配置类中使用@Bean注解</p>
<ul>
<li>配置类：用于替代配置文件，一个普通的Java类加上@Configuration注解</li>
<li>@Bean： 标注在配置类中的方法上，将方法的返回值作为组件添加到容器中，这个组件在容器中的默认id就是方法名</li>
</ul>
<h2 id="配置文件占位符："><a href="#配置文件占位符：" class="headerlink" title="配置文件占位符："></a>配置文件占位符：</h2><p><strong>在配置文件中获取随机数</strong>：${random.value}、${random.int}</p>
<p>占位符可以获取之间配置过的值，如果没有，可以指定默认值</p>
<ul>
<li><p>${app.name} ：获取值</p>
</li>
<li><p>${app.name:默认值}：没有值的情况下指定默认值</p>
</li>
</ul>
<h2 id="Profile-多环境支持"><a href="#Profile-多环境支持" class="headerlink" title="Profile 多环境支持"></a>Profile 多环境支持</h2><blockquote>
<p>在Spring中可以使用Profile来快速切换环境，如生产环境，测试环境等，可以快速为每种环境设置不同的参数</p>
</blockquote>
<h3 id="多文件形式的Profile："><a href="#多文件形式的Profile：" class="headerlink" title="多文件形式的Profile："></a>多文件形式的Profile：</h3><ul>
<li>可以新建多个配置文件，每一个配置文件对应一种使用环境，配置文件命名的要求：<ul>
<li>application-{profile}.properties –&gt; application-dev.properties</li>
</ul>
</li>
</ul>
<h3 id="文档块形式-yaml配置文件-的Profile："><a href="#文档块形式-yaml配置文件-的Profile：" class="headerlink" title="文档块形式(yaml配置文件)的Profile："></a>文档块形式(yaml配置文件)的Profile：</h3><p>yaml配置文件支持多文档块的形式</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8081</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">profiles</span>:<span class="string"></span></span><br><span class="line"></span><br><span class="line"><span class="attr">active</span>: <span class="string">dev</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8082</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">profiles</span>: <span class="string">dev</span></span><br><span class="line"></span><br><span class="line"><span class="attr">---</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8083</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">profiles</span>: <span class="string">prod</span></span><br></pre></td></tr></table></figure>

<h3 id="Profile的激活方式："><a href="#Profile的激活方式：" class="headerlink" title="Profile的激活方式："></a>Profile的激活方式：</h3><p>配置文件：spring.profiles.active=dev</p>
<p>命令行：–spring.profiles.active=dev</p>
<p>jvm：-Dpring.profiles.active=dev</p>
<h2 id="配置文件的加载位置"><a href="#配置文件的加载位置" class="headerlink" title="配置文件的加载位置"></a>配置文件的加载位置</h2><p>spring boot 启动之后会默认访问以下位置下的 application.properties 或 application.yaml来作为主配置文件</p>
<p>优先级由高到低：</p>
<ol>
<li>file:/config/</li>
<li>file:/</li>
<li>classpath:/config/</li>
<li>classpath:/</li>
</ol>
<blockquote>
<p>file:/ 文件下路径为 pom.xml 同级路径</p>
<p>classpath:/ 类路径为 resources 文件夹下</p>
</blockquote>
<p>以上所有目录下的配置文件都会被加载，如果有相同的配置，优先级高的会覆盖优先级低的，也有可能形成互补配置。</p>
<h2 id="外部配置的加载顺序"><a href="#外部配置的加载顺序" class="headerlink" title="外部配置的加载顺序"></a>外部配置的加载顺序</h2><p>优先级仍然是从高到低：</p>
<ol>
<li>命令行参数</li>
<li>由jar包外向jar包内寻找，优先加载带spring.profile的配置文件<ul>
<li>jar包外，带profile</li>
<li>jar包内，带profile</li>
<li>jar包外，不带profile</li>
<li>jar包内，不带profile</li>
</ul>
</li>
</ol>
<h2 id="日志框架"><a href="#日志框架" class="headerlink" title="日志框架"></a>日志框架</h2><p>springboot内部的使用的日志框架：</p>
<ul>
<li>日志抽象层：SLF4J</li>
<li>日志实现：Logback</li>
</ul>
<p>​    SLF4J的使用：导入SLF4J的jar包，就可以使用了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.loggerfactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Logger logger = LoggerFactory.getLogger(HelloWorld<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        logger.info(<span class="string">"HelloWorld"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SpringBoot框架中使用日志框架"><a href="#SpringBoot框架中使用日志框架" class="headerlink" title="SpringBoot框架中使用日志框架"></a>SpringBoot框架中使用日志框架</h2><p>SpringBoot底层使用的是slf4j + logback进行日志记录，</p>
<p>如果我们要在SpringBoot中引入其他的框架时，首先就要把这个框架依赖的日志框架移除</p>
<h1 id="SpringBoot与web开发"><a href="#SpringBoot与web开发" class="headerlink" title="SpringBoot与web开发"></a>SpringBoot与web开发</h1><h2 id="一、SpringBoot对静态资源的映射规则"><a href="#一、SpringBoot对静态资源的映射规则" class="headerlink" title="一、SpringBoot对静态资源的映射规则"></a>一、SpringBoot对静态资源的映射规则</h2><ol>
<li><p>所有的webjars/** ，都去classpath:/META-INF/resources/webjars/ 找资源</p>
<p>webjars：以jar包的形式引入资源</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过在pom.xml中引入maven依赖的方式来引入静态资源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jquery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>/** 访问当前项目里的所有静态资源</p>
<ul>
<li>classpath:/META-INF/resources/</li>
<li>classpath:/resources/</li>
<li>classpath:/static/</li>
<li>classpath:/public/</li>
<li>/ ： ‘项目的根目录’</li>
</ul>
<p>以上文件夹为静态资源的文件夹，当使用 / 来访问项目中的资源时，如果资源没人处理，则会到上面文件夹中按先后顺序寻找**</p>
<p>classpath:/ –&gt; resources文件夹</p>
</li>
<li><p>欢迎页：静态资源文件夹下的 index.html 文件, 被 /** 映射</p>
</li>
<li><p>网页图标：在静态资源文件夹下找 favicon.ico</p>
</li>
</ol>
<blockquote>
<p>自己修改静态资源文件夹的位置：在springboot的配置文件中这样配置：spring.resources.static-locations=</p>
</blockquote>
<h2 id="二、模板引擎"><a href="#二、模板引擎" class="headerlink" title="二、模板引擎"></a>二、模板引擎</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p> jsp、Freemarker、thymeleaf</p>
<p> 模板引擎就是将页面和数据整合到一起的东西。</p>
<p> SpringBoot 推荐使用：thymeleaf</p>
<h3 id="引入thymeleaf"><a href="#引入thymeleaf" class="headerlink" title="引入thymeleaf"></a>引入thymeleaf</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修改thymeleaf版本以及thymeleaf-layout-dialect版本 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">thymeleaf.version</span>&gt;</span>3.0.11.RELEASE<span class="tag">&lt;/<span class="name">thymeleaf.version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">thymeleaf-layout-dialect.version</span>&gt;</span>2.4.1.RELEASE<span class="tag">&lt;/<span class="name">thymeleaf-layout-dialect.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="thymeleaf使用-amp-语法"><a href="#thymeleaf使用-amp-语法" class="headerlink" title="thymeleaf使用&amp;语法"></a>thymeleaf使用&amp;语法</h3><p>thymeleaf的使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset DEFAULT_ENCODING = StandardCharsets.UTF_8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_PREFIX = <span class="string">"classpath:/templates/"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_SUFFIX = <span class="string">".html"</span>;</span><br><span class="line"><span class="comment">// 只要在classpath:/templates/ 路径下的.html 文件，thymeleaf就能自动渲染</span></span><br></pre></td></tr></table></figure>

<p>thymeleaf的语法：</p>
<ul>
<li><p>要想使用thymeleaf的提示功能，需要在页面的HTML文件中引入thymeleaf的xmlns<br><code>&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</code></p>
</li>
<li><p>语法：th:**</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用th:text来获取controller中的文本内容，这里获取到的文本会覆盖div里面原本的文本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:text</span>=<span class="string">"$&#123;hello&#125;"</span>&gt;</span>这是一个div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>idea配置</title>
    <url>/2019/10/08/Java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/idea%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>新安装的idea在使用前需要进行的配置</p>
<a id="more"></a>

<h2 id="新建项目时idea如何配置"><a href="#新建项目时idea如何配置" class="headerlink" title="新建项目时idea如何配置"></a>新建项目时idea如何配置</h2><ol>
<li>每次新建一个project，都要设置<strong>maven仓库</strong>&amp;设置<strong>jdk</strong></li>
</ol>
<h2 id="如何新建项目"><a href="#如何新建项目" class="headerlink" title="如何新建项目"></a>如何新建项目</h2><ol>
<li>直接创建项目</li>
<li>从 git （或者其他版本控制工具）上面获取项目</li>
</ol>
<h2 id="往git上提交哪些内容？"><a href="#往git上提交哪些内容？" class="headerlink" title="往git上提交哪些内容？"></a>往git上提交哪些内容？</h2><ul>
<li>pom.xml</li>
<li>src下面的内容</li>
</ul>
<blockquote>
<p>绝对不能提交 .idea 这些带点的配置文件\</p>
</blockquote>
<h2 id="idea-展开-折叠-目录快捷键"><a href="#idea-展开-折叠-目录快捷键" class="headerlink" title="idea 展开/折叠 目录快捷键:"></a>idea 展开/折叠 目录快捷键:</h2><p>右箭头展开 / 左箭头折叠</p>
]]></content>
      <categories>
        <category>其他技术</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>谷粒商城</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令</title>
    <url>/2019/08/08/linux%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>linux的一些命令, 记录便于查阅.</p>
<a id="more"></a>

<h1 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h1><p><strong>最常用命令：</strong></p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">英文</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ls</td>
<td align="center">list</td>
<td align="center">查看当前文件夹下的内容</td>
</tr>
<tr>
<td align="center">pwd</td>
<td align="center">print work directory</td>
<td align="center">查看当前所在文件夹</td>
</tr>
<tr>
<td align="center">cd 目录名</td>
<td align="center">change directory</td>
<td align="center">切换文件夹</td>
</tr>
<tr>
<td align="center">touch 文件名</td>
<td align="center">touch</td>
<td align="center">如果文件不存在，创建文件</td>
</tr>
<tr>
<td align="center">mkdir 文件夹名</td>
<td align="center">make directory</td>
<td align="center">创建文件夹</td>
</tr>
<tr>
<td align="center">rm 文件名</td>
<td align="center">remove</td>
<td align="center">删除文件</td>
</tr>
<tr>
<td align="center">clear</td>
<td align="center">clear</td>
<td align="center">清屏</td>
</tr>
</tbody></table>
<blockquote>
<p>Linux中命令的格式：command [-options] [parameter]</p>
<ul>
<li><p>commond  命令名</p>
</li>
<li><p>[-options]  选项，对命令进行控制，可省略</p>
</li>
<li><p>[parameter]  参数，可以多个，可以省略</p>
<p>例如：删除文件夹：rm -r 文件夹名</p>
</li>
</ul>
</blockquote>
<hr>
<p><strong>查询命令的帮助信息：</strong></p>
<p><code>command --help</code> –&gt; 显示命令的<strong>帮助信息</strong></p>
<p><code>man command</code> –&gt; 显示命令的<strong>使用手册</strong></p>
<hr>
<p><strong>自动补全和命令选择：</strong></p>
<ul>
<li>自动补全：tab键，如果结果不唯一，按两下tab键会出现提示</li>
<li>命令选择：上下键，如果不想执行当前选中的命令，按<code>ctrl+c</code></li>
</ul>
<p><strong>隐藏文件和返回上一级：</strong></p>
<p>在Linux中，以<code>.</code>开头的文件为隐藏文件</p>
<p><code>cd ..</code>  返回上一级目录</p>
<p><strong>ls命令常用选项：</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>显示隐藏文件</td>
</tr>
<tr>
<td>-l</td>
<td>以列表的形式显示文件的详细信息</td>
</tr>
<tr>
<td>-h</td>
<td>配合 -l 以通用方式显示文件大小</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>其他技术</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>笔记</title>
    <url>/2019/08/02/%E5%85%B6%E5%AE%83%E7%AC%94%E8%AE%B0/%E8%BF%90%E5%8A%A8%E4%B8%8E%E5%81%A5%E5%BA%B7_%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>mooc 运动与健康 课堂笔记</p>
<a id="more"></a>
<h1 id="运动与健康"><a href="#运动与健康" class="headerlink" title="运动与健康"></a>运动与健康</h1><p><strong>影响人类健康的三大问题：</strong></p>
<ul>
<li>肥胖</li>
<li>缺乏运动导致的文明病</li>
<li>危险与紧张带来的心理病</li>
</ul>
<p><strong>肥胖的危害：</strong></p>
<p>血脂异常、增加脑血管病变、增加患高血压的概率、增加心脏负荷、增加糖尿病风险、易患癌症</p>
<p><strong>判断肥胖的方法：</strong></p>
<ol>
<li><p>BMI = w(体重_kg) / h<sup>2</sup>(身高_m)</p>
</li>
<li><p>腰围（可以测出脂肪在体内的大致分布）</p>
<ul>
<li>世界卫生组织：男 &lt; 95cm，女 &lt; 80cm</li>
<li>中国：男 &lt; 85cm，女 &lt; 80cm</li>
</ul>
</li>
<li><p>腰臀比：男 &lt; 0.95，女 &lt; 0.85    向心性肥胖</p>
</li>
<li><p>标准体重_kg = 身高_cm - 105</p>
</li>
</ol>
<blockquote>
<p>肥胖是仅次于吸烟和艾滋病的第三大慢性杀手</p>
<p>运动是减少脂肪最经济有效的方法</p>
</blockquote>
<hr>
<p><strong>判断心理健康的四个标准：</strong></p>
<ol>
<li>心理标准</li>
<li>心理测验标准</li>
<li>统计标准</li>
<li>社会适应标准</li>
</ol>
<p><strong>运动的好处：</strong></p>
<ul>
<li>健康幸福感</li>
<li>对抑郁有治疗作用</li>
<li>产生良好的情绪体验</li>
<li>对意志品质有促进作用</li>
<li>使认知能力提高</li>
</ul>
<blockquote>
<p>生命在于科学运动</p>
</blockquote>
<p><strong>科学运动的关键：</strong></p>
<ul>
<li>确定运动项目</li>
<li>设定运动量与运动强度</li>
<li>把握运动时间</li>
</ul>
<p><strong>有氧运动和无氧运动：</strong></p>
<ul>
<li>有氧运动：中低强度、时间长、不间断、有节奏（走、慢跑、游泳、健身操）</li>
<li>无氧运动：强度高、时间短、疲劳难以消除（短跑、举重、拳击）</li>
</ul>
<p><strong>靶心率</strong> =（220-年龄）*65%(下限) 或 85%(上限)</p>
<p><strong>运动量</strong> = 运动强度 * 运动时间</p>
<blockquote>
<p><strong>每周4~5次</strong>运动最为合适（贵在持之以恒）</p>
</blockquote>
<blockquote>
<p>在<strong>餐后30分钟~1小时</strong>运动最为合适</p>
</blockquote>
<blockquote>
<p><strong>晚上6~8点</strong>运动合适</p>
</blockquote>
]]></content>
      <tags>
        <tag>运动与健康</tag>
        <tag>课堂笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>新电脑开发环境搭建</title>
    <url>/2019/07/06/%E5%85%B6%E5%AE%83%E7%AC%94%E8%AE%B0/%E6%96%B0%E7%94%B5%E8%84%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>从头开始搭建自己的开发环境</p>
<a id="more"></a>
<h1 id="新电脑开发环境搭建"><a href="#新电脑开发环境搭建" class="headerlink" title="新电脑开发环境搭建"></a>新电脑开发环境搭建</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>作为一名数码爱好者，以及一名准Java程序员，之前一直是用自己大一的时候买的一台笔记本来做Java程序的编写，那台笔记本在使用两年之后卡的不行不行的，在把内存从4G加到8G，机械硬盘换成固态后，又焕发了第二春。一直使用到现在。得益于固态硬盘的加持，日常轻度办公影音是没有问题，但是受限于i5-4200U这颗远古时代的处理器，启动个Tomcat服务器都需要20秒的时间，实在忍受不了，故心心念一台台式机，谋划良久，终于行动。</p>
</blockquote>
<p><strong>台式机配置清单：</strong></p>
<ul>
<li>CPU：AMD R5-2400G （AMD YES）</li>
<li>内存：金士顿 骇客神条 DDR4 2400 8G*2</li>
<li>主板：B350M BAZOOKA</li>
<li>固态：三星 970 EVO 250G M.2</li>
<li>机械硬盘：西数蓝盘 2T</li>
<li>电源：安钛克 VP300P </li>
<li>机箱：航嘉 暗夜猎手3 （这个机箱是真的烂，要不是穷，肯定不会买它）</li>
<li>显示器：戴尔 U2518DR（这个显示器是真的好）</li>
</ul>
<p><strong>基础软件清单：</strong></p>
<ul>
<li>系统：win10 专业版 1903 （收费）</li>
<li>IDE：IDEA 2019.1.3 （收费）</li>
<li>JDK：1.8.0_212</li>
<li>数据库：MySQL 5.5 （5.5版本仍然是免费的，学习使用足够了）</li>
<li>数据库开发工具：Navicat Premium 12 （收费）</li>
<li>服务器：Tomcat 9.0.21</li>
<li>代码管理：git</li>
<li>项目管理：Maven  3.6.1</li>
<li>博客框架：Hexo</li>
<li>Markdown编辑器：Typora</li>
<li>浏览器：FireFox</li>
<li>文本编辑器：Notepad++</li>
</ul>
<p><strong>软件安装流程：</strong></p>
<ol>
<li><p>系统：下载地址：<a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">MSDN</a> </p>
<p>激活：我用的KMS</p>
</li>
<li><p>IDE：下载地址：<a href="https://www.jetbrains.com/idea/download/#section=windows" target="_blank" rel="noopener">官网下载</a></p>
<p>激活：google，<em>希望有能力的同学还是支持正版</em></p>
</li>
<li><p>JDK：下载地址：<a href="https://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">Oracle官网下载</a> 下载 jdk 送 jre</p>
</li>
<li><p>Navicat：下载地址：<a href="https://www.navicat.com.cn/products" target="_blank" rel="noopener">官网下载</a></p>
<p>破解：<a href="https://www.jianshu.com/p/5f693b4c9468/" target="_blank" rel="noopener">我参考的一篇文章</a></p>
</li>
<li><p>git：<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">官网下载</a>，<a href="https://github.com/waylau/git-for-win" target="_blank" rel="noopener">国内代理服务器下载</a></p>
</li>
<li><p>Hexo：hexo安装可参考<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">官网文档</a></p>
<p>一点注意事项：使用npm安装时速度比较慢，修改一下安装源即可：命令：npm config set registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>数码</tag>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat日志打印乱码问题解决</title>
    <url>/2019/07/06/%E5%85%B6%E5%AE%83%E7%AC%94%E8%AE%B0/Tomcat%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>解决tomcat在idea中日志中文乱码的问题</p>
<a id="more"></a>
<h1 id="Tomcat日志打印乱码问题解决"><a href="#Tomcat日志打印乱码问题解决" class="headerlink" title="Tomcat日志打印乱码问题解决"></a>Tomcat日志打印乱码问题解决</h1><p><em>idea版本：2019.1.3</em></p>
<p><em>Tomcat版本：9.0.21</em></p>
<p>出现 <strong>“淇℃伅”</strong> 乱码情况：</p>
<p>tomcat安装目录 –&gt; conf文件夹 –&gt; logging.properties，找到 java.util.logging.ConsoleHandler.encoding = UTF-8 <strong>更改为</strong> java.util.logging.ConsoleHandler.encoding = GBK</p>
<p><em>已设置</em> idea Settings –&gt; Editor –&gt; File Encodings 中：</p>
<ul>
<li>Global Encoding : UTF-8</li>
<li>Project Encoding : UTF-8</li>
<li>Default encoding for properties files : UTF-8</li>
</ul>
<p><em>未设置</em> Tomcat中 VM options，</p>
<p><em>未修改</em> idea.exe.vmoptions 和 idea64.exe.vmoptions 文件</p>
]]></content>
      <tags>
        <tag>Tomcat</tag>
        <tag>乱码</tag>
      </tags>
  </entry>
  <entry>
    <title>容器</title>
    <url>/2019/06/18/Java/1.Java%E5%9F%BA%E7%A1%80/%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<p>Java容器一定要好好学习</p>
<a id="more"></a>

<h2 id="Collection、List、ArrayList"><a href="#Collection、List、ArrayList" class="headerlink" title="Collection、List、ArrayList"></a>Collection、List、ArrayList</h2><h3 id="Collection接口的一些常见方法"><a href="#Collection接口的一些常见方法" class="headerlink" title="Collection接口的一些常见方法"></a>Collection接口的一些常见方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Colection&lt;String&gt; c = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">c.add(<span class="string">"AA"</span>);</span><br><span class="line">c.add(<span class="string">"BB"</span>);</span><br><span class="line">c.add(<span class="string">"CC"</span>);</span><br><span class="line"></span><br><span class="line">c.size();</span><br><span class="line">c.isEmpty();</span><br><span class="line">c.remove(<span class="string">"BB"</span>);</span><br><span class="line">c.clear();</span><br></pre></td></tr></table></figure>

<h3 id="Collection接口中的一些与集合相关的方法"><a href="#Collection接口中的一些与集合相关的方法" class="headerlink" title="Collection接口中的一些与集合相关的方法"></a>Collection接口中的一些与集合相关的方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Colection&lt;String&gt; c1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">Colection&lt;String&gt; c2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">c1.add(<span class="string">"zz"</span>);</span><br><span class="line">c1.add(<span class="string">"ff"</span>);</span><br><span class="line">c1.add(<span class="string">"xx"</span>);</span><br><span class="line">	</span><br><span class="line">c2.add(<span class="string">"zz"</span>);</span><br><span class="line">c2.add(<span class="string">"hh"</span>);</span><br><span class="line">c2.add(<span class="string">"ll"</span>);</span><br><span class="line">		</span><br><span class="line">c1.addAll(c2); <span class="comment">// 将c2中的所有元素添加到c1中</span></span><br><span class="line">c1.removeAll(c2); <span class="comment">// 将c1中和c2相同的元素删除</span></span><br><span class="line">c1.retainAll(c2); <span class="comment">// 将c1中和c2相同的元素保留</span></span><br><span class="line">	</span><br><span class="line">c1.containsAll(c2); <span class="comment">// 判断c1是否包含了c2的全部元素，返回boolean</span></span><br></pre></td></tr></table></figure>

<h3 id="List接口中一些与索引有关的方法"><a href="#List接口中一些与索引有关的方法" class="headerlink" title="List接口中一些与索引有关的方法"></a>List接口中一些与索引有关的方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">"A"</span>);</span><br><span class="line">list.add(<span class="string">"B"</span>);</span><br><span class="line">list.add(<span class="string">"C"</span>);</span><br><span class="line"></span><br><span class="line">list.add(<span class="number">2</span>,<span class="string">"H"</span>);</span><br><span class="line">list.remove(<span class="number">0</span>);</span><br><span class="line">list.set(<span class="number">1</span>,<span class="string">"S"</span>);</span><br><span class="line">list.get(<span class="number">1</span>);</span><br><span class="line">list.indexOf(<span class="string">"C"</span>);</span><br></pre></td></tr></table></figure>



<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>LinkedList底层用双向链表实现储存<br>特点：查询效率低，增删效率高，线程不安全</p>
<p>自己尝试实现LinkedList，详见代码</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>Map使用“键（key）-值（value）对”来储存信息。<br>键值对信息通过键来标识，键不可重复。<br>HashMap实现类实现了Map接口。</p>
<p>HashMap底层存储方式为<em>数组+链表</em>，<br>特点：查询效率高，增删效率高，线程不安全</p>
<p>自己尝试实现HashMap，详见代码</p>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>TreeMap是<em>红黑二叉树</em>的典型实现<br>TreeMap和HashMap实现了同样的接口Map<br><strong>在需要排序的Map时才选用TreeMap</strong><br>按照<strong>Key递增</strong>的方向进行定义</p>
<blockquote>
<p>如果Key是自己定义的类，那么这个类必须实现Comparable接口，从而实现排序</p>
</blockquote>
<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p>HashTable 同样是Map的一个实现类。<br>HashTab 和 HashMap用法几乎一样，区别在于</p>
<ul>
<li>HashMap 效率高，线程不安全，允许key和value为null</li>
<li>HashTable 效率低，线程安全（方法中添加了<strong>synchronized</strong>关键字确保线程同步检查），不允许key和value为null</li>
</ul>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>Set容器的特点：其中元素 <strong>无序</strong> &amp; <strong>不可重复</strong><br><strong>HashSet底层采用HashMap实现</strong><br>Set中所有的元素在Map中作为key</p>
<p>手工实现HashSet：详见代码</p>
<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p><strong>TreeSet底层采用TreeMap实现</strong><br>TreeSet会按照元素递增的方式实现排序</p>
<blockquote>
<p>如果TreeSet中是自己定义的类，那么这个类必须实现Comparable接口，从而实现排序</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面试</title>
    <url>/2019/06/05/Java/Java%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<p>Java面试题目整理</p>
<a id="more"></a>

<h1 id="面试题目整理"><a href="#面试题目整理" class="headerlink" title="面试题目整理"></a>面试题目整理</h1><ol>
<li><p>Java中的<strong>基本数据类型</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">四类八种：</span><br><span class="line"></span><br><span class="line">整数型</span><br><span class="line">byte(1字节)，short(2字节)，int(4字节)，long(8字节)</span><br><span class="line">浮点型</span><br><span class="line">float(4字节)，double(8字节)</span><br><span class="line">字符型</span><br><span class="line">char(1字节)</span><br><span class="line">布尔型</span><br><span class="line">boolean(无大小)</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>用什么数据类型存储金额</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用 BigDecimal,不会损失精度</span></span><br><span class="line">BigDecimal price1 = <span class="keyword">new</span> BigDecimal(<span class="string">"0.3"</span>);</span><br><span class="line">BigDecimal price2 = <span class="keyword">new</span> BigDecimal(<span class="string">"0.2"</span>);</span><br><span class="line"></span><br><span class="line">price1.subtract(price2);</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>WEB-INF 目录的作用</p>
<p><strong>基于Servlet的声明，WEB-INF 不作为web应用的公共文档树的一部分。</strong></p>
<p>因此，WEB-INF 目录下的资源不是为客户直接服务的，</p>
<p>所以，要想访问WEB-INF 目录下的资源，必须<strong>走控制器</strong></p>
<p>WEB-INF 目录下的资源相对来说是<strong>安全的</strong></p>
</li>
</ol>
<ol start="4">
<li><p>Servlet的执行流程</p>
<p>Servlet是<strong>单实例、多线程</strong></p>
<p>第一次访问时，服务器创建Servlet， 并调用 init 方法进行初始化，然后调用service方法</p>
<p>每当请求来到的时候，服务器创建一个线程，并调用service方法完成自己的业务逻辑</p>
<p>当Servlet被移除或服务器正常关闭时，服务器调用Servlet的 destory 方法执行收尾操作</p>
</li>
</ol>
<ol start="5">
<li><p>@Autowired 注解的使用</p>
<p>默认按照类型去容器中查找，</p>
<p>如果找到多个相同类型的组件，再将<strong>属性名</strong>作为<strong>组件的 id</strong> 去容器中查找</p>
</li>
</ol>
<ol start="6">
<li><p>JDK 和 JRE 的区别</p>
<p>JRE = JVM + Java核心类库</p>
<p>JDK = JRE + Java开发工具（JDK 11 及之后的版本中不再包括 JRE）</p>
</li>
</ol>
<ol start="7">
<li><p>final 关键字的作用</p>
<p>修饰类：类不能被继承</p>
<p>修饰成员方法：方法不能被重写</p>
<p>修饰成员变量：变量的值不能修改</p>
</li>
</ol>
<ol start="8">
<li>== 和 equals 的区别</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
      </tags>
  </entry>
  <entry>
    <title>AJAX</title>
    <url>/2019/05/30/Java/2.JavaWeb/AJAX&amp;JSON/</url>
    <content><![CDATA[<p>AJAX：Asynchronous JavaScript and XML <code>异步的 JavaScript和XML</code></p>
<a id="more"></a>

<h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><p>AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术</p>
<blockquote>
<p>浏览器和服务器通信中的<strong>同步和异步</strong>：</p>
<ul>
<li>同步：浏览器发出请求后必须等待服务器的响应，在等待期间不能做任何操作</li>
<li>异步： 浏览器不需要等待服务器的响应，在等待期间可以进行其他操作</li>
</ul>
</blockquote>
<p>AJAX 不是新的语言, 而是一种基于现有Internet标准的新方法, 并联合使用它们:</p>
<ul>
<li>XMLHttpRequest 对象(异步与服务器交换数据, 该对象为浏览器内置)</li>
<li>JavaScript / DOM</li>
<li>CSS</li>
<li>XML</li>
</ul>
<h3 id="使用-jQuery-实现AJAX"><a href="#使用-jQuery-实现AJAX" class="headerlink" title="使用 jQuery 实现AJAX"></a>使用 jQuery 实现AJAX</h3><ol>
<li>基础语法：<code>$.ajax({name:value, name:value, ...});</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url:<span class="string">"请求路径"</span>,</span><br><span class="line">    type:<span class="string">"POST"</span>, <span class="comment">// 请求方式，默认为GET</span></span><br><span class="line">    data:&#123;<span class="string">"username"</span>:<span class="string">"tom"</span>,<span class="string">"age"</span>:<span class="number">23</span>&#125;, <span class="comment">// 请求参数</span></span><br><span class="line">    success:<span class="function"><span class="keyword">function</span> (<span class="params">a</span>)</span>&#123; <span class="comment">// 响应成功后执行的回调函数，a 表示服务器响应的数据</span></span><br><span class="line">        alert(a);</span><br><span class="line">    &#125;,</span><br><span class="line">    error:<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"出错了"</span>); <span class="comment">// 请求响应出错时执行的回调函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<ol start="2">
<li><p><code>$.get()</code></p>
<p>语法：<code>$.get(url, [data], [callback], [type]);</code></p>
<ul>
<li>url：请求路径</li>
<li>data：请求参数</li>
<li>callback：回调函数</li>
<li>type：响应数据类型</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p><code>$.post()</code></p>
<p>语法：<code>$.get(url, [data], [callback], [type]);</code></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery高级</title>
    <url>/2019/05/30/Java/2.JavaWeb/jQuery-%E9%AB%98%E7%BA%A7/</url>
    <content><![CDATA[<p>jQuery</p>
<a id="more"></a>

<h1 id="jQuery高级"><a href="#jQuery高级" class="headerlink" title="jQuery高级"></a>jQuery高级</h1><h2 id="一-动画"><a href="#一-动画" class="headerlink" title="一. 动画"></a>一. 动画</h2><p>三种显示和隐藏元素的动画效果</p>
<ol>
<li><p><strong>默认</strong>效果    </p>
<ol>
<li><p>show([speed,[easing],[fn]])</p>
<pre><code>- speed：动画的速度。三个预定义的值(**&quot;slow&quot;,&quot;normal&quot;, &quot;fast&quot;**)或表示动画时长的毫秒数值(如：1000)</code></pre><ul>
<li>easing：用来指定切换动画效果，默认是”swing”，可用参数”linear”<ul>
<li>swing：非线性动画</li>
<li>linear：线性动画</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>fn：在动画完成时执行的函数，每个元素执行一次。</li>
</ul>
<ol start="2">
<li>hide([speed,[easing],[fn]])</li>
<li>toggle([speed],[easing],[fn])</li>
</ol>
</li>
<li><p><strong>滑动</strong>效果</p>
<ol>
<li>显示：slideDown([speed],[easing],[fn])</li>
<li>隐藏：slideUp([speed,[easing],[fn]])</li>
<li>切换：slideToggle([speed],[easing],[fn])</li>
</ol>
</li>
<li><p><strong>淡入淡出</strong>效果</p>
<ol>
<li>显示：fadeIn([speed],[easing],[fn])</li>
<li>隐藏：fadeOut([speed],[easing],[fn])</li>
<li>切换：fadeToggle([speed,[easing],[fn]])</li>
</ol>
</li>
</ol>
<h2 id="二-遍历"><a href="#二-遍历" class="headerlink" title="二. 遍历"></a>二. 遍历</h2><ol>
<li><p>js的遍历方式</p>
<pre><code>`for(初始化值;循环结束条件;步长)`</code></pre></li>
<li><p>jq的遍历方式</p>
<p>  <code>jq对象.each(callback)</code></p>
<ol start="3">
<li><p>语法：</p>
<p><code>jquery对象.each(function(index,element){});</code></p>
<ul>
<li>index:就是元素在集合中的索引</li>
<li>element：就是集合中的每一个元素对象</li>
<li>this：集合中的每一个元素对象</li>
</ul>
<ol start="2">
<li>回调函数返回值：</li>
</ol>
</li>
</ol>
<ul>
<li>true：如果当前function返回为false，则结束循环(break)。</li>
<li>false：如果当前function返回为true，则结束本次循环，继续下次循环(continue)</li>
</ul>
<ol start="2">
<li><p><code>$.each(object（可js，可jq）, [callback])</code></p>
</li>
<li><p><code>for .. of</code>: jquery 3.0 版本之后提供的方式</p>
<p><code>for(元素对象 of 容器对象)</code></p>
</li>
</ol>
</li>
</ol>
<h2 id="三-事件绑定"><a href="#三-事件绑定" class="headerlink" title="三. 事件绑定"></a>三. 事件绑定</h2><ol>
<li><p>jquery标准的绑定方式</p>
<pre><code>* `jq对象.事件方法(回调函数);`
* 注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。
    * 表单对象.submit();//让表单提交</code></pre></li>
<li><p>on绑定事件/off解除绑定</p>
<ul>
<li><code>jq对象.on(&quot;事件名称&quot;,回调函数)</code></li>
<li><code>jq对象.off(&quot;事件名称&quot;)</code><ul>
<li>如果off方法不传递任何参数，则将组件上的所有事件全部解绑</li>
</ul>
</li>
</ul>
</li>
<li><p>事件切换：toggle</p>
<ul>
<li><p><code>jq对象.toggle(fn1,fn2...)</code></p>
<ul>
<li>当单击jq对象对应的组件后，会执行fn1.第二次点击会执行fn2…..</li>
</ul>
</li>
<li><p>注意：1.9版本 .toggle() 方法删除,jQuery Migrate（迁移）插件可以恢复此功能。</p>
</li>
</ul>
</li>
</ol>
<h2 id="四-插件"><a href="#四-插件" class="headerlink" title="四. 插件"></a>四. 插件</h2><p>增强JQuery的功能<br>        1. $.fn.extend(object)<br>      * 增强通过Jquery获取的对象的功能  $(“#id”)<br>2. $.extend(object)</p>
<ul>
<li>增强JQeury对象自身的功能  $/jQuery</li>
</ul>
]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery基础</title>
    <url>/2019/05/28/Java/2.JavaWeb/jQuery-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>jQuery的选择器 &amp; DOM操作</p>
<a id="more"></a>

<h1 id="jQuery基础"><a href="#jQuery基础" class="headerlink" title="jQuery基础"></a>jQuery基础</h1><p>概念：jQuery是JavaScript的一个框架，可以简化js代码的书写</p>
<h2 id="jQuery对象和js对象的区别和转换"><a href="#jQuery对象和js对象的区别和转换" class="headerlink" title="jQuery对象和js对象的区别和转换"></a>jQuery对象和js对象的区别和转换</h2><ol>
<li><p>jQuery对象在操作时，更加方便</p>
</li>
<li><p>jQuery对象和js对象方法不通用</p>
</li>
<li><p>jQuery对象和js对象的相互转换</p>
<ol>
<li>jQuery –&gt; js ：<code>jQuery对象[索引]</code>  /  <code>jQuery对象.get(索引)</code></li>
<li>js –&gt; jQuery ：<code>$(js对象)</code></li>
</ol>
</li>
</ol>
<h2 id="jQuery的选择器"><a href="#jQuery的选择器" class="headerlink" title="jQuery的选择器"></a>jQuery的选择器</h2><blockquote>
<ol>
<li>事件绑定<ol>
<li>规则：<code>$(&quot;#div1&quot;).click(function(){ alert(123) });</code></li>
</ol>
</li>
<li>入口函数<ol>
<li>规则：<code>$(function(){ 代码 });</code></li>
<li>与js 中<code>window.onload</code>的区别<ol>
<li><code>window.onload</code> 只能定义一次，如果定义多次，后面的会把前面的覆盖掉</li>
<li><code>$(function(){ 代码 });</code> 可以定义多次，</li>
</ol>
</li>
</ol>
</li>
<li>样式控制<ol>
<li><code>$(&quot;#div1&quot;).css(&quot;background-color&quot;, &quot;pink&quot;);</code></li>
<li><code>$(&quot;#div1&quot;).css(&quot;backgroundColor&quot;, &quot;pink&quot;);</code>：<em>推荐使用</em></li>
</ol>
</li>
</ol>
</blockquote>
<ol>
<li><p>基本选择器</p>
<pre><code>1. 标签选择器（元素选择器）
    * 语法：`$(&quot;标签&quot;)` 获得所有匹配标签名称的元素</code></pre><ol start="2">
<li>id选择器 <ul>
<li>语法：<code>$(&quot;#id&quot;)</code>获得与指定id属性值匹配的元素</li>
</ul>
</li>
<li>类选择器<ul>
<li>语法：<code>$(&quot;.class属性的值&quot;)</code>获得与指定的class属性值匹配的元素</li>
</ul>
</li>
<li>并集选择器：<ul>
<li>语法：<code>$(&quot;选择器1,选择器2....&quot;)</code> 获取多个选择器选中的所有元素</li>
</ul>
</li>
</ol>
</li>
<li><p>层级选择器</p>
<pre><code>1. 后代选择器
    * 语法：`$(&quot;A B&quot;)` 选择A元素内部的所有B元素        </code></pre><ol start="2">
<li>子选择器<ul>
<li>语法：<code>$(&quot;A &gt; B&quot;)</code> 选择A元素内部的所有B<strong>子元素</strong></li>
</ul>
</li>
</ol>
</li>
<li><p>属性选择器</p>
<pre><code>1. 属性名称选择器 
    * 语法：`$(&quot;A[属性名]&quot;)` 包含指定属性的选择器</code></pre><ol start="2">
<li>属性选择器<ul>
<li>语法：<code>$(&quot;A[属性名=&#39;值&#39;]&quot;)</code> 包含指定属性等于指定值的选择器</li>
<li><code>$(&quot;A[属性名!=&#39;值&#39;]&quot;)</code> ：属性不等于某些值，以及不包括该属性</li>
<li><code>$(&quot;A[属性名^=&#39;值&#39;]&quot;)</code> ：属性的值以 ** 开头</li>
<li><code>$(&quot;A[属性名$=&#39;值&#39;]&quot;)</code>：属性的值以 ** 结束</li>
<li><code>$(&quot;A[属性名*=&#39;值&#39;]&quot;)</code>  ：属性的值含有 **</li>
</ul>
</li>
<li>复合属性选择器<ul>
<li>语法：<code>$(&quot;A[属性名=&#39;值&#39;][]...&quot;)</code> 包含多个属性条件的选择器</li>
</ul>
</li>
</ol>
</li>
<li><p>过滤选择器</p>
<pre><code>1. 首元素选择器 
    * 语法： `$(&quot;A:first&quot;)`  获得选择的元素中的第一个元素</code></pre><ol start="2">
<li>尾元素选择器 <ul>
<li>语法： <code>$(&quot;A:last&quot;)</code>  获得选择的元素中的最后一个元素</li>
</ul>
</li>
<li>非元素选择器<ul>
<li>语法： <code>$(&quot;A:not(content)&quot;)</code> 不包括指定内容的元素</li>
<li>content：选择器表达式</li>
</ul>
</li>
<li>偶数选择器<ul>
<li>语法： <code>$(&quot;A:even&quot;)</code> 偶数，从 0 开始计数</li>
</ul>
</li>
<li>奇数选择器<ul>
<li>语法： <code>$(&quot;A:odd&quot;)</code> 奇数，从 0 开始计数</li>
</ul>
</li>
<li>等于索引选择器<ul>
<li>语法： <code>$(&quot;A:eq(index)&quot;)</code> 指定索引元素</li>
</ul>
</li>
<li>大于索引选择器 <ul>
<li>语法： <code>$(&quot;A:gt(index)&quot;)</code> 大于指定索引元素</li>
</ul>
</li>
<li>小于索引选择器 <ul>
<li>语法： <code>$(&quot;A:lt(index)&quot;)</code> 小于指定索引元素</li>
</ul>
</li>
<li>标题选择器<ul>
<li>语法： <code>$(&quot;:header&quot;)</code> 获得标题（h1~h6）元素，固定写法</li>
</ul>
</li>
</ol>
</li>
<li><p>表单过滤选择器</p>
<ol>
<li>可用元素选择器 <pre><code>* 语法： `:enabled`获得可用元素</code></pre></li>
<li>不可用元素选择器 <ul>
<li>语法：<code>:disabled</code> 获得不可用元素</li>
</ul>
</li>
<li>选中选择器 <ul>
<li>语法：<code>:checked</code> 获得<strong>单选/复选框</strong>选中的元素</li>
</ul>
</li>
<li>选中选择器 <ul>
<li>语法：<code>:selected</code> 获得<strong>下拉框</strong>选中的元素</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h2><h3 id="内容操作"><a href="#内容操作" class="headerlink" title="内容操作"></a>内容操作</h3><ol>
<li><code>html()</code> –&gt; 获取/设置元素的标签体内容</li>
<li><code>text()</code> –&gt; 获取元素的标签体纯文本内容，设置元素的标签体内容</li>
<li><code>val()</code> –&gt; 获取/设置元素的value属性值</li>
</ol>
<h3 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h3><ol>
<li><p>通用属性操作</p>
<ol>
<li>attr() –&gt;  获取/设置<strong>自定义元素</strong>的属性</li>
<li>removeAttr() –&gt; 删除属性</li>
<li>prop() –&gt; 获取/设置<strong>固有元素</strong>的属性</li>
<li>removeProp() –&gt; 删除属性</li>
</ol>
</li>
<li><p>对class属性的操作</p>
<ol>
<li>addClass() –&gt; 添加class属性的值</li>
<li>removeClass() –&gt; 删除class属性的值</li>
<li>toggleClass() –&gt; 切换class属性</li>
</ol>
</li>
</ol>
<h3 id="CRUD操作"><a href="#CRUD操作" class="headerlink" title="CRUD操作"></a>CRUD操作</h3><ol>
<li>append():父元素将子元素追加到末尾<pre><code>* 对象1.append(对象2): 将对象2添加到对象1元素内部，并且在末尾</code></pre></li>
<li>prepend():父元素将子元素追加到开头<ul>
<li>对象1.prepend(对象2):将对象2添加到对象1元素内部，并且在开头</li>
</ul>
</li>
<li>appendTo():<ul>
<li>对象1.appendTo(对象2):将对象1添加到对象2内部，并且在末尾</li>
</ul>
</li>
<li>prependTo()：<ul>
<li>对象1.prependTo(对象2):将对象1添加到对象2内部，并且在开头</li>
</ul>
</li>
</ol>
<hr>
<ol start="5">
<li><p>after():添加元素到元素后边</p>
<pre><code>* 对象1.after(对象2)： 将对象2添加到对象1后边。对象1和对象2是兄弟关系</code></pre></li>
<li><p>before():添加元素到元素前边</p>
<ul>
<li>对象1.before(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系</li>
</ul>
</li>
<li><p>insertAfter()</p>
<ul>
<li>对象1.insertAfter(对象2)：将对象1添加到对象2后边。对象1和对象2是兄弟关系</li>
</ul>
</li>
<li><p>insertBefore()</p>
<ul>
<li>对象1.insertBefore(对象2)： 将对象1添加到对象2前边。对象1和对象2是兄弟关系</li>
</ul>
</li>
</ol>
<hr>
<ol start="9">
<li><p>remove():移除元素</p>
<ul>
<li>对象.remove():将对象删除掉</li>
</ul>
</li>
<li><p>empty():清空元素的所有后代元素。</p>
<ul>
<li>对象.empty():将对象的后代元素全部清空，但是保留当前对象以及其属性节点</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>EL &amp; JSTL</title>
    <url>/2019/05/26/Java/2.JavaWeb/12.EL%20&amp;%20JSTL/</url>
    <content><![CDATA[<p>EL : Expression Language : 替换和简化jsp页面中Java代码的编写</p>
<p>JSTL : Java Server pages Tag Library : jsp标签库</p>
<a id="more"></a>

<h1 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h1><p>概念：Expression Language  表达式语言</p>
<p>作用：替换和简化jsp页面中Java代码的编写</p>
<p>语法：<code>${表达式}</code></p>
<p>注意：在jsp页面中默认支持EL表达式，如果想忽略EL表达式，有两种方法</p>
<ul>
<li>在<code>page</code>指令中添加属性 <code>isElIgnored=&quot;true&quot;</code>，可以忽略当前页面中所有的EL表达式</li>
<li>在EL表达式前加<code>\</code> ,即 <code>\${表达式}</code>，可以忽略这个表达式</li>
</ul>
<h3 id="EL表达式的使用"><a href="#EL表达式的使用" class="headerlink" title="EL表达式的使用"></a>EL表达式的使用</h3><p><strong>1、运算符</strong></p>
<p>在EL表达式中可以直接进行运算，可以使用的运算符有以下几种：</p>
<ul>
<li>算术运算符：+ - * / %</li>
<li>比较运算符：&gt;  &lt;  &gt;=  &lt;=  == !=</li>
<li>逻辑运算符：&amp;&amp;  ||  !</li>
<li>空运算符：empty<ul>
<li>作用：用于判断字符串、集合、数组对象 <strong>是否为null</strong> 或者 <strong>长度是否为0</strong>，返回true或false</li>
<li>用法：<code>${empty list}</code> / <code>${not empty list}</code></li>
</ul>
</li>
</ul>
<hr>
<p><strong>2、获取值</strong></p>
<p>EL表达式只能从<strong>域对象</strong>中获取值</p>
<p>语法：</p>
<ul>
<li><p><code>${域名称.键名}</code>：从指定域中获取指定键的值</p>
<table>
<thead>
<tr>
<th align="center">域名称（从小到大）</th>
<th align="center">对象名</th>
</tr>
</thead>
<tbody><tr>
<td align="center">pageScope</td>
<td align="center">pageContext</td>
</tr>
<tr>
<td align="center">requestScope</td>
<td align="center">request</td>
</tr>
<tr>
<td align="center">sessionScope</td>
<td align="center">session</td>
</tr>
<tr>
<td align="center">applicationScope</td>
<td align="center">application</td>
</tr>
</tbody></table>
</li>
<li><p><code>${键名}</code>：从最小的域开始往大的域查找是否有该键，直到找到为止</p>
</li>
</ul>
<p>获取对象、List集合、Map集合中的值：</p>
<ul>
<li><p>获取对象的值：<code>${域名称.键名.属性名}</code></p>
<ul>
<li>这种获取方法本质上会去调用对象的getter方法，</li>
<li>属性名其实是getter方法名去掉getter后剩余部分首字母变小写，通常情况下就和成员变量名一样</li>
</ul>
</li>
<li><p>获取List集合中的值：<code>${域名称.键名[索引]}</code></p>
</li>
<li><p>获取Map集合中的值：</p>
<ul>
<li><code>${域名称.键名.key}</code></li>
<li><code>${域名称.键名[&quot;key&quot;]}</code></li>
</ul>
</li>
</ul>
<h3 id="隐式对象"><a href="#隐式对象" class="headerlink" title="隐式对象"></a>隐式对象</h3><p>EL表达式中共有11个隐式对象，类似于jsp的内置对象</p>
<ul>
<li>pageContext：最常用的隐式对象就这一个<ul>
<li>作用：获取jsp的其它8个内置对象</li>
<li>使用：<code>${pageContext.request.contextPath}</code>：动态获取虚拟目录 ☆</li>
</ul>
</li>
</ul>
<h1 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h1><p>概念：Java Server pages Tag Library ：jsp标签库</p>
<p>作用：用于简化和替换jsp页面上的Java代码</p>
<p>使用：在使用之前需要先引入标签库</p>
<ul>
<li><code>&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</code></li>
</ul>
<hr>
<h3 id="常用的-JSTL-标签"><a href="#常用的-JSTL-标签" class="headerlink" title="常用的 JSTL 标签"></a>常用的 JSTL 标签</h3><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><p>相当于Java代码的 <strong>if语句</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%-- test属性为必须的，当test中表达式为<span class="keyword">true</span>时，执行标签体中的代码 --%&gt;</span><br><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">"boolean表达式"</span>&gt;</span><br><span class="line">    &lt;h1&gt;jstl的if标签&lt;/h1&gt;</span><br><span class="line">&lt;/c:if&gt;</span><br></pre></td></tr></table></figure>



<h4 id="choose"><a href="#choose" class="headerlink" title="choose"></a>choose</h4><p>相当于Java代码的 <strong>switch语句</strong></p>
<ul>
<li>choose –&gt; switch</li>
<li>when –&gt; case</li>
<li>otherwise –&gt; default</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">	request.setAttribute(<span class="string">"number"</span>,<span class="number">3</span>);</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:choose&gt;</span><br><span class="line">	&lt;c:when test="$&#123;number == 1&#125;"&gt;星期一&lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test="$&#123;number == 2&#125;"&gt;星期二&lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test="$&#123;number == 3&#125;"&gt;星期三&lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test="$&#123;number == 4&#125;"&gt;星期四&lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test="$&#123;number == 5&#125;"&gt;星期五&lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test="$&#123;number == 6&#125;"&gt;星期六&lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test="$&#123;number == 7&#125;"&gt;星期七&lt;/c:when&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;c:otherwise&gt;数据输入有误&lt;/c:otherwise&gt;</span><br><span class="line">&lt;/c:choose&gt;</span><br></pre></td></tr></table></figure>



<h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><p>相当于Java代码的 <strong>for语句</strong></p>
<p>foreach 标签具有两个功能：</p>
<ul>
<li><p>完成重复的操作</p>
<ul>
<li>begin：开始值</li>
<li>end：结束值（也包括）</li>
<li>var：临时变量</li>
<li>step：步长</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;c:foreach begin=<span class="string">"0"</span> end=<span class="string">"9"</span> <span class="keyword">var</span>=<span class="string">"i"</span> step=<span class="string">"1"</span>&gt;</span><br><span class="line">	$&#123;i&#125;</span><br><span class="line">&lt;/c:foreach&gt;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>遍历容器</p>
<ul>
<li>items：容器对象</li>
<li>var：临时变量</li>
<li>varStatus：循环状态对象<ul>
<li>index：容器中元素的索引，从0开始</li>
<li>count：循环次数，从1开始</li>
</ul>
</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;c:foreach items=<span class="string">"list"</span> <span class="keyword">var</span>=<span class="string">"str"</span> varStatus=<span class="string">"s"</span>&gt;</span><br><span class="line">	$&#123;str&#125;</span><br><span class="line">&lt;/c:foreach&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>EL</tag>
        <tag>JSTL</tag>
      </tags>
  </entry>
  <entry>
    <title>JSP</title>
    <url>/2019/05/26/Java/2.JavaWeb/11.JSP/</url>
    <content><![CDATA[<p>jsp在目前前后端分离的大趋势下已经逐渐被抛弃了…</p>
<a id="more"></a>

<h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><ul>
<li>Java Server pages：Java服务器端页面</li>
<li>JSP是一个特殊的页面，既可以指定HTML 代码，又可以定义Java代码</li>
</ul>
<h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>JSP本质上是一个Servlet</p>
<ul>
<li>浏览器访问 jsp 时，服务器会把 jsp 转化为一个 <code>.java</code> 文件，这个 <code>.java</code> 文件就是一个Servlet</li>
</ul>
<h3 id="JSP的脚本"><a href="#JSP的脚本" class="headerlink" title="JSP的脚本"></a>JSP的脚本</h3><p>JSP的脚本是书写Java代码的区域</p>
<ul>
<li><code>&lt;% 代码 %&gt;</code>：这个脚本中的Java代码会出现在service方法中，该脚本中可以书写方法中可以书写的内容</li>
<li><code>&lt;%! 代码 %&gt;</code>：可以定义成员变量和成员方法</li>
<li><code>&lt;%= 代码 %&gt;</code>：定义的java代码，可以直接输出到页面上</li>
</ul>
<h3 id="JSP的指令"><a href="#JSP的指令" class="headerlink" title="JSP的指令"></a>JSP的指令</h3><p>作用：用于配置JSP页面，导入资源文件</p>
<p>格式：<code>&lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2 ... %&gt;</code></p>
<p>指令种类：</p>
<ul>
<li><strong>page</strong>：用于配置JSP页面<ul>
<li><strong>contentType</strong>：等同于<code>response.setContentType()</code><ul>
<li>设置响应体的<strong>mime类型</strong>以及<strong>字符集</strong></li>
<li>在IDE中，会自动根据该属性的值，设置当前jsp页面的编码</li>
</ul>
</li>
<li><strong>import</strong>：导 java 包</li>
<li><strong>errorPage</strong>：当页面发生异常后，会自动跳转到指定的错误页面</li>
<li><strong>isErrorPage</strong>：标识当前页面是否是错误页面，如果标识为<code>true</code>，则可以使用内置对象<code>exception</code></li>
</ul>
</li>
<li><strong>taglib</strong>：用于导入资源<ul>
<li><code>&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</code></li>
<li>其中prefix为前缀，一般有一些约定俗成名称</li>
</ul>
</li>
<li><strong>include</strong>：用于导入其他的jsp文件</li>
</ul>
<h3 id="JSP中的注释"><a href="#JSP中的注释" class="headerlink" title="JSP中的注释"></a>JSP中的注释</h3><p>JSP 中有两种注释</p>
<ul>
<li>HTML注释：<code>&lt;!-- 内容 --&gt;</code> ： 只能注释HTML内容</li>
<li>JSP注释：<code>&lt;%-- 内容 --%&gt;</code>：可以注释jsp页面中的所有内容，<strong>推荐使用</strong></li>
</ul>
<h3 id="JSP的内置对象"><a href="#JSP的内置对象" class="headerlink" title="JSP的内置对象"></a>JSP的内置对象</h3><p>在jsp页面中不需要获取和创建，直接就可以使用的对象</p>
<p>JSP一个有9个内置对象：</p>
<table>
<thead>
<tr>
<th align="center">变量名</th>
<th align="center">真实类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">pageContext</td>
<td align="center">PageContext</td>
</tr>
<tr>
<td align="center">request</td>
<td align="center">HttpServletRequest</td>
</tr>
<tr>
<td align="center">session</td>
<td align="center">HttpSession</td>
</tr>
<tr>
<td align="center">application</td>
<td align="center">ServletContext</td>
</tr>
<tr>
<td align="center">response</td>
<td align="center">HttpServletResponse</td>
</tr>
<tr>
<td align="center">page</td>
<td align="center">Object</td>
</tr>
<tr>
<td align="center">out</td>
<td align="center">JspWriter</td>
</tr>
<tr>
<td align="center">config</td>
<td align="center">ServletConfig</td>
</tr>
<tr>
<td align="center">exception</td>
<td align="center">Throwable</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JSP</tag>
      </tags>
  </entry>
  <entry>
    <title>redis</title>
    <url>/2019/05/26/Java/2.JavaWeb/redis/</url>
    <content><![CDATA[<p>redis是一款典型的内存数据库</p>
<a id="more"></a>

<h2 id="redis简介"><a href="#redis简介" class="headerlink" title="redis简介"></a>redis简介</h2><p>概念: redis是一款高性能的非关系型数据库(NOSQL)</p>
<p>关系型数据库 和 非关系型数据库的一些不同:</p>
<ul>
<li>关系型数据库:<ul>
<li>数据之间有联系</li>
<li>数据存储在硬盘的文件上</li>
</ul>
</li>
<li>非关系型数据库<ul>
<li>数据之间没有关系</li>
<li>数据存储在内存中</li>
</ul>
</li>
</ul>
<blockquote>
<p>关系型数据库和非关系型数据库是一种互补的状态</p>
<p>一般将数据存储在关系型数据库中, 在非关系型数据库中备份存储关系型数据库中的数据</p>
</blockquote>
<h2 id="redis命令操作"><a href="#redis命令操作" class="headerlink" title="redis命令操作"></a>redis命令操作</h2><p><strong>redis的数据结构</strong>: <strong>key, value 结构</strong>的数据, 其中key都是字符串, value则有5种不同的数据结构</p>
<p>value 的5种数据结构:</p>
<ul>
<li>字符串类型 String</li>
<li>哈希类型 hash  (map格式)</li>
<li>列表类型 list  (linkedlist格式)</li>
<li>集合类型 set</li>
<li>有序集合类型 sortedset</li>
</ul>
<p><strong>字符串</strong>类型的命令:</p>
<ul>
<li>存储: <code>set key value</code></li>
<li>获取: <code>get key</code></li>
<li>删除: <code>del key</code></li>
</ul>
<p><strong>哈希</strong>类型的命令:</p>
<ul>
<li>存储: <code>hset key field value</code></li>
<li>获取: <ul>
<li><code>hget key field</code>  获取指定field对应的值</li>
<li><code>hgetall key</code>  获取key对应的所有的field和value</li>
</ul>
</li>
<li>删除: <code>hdel key field</code></li>
</ul>
<p><strong>列表</strong>类型的命令: <code>key</code>为列表名, 列表中的元素都为<strong>string</strong></p>
<ul>
<li><p>存储: </p>
<ul>
<li><code>lpush key value</code>  从列表的左边添加一个元素</li>
<li><code>rpush key value</code>  从列表的右边添加一个元素</li>
</ul>
</li>
<li><p>获取: <code>lrange key start end</code>  获取列表指定范围内的元素</p>
</li>
<li><p>删除:</p>
<ul>
<li><code>lpop key</code>  删除列表最左边的元素并返回</li>
<li><code>rpop key</code>  删除列表最右边的元素并返回</li>
</ul>
</li>
</ul>
<p><strong>集合</strong>类型的命令: <code>key</code>为集合名, 集合中的元素都为<strong>string</strong></p>
<ul>
<li>存储: <code>sadd key value</code></li>
<li>获取: <code>smembers key</code>  获取列表中的所有元素</li>
<li>删除: <code>srem key value</code>  删除列表中的某个元素</li>
</ul>
<p><strong>有序集合</strong>类型的命令: <code>key</code>为集合名, 通过 <code>score</code> 来排序</p>
<ul>
<li>存储: <code>zadd key score value</code>  </li>
<li>获取: <code>zrange key start end</code>  获取指定范围内的元素</li>
<li>删除: <code>zrem key value</code></li>
</ul>
<p><strong>通用命令</strong>:</p>
<ul>
<li><code>keys *</code>  查询所有键</li>
<li><code>type key</code>  获取<code>key</code>对应的<code>value</code>的类型</li>
<li><code>del key</code>  删除指定的 key value</li>
</ul>
<h2 id="redis的持久化"><a href="#redis的持久化" class="headerlink" title="redis的持久化"></a>redis的持久化</h2><p>redis的持久化有两种机制:</p>
<ul>
<li><p><strong>RDB</strong> (Redis DataBase): 在一定间隔时间内, 检测key的变化情况, 然后持久化数据. (默认机制)</p>
</li>
<li><p><strong>AOF</strong> (Append Only File): 日志记录方式, 把redis所有的<strong>写指令</strong>记录到文件中, 重启服务器时重新运行所有的写指令,以达到恢复数据的目的</p>
<p>要开启AOF, 只需要在redis的配置文件<code>redis.windows.conf</code>中配置: <code>appendonly yes</code></p>
<p>AOF有3中模式:(只能选择一种使用, 默认使用<code>appendfsync everysec</code>)</p>
<ul>
<li><code>appendfsync always</code>  每次有写指令就持久化</li>
<li><code>appendfsync everysec</code>  每秒持久化<ul>
<li><code>appendfsync no</code>  系统高兴的时候持久化</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Java操作redis"><a href="#Java操作redis" class="headerlink" title="Java操作redis"></a>Java操作redis</h2><blockquote>
<p>java使用<code>Jedis</code>来操作redis</p>
</blockquote>
<p>Jedis 的基本使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickGetStart</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建连接</span></span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"localhost"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 执行命令</span></span><br><span class="line">    jedis.set(<span class="string">"username"</span>, <span class="string">"zhangsan"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 关闭连接</span></span><br><span class="line">    jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Jedis中执行命令的方法名称就是redis的命令名称</p>
</blockquote>
<p>使用Jedis的<code>setex</code>方法可以指定key value 的过去时间</p>
<ul>
<li><code>jedis.setex(&quot;checkcode&quot;, 20, &quot;aabb&quot;)</code> –&gt; 20s 过期</li>
</ul>
<p><strong>Jedis连接池</strong></p>
<blockquote>
<p>Jedis自带连接池 <code>JedisPool</code></p>
</blockquote>
<p>创建连接池并从连接池中获取连接:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建连接池(调用空参构造)</span></span><br><span class="line">    JedisPool jedisPool = <span class="keyword">new</span> JedisPool();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    Jedis jedis = JedisPool.getResource();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 jedis</span></span><br><span class="line">    jedis.set(<span class="string">"hello"</span>, <span class="string">"你好"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 归还连接</span></span><br><span class="line">    jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以创建配置对象对JedisPool进行配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建配置对象, 配置连接池</span></span><br><span class="line">    JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">    config.setMaxTotal(<span class="number">50</span>);  <span class="comment">// 配置最大连接数</span></span><br><span class="line">    <span class="comment">// 还有很多配置......</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建连接池对象(有参构造)</span></span><br><span class="line">    JedisPool jedisPool = <span class="keyword">new</span> JedisPool(config, <span class="string">"localhost"</span>, <span class="number">6379</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取连接, 使用连接, 归还连接 均同上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>其他技术</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Bootstrap</title>
    <url>/2019/05/26/Java/2.JavaWeb/5.Bootstrap/</url>
    <content><![CDATA[<p>BootStrap是一个前端开发框架，来自Twitter</p>
<a id="more"></a>

<h1 id="BootStrap"><a href="#BootStrap" class="headerlink" title="BootStrap"></a>BootStrap</h1><p>概念：BootStrap是一个前端开发框架，来自Twitter，基于HTML，CSS，JavaScript</p>
<p>优点：</p>
<ul>
<li>定义了很多css样式和js插件，可以直接使用这些样式和插件获得丰富的页面效果</li>
<li>响应式布局：同一套页面可以兼容不同分辨率的设备</li>
</ul>
<h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2><p>实现：基于栅格系统，将一行平均分为12个格子，可以指定元素占几个格子</p>
<p>步骤：</p>
<ol>
<li><p>定义容器</p>
<ul>
<li>容器分为两类：<ul>
<li>container：两边留白，比较常用</li>
<li>container-fluid： 每一种设备都是100%宽度</li>
</ul>
</li>
</ul>
</li>
<li><p>定义行</p>
<p>样式：row</p>
</li>
<li><p>定义元素</p>
<p>指定该元素在不同的设备上，所占格子的数目，col-设备代号-格子数目</p>
<ul>
<li><p>设备代号：</p>
<ul>
<li>xs：超小屏幕 手机（&lt;768px）</li>
<li>sm：小屏幕 平板（≥768px）</li>
<li>md：大屏幕 笔记本电脑 （≥992px）</li>
<li>lg：超大屏幕 桌面显示器 （≥1200px）</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li>一行中如果格子数目超过12，则会自动换行</li>
<li>栅格类的属性向上兼容</li>
<li>如果真实设备的宽度小于了设置栅格类属性的设备代码的最小值，会一个元素占满一行</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="css样式和js插件"><a href="#css样式和js插件" class="headerlink" title="css样式和js插件"></a>css样式和js插件</h2><p>用到的时候从官方文档里面找看着顺眼的样式，复制过来改改就好了</p>
]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>BootStrap</tag>
      </tags>
  </entry>
  <entry>
    <title>Git</title>
    <url>/2019/05/22/Java/Git/</url>
    <content><![CDATA[<p>Git是目前世界上最先进的<strong>分布式版本控制系统</strong>（没有之一）</p>
<a id="more"></a>

<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><blockquote>
<p>SVN：集中式版本控制系统</p>
<p>Git：  分布式版本控制系统</p>
</blockquote>
<h3 id="使用Git的步骤："><a href="#使用Git的步骤：" class="headerlink" title="使用Git的步骤："></a>使用Git的步骤：</h3><p>1、安装Git</p>
<p>2、设置用户名和邮箱</p>
<ul>
<li><code>$ git config --global user.name &quot;Your Name&quot;</code></li>
<li><code>$ git config --global user.email &quot;email@example.com&quot;</code></li>
</ul>
<p>3、创建版本库（仓库 repository）</p>
<ul>
<li><p>选择一个合适的地方，创建一个空目录</p>
</li>
<li><p>在 Git Bash 中，cd 到该目录（或者直接把Git Bash添加到右键菜单，然后在空目录直接右键打开Git Bash）</p>
</li>
<li><p>运行<code>git init</code>命令，创建 repository 完成</p>
</li>
</ul>
<p>4、把文件添加到版本库</p>
<ul>
<li><p>使用<code>git add FileName</code>将指定文件添加到暂存区</p>
</li>
<li><p>使用<code>git commit -m &quot;commit explain&quot;</code>将暂存区文件提交到仓库</p>
<blockquote>
<p>注意事项：</p>
<p>版本控制工具只能跟踪<strong>文本文件</strong>（txt，程序代码等）的改动</p>
<p>使用<code>git add</code>的文件 <strong>必须在仓库目录下</strong></p>
<p><code>git commit</code>的参数<code>-m</code>后面可以直接写<strong>本次提交的说明</strong>（如果不加<code>-m</code>，在输入<code>git commit</code>回车后，会打开<code>Vim</code>让你输入提交说明）</p>
</blockquote>
</li>
</ul>
<h3 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h3><ul>
<li><code>git status</code> –&gt; 查看仓库当前的状态</li>
<li><code>git diff</code> –&gt; 查看修改的内容</li>
<li><code>git log</code> –&gt; 显示从最近到最远的提交日志</li>
<li><code>git reflog</code> –&gt; 查看命令历史，以便确定要回到未来的哪个版本</li>
<li><code>git reset --hard HEAD^</code> –&gt; 回退到上一个版本<ul>
<li><code>--hard HEAD^^</code> –&gt; 回退到上上个版本</li>
<li><code>--hard &lt;commit_id&gt;</code> –&gt; 回退到 commit_id 指定的版本</li>
</ul>
</li>
<li><code>git checkout -- filename</code> –&gt; 用版本库中的版本替换工作区的版本</li>
<li><code>git rm filename</code> –&gt; 删除工作区的一个文件</li>
</ul>
<h3 id="暂存区的概念"><a href="#暂存区的概念" class="headerlink" title="暂存区的概念"></a>暂存区的概念</h3><p>暂存区位于版本库（.git 文件夹）中，称为stage</p>
<p>git add 操作就是<strong>将文件添加到暂存区</strong></p>
<p>git commit 操作就是<strong>将位于暂存区的所有文件提交到当前分支</strong></p>
<blockquote>
<p>git 是<strong>管理修改</strong>而非管理文件的</p>
</blockquote>
<h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><p>一般使用github作为自己的远程仓库</p>
<ul>
<li><p>将本地仓库与远程仓库关联</p>
<p><code>git remote add origin https://github.com/PikachuHL/learngit.git</code></p>
</li>
<li><p>将本地仓库的内容推送到远程仓库</p>
<ul>
<li><p>第一次</p>
<p><code>git push -u origin master</code></p>
</li>
<li><p>以后</p>
<p><code>git push origin master</code></p>
</li>
</ul>
</li>
<li><p>从远程仓库克隆</p>
<p><code>git clone https://github.com/PikachuHL/learngit.git</code></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Git</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle</title>
    <url>/2019/05/17/Java/Oracle/</url>
    <content><![CDATA[<a id="more"></a>

]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM整合</title>
    <url>/2019/05/17/Java/3.SSM%E6%A1%86%E6%9E%B6/SSM%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<p>ssm整合起来, 实现前端页面可以对数据库进行增删改查</p>
<a id="more"></a>

<h1 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a>SSM整合</h1><p>Spring / SpringMVC / MyBatis 整合的基本要求：</p>
<ul>
<li>由Spring框架整合其他两个框架</li>
<li>每个框架都需要可以独立运行</li>
</ul>
<h2 id="Spring整合SpringMVC"><a href="#Spring整合SpringMVC" class="headerlink" title="Spring整合SpringMVC"></a>Spring整合SpringMVC</h2><p>在web.xml 中设置监听器，当服务器启动时，由监听器完成加载spring 配置文件的动作。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置监听器，用于加载Spring的配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="Spring整合MyBatis"><a href="#Spring整合MyBatis" class="headerlink" title="Spring整合MyBatis"></a>Spring整合MyBatis</h2><p>在Spring 的配置文件中配置SqlSession 工厂，用于将代理dao放到Spring 容器中</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring 整合 MyBatis --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置数据库连接池，用 c3p0 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql:///springtest"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置SqlSession工厂 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactoryBean"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置AccountDao接口所在的包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mapperScanner"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.pika.dao"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>另外，因为对数据库的增删改操作需要事务的支持，</p>
<p>所以需要在Spring 的配置文件中设置事务</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置Spring的声明式事务 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置事务通知 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txadvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"find*"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置AOP增强 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txadvice"</span> <span class="attr">pointcut</span>=<span class="string">"execution(* com.pika.service.*.*(..))"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SSM整合</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC_响应</title>
    <url>/2019/05/16/Java/3.SSM%E6%A1%86%E6%9E%B6/SpringMVC_%E5%93%8D%E5%BA%94/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="SpringMVC的响应"><a href="#SpringMVC的响应" class="headerlink" title="SpringMVC的响应"></a>SpringMVC的响应</h2><p>Spring的响应分为几种类型 (根据控制器中的方法返回值不同):</p>
<ul>
<li>返回 <code>String</code>，<ul>
<li>字符串名为页面名称，通过视图解析器来把字符串匹配到要响应的页面</li>
<li>字符串为<code>关键字+页面地址</code>，通过<code>forward</code>、<code>redirect</code> 两个关键字来实现转发和重定向</li>
</ul>
</li>
<li>返回 <code>void</code>，通过request、response来转发、重定向到指定页面</li>
<li>返回 <code>ModelAndView</code></li>
<li>返回<code>json</code>格式数据（实际返回的是javabean，通过<code>@ResponseBody</code>注解实现转换为json数据）</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC_基础</title>
    <url>/2019/05/15/Java/3.SSM%E6%A1%86%E6%9E%B6/SpringMVC_%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>SpringMVC入门案例</p>
<a id="more"></a>

<h1 id="SpringMVC-基础"><a href="#SpringMVC-基础" class="headerlink" title="SpringMVC_基础"></a>SpringMVC_基础</h1><p><strong>基本概念：</strong></p>
<ul>
<li><p><strong>三层架构：</strong></p>
<ul>
<li>表现层</li>
<li>业务层</li>
<li>持久层</li>
</ul>
</li>
<li><p><strong>MVC模型（Model View Controller）：</strong></p>
<ul>
<li>Model：数据模型，JavaBean的类，用来进行数据封装。</li>
</ul>
<ol start="3">
<li>View：指JSP、HTML用来展示数据给用户</li>
<li>Controller：用来接收用户的请求，整个流程的控制器。用来进行数据校验等。 </li>
</ol>
</li>
<li><p><strong>SpringMVC：</strong>基于MVC设计模式的轻量级web框架</p>
</li>
<li><p><strong>SpringMVC有清晰的角色划分：</strong></p>
<ul>
<li>前端控制器（DispatcherServlet）</li>
<li>处理器映射器（HandlerMapping）</li>
<li>处理器适配器（HandlerAdapter）</li>
<li>视图解析器（ViewResolver）</li>
<li>处理器或页面控制器（Controller）</li>
<li>验证器（Validator）</li>
<li>命令对象（Command 请求参数绑定到的对象就是命令对象）</li>
<li>表单对象（Form Object 提供给表单展示或提交到的对象就是表单对象）</li>
</ul>
</li>
</ul>
<h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h2><blockquote>
<p>入门案例需求:</p>
<p>​    在<code>index.jsp</code>中写一个超链接, 点击超链接, 跳转到 <code>success.jsp</code></p>
</blockquote>
<p>*<em>在<code>index.jsp</code>中写一个超链接标签: *</em></p>
<p><code>&lt;a href = &quot;hello&quot;&gt;入门案例&lt;/a&gt;</code></p>
<p><strong>创建<code>success.jsp</code>页面</strong></p>
<p>在<code>WEB-INF</code>文件夹下创建<code>pages</code>文件夹, 并在<code>pages</code>文件夹中创建<code>success.jsp</code></p>
<p><strong>创建一个Controller类, 并写一个方法, 在方法上添加<code>@RequestMapping</code>注解, 返回一个字符串:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(path = <span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HelloController"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>配置SpringMVC的各个组件：</strong></p>
<ul>
<li><p>前端控制器（DispatcherServlet）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在web.xml中进行配置 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置前端控制器DispatcherServlet，其实就是一个Servlet--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置全局初始化参数，用于加载Spring的配置文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationcontext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置服务器启动时就创建Servlet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>DispatcherServlet 中的url-pattern, 一定要配置 <code>/</code>, 而不能配置<code>/*</code></p>
<p>配置成 <code>/*</code> 会导致访问<code>.jsp</code> 时出现<code>404</code>的情况</p>
</blockquote>
</li>
<li><p>处理器映射器（HandlerMapping）</p>
</li>
<li><p>处理器适配器（HandlerAdapter）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启SpringMVC框架注解的支持</span></span><br><span class="line"><span class="comment">使用此标签会自动加载 处理器映射器（RequestMappingHandlerMapping） 和 </span></span><br><span class="line"><span class="comment">处理器适配器（RequestMappingHandlerAdapter）</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>视图解析器（ViewResolver）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在Spring的配置文件中进行配置 --&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 配置视图解析器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"internalResourceViewResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/pages/"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<hr>
<p><strong>入门案例的流程总结:</strong></p>
<p><img src="C:%5Cdevelop%5Cblog%5Csource%5Cimages%5Cspringmvc%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%8E%9F%E7%90%86.jpg" alt=""></p>
<p><strong>@RequestMapping注解：</strong></p>
<p><strong>作用：</strong>用于建立 <strong>请求URL</strong> 和 <strong>处理请求方法</strong> 之间的对应关系</p>
<p><strong>作用范围：类</strong> 和 <strong>方法</strong></p>
<p><strong>属性：</strong></p>
<ul>
<li><code>path</code> –&gt; 指定请求路径的url</li>
<li><code>value</code> –&gt; 和path属性是一样的</li>
<li><code>method</code> –&gt; 指定该方法的请求方式(get/post/…)</li>
<li><code>params</code> –&gt; 指定限制请求参数的条件</li>
<li><code>headers</code> –&gt; 发送的请求中必须包含的请求头</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Template &amp; 事务</title>
    <url>/2019/05/12/Java/3.SSM%E6%A1%86%E6%9E%B6/Spring%20Template&amp;%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<p>JdbcTemplate：Spring 提供的一个对 JDBC 的简单封装</p>
<a id="more"></a>

<h2 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h2><p>JdbcTemplate：Spring 提供的一个对 JDBC 的简单封装</p>
<p>JdbcTemplate的使用：</p>
<ul>
<li><p>导坐标（maven）</p>
<ul>
<li>spring-jdbc</li>
</ul>
</li>
<li><p>创建 JdbcTemplate 对象(<em>需要数据源，有参/无参创建</em>)</p>
<pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 有参创建	</span></span><br><span class="line">JdbcTemplate template = <span class="keyword">new</span> JdbcTemplate(DataSource ds);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 无参创建</span></span><br><span class="line">  JdbcTemplate template = <span class="keyword">new</span> JdbcTemplate();</span><br><span class="line">  template.setDataSource(ds);</span><br></pre></td></tr></table></figure></code></pre></li>
<li><p>调用 JdbcTemplate 中的方法完成 <strong>CRUD</strong> 操作</p>
<ul>
<li><code>update()</code> –&gt; 执行<strong>增、删、改</strong><ul>
<li><strong>增</strong>：<code>template.update(&quot;insert into account(name, money) values(?, ?)&quot;, &quot;aaa&quot;, 1000);</code></li>
<li><strong>改</strong>：<code>template.update(&quot;update account set name=?, money=? where id=?&quot;, &quot;bbb&quot;, 2000, 2);</code></li>
<li><strong>删</strong>：<code>template.update(&quot;delete from account where id = ?&quot;, 2);</code></li>
</ul>
</li>
<li><code>query()</code> –&gt; 查询结果，将结果自动封装为 JavaBean 对象<ul>
<li>查询所有：<code>List&lt;Account&gt; accounts = template.query(&quot;select * from account where money &gt; ?&quot;, new BeanPropertyRowMapper&lt;Account&gt;(Account.class), 1000);</code></li>
<li>query的<strong>参数</strong>：(1:<strong>sql查询语句</strong>, 2:<strong>BeanPropertyRowMapper&lt;封装类&gt;(封装类.class)</strong>, 3:<strong>可变参数</strong>)</li>
<li>一般我们使用 <strong>RowMapper</strong> 实现类 <strong>BeanPropertyRowMapper</strong>。可以完成 <strong>数据</strong> 到 <strong>JavaBean</strong> 的自动封装</li>
</ul>
</li>
<li><code>queryForMap()</code> –&gt; 查询一条记录，将查询结果封装为一个map集合<ul>
<li>注意：这个方法查询的结果集长度只能是1</li>
</ul>
</li>
<li><code>queryForList()</code> –&gt; 查询结果，将结果集封装为list集合<ul>
<li>注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中</li>
</ul>
</li>
<li><code>queryForObject()</code> –&gt; 查询结果，将结果封装为对象<ul>
<li>一般用于聚合函数的查询</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<p>Spring的内置数据库连接池：<code>DriveManagerDataSource</code></p>
</blockquote>
<h2 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h2><blockquote>
<p>在 JavaEE 开发中，事务处理位于<strong>业务层</strong></p>
<p>mavne项目坐标：spring-tx</p>
<p>Spring的事务控制都是基于AOP的，可通过配置实现（常用），也可通过编程实现</p>
</blockquote>
<p>Spring的事务管理器：</p>
<ul>
<li>接口：<code>PlatformTransactionManager</code></li>
<li>实现类：<code>DataSourceTransactionManager</code>（真正管理事务的对象）</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring中基于XML的声明式事务控制的配置步骤 </span></span><br><span class="line"><span class="comment">	1.配置事务管理器</span></span><br><span class="line"><span class="comment">	2.配置事务的通知</span></span><br><span class="line"><span class="comment">		此时我们需要 tx 名称空间和约束</span></span><br><span class="line"><span class="comment">		使用 tx:advice 标签配置事务通知</span></span><br><span class="line"><span class="comment">			标签的属性：</span></span><br><span class="line"><span class="comment">				id：给事务通知起个名</span></span><br><span class="line"><span class="comment">				transaction-manager：给事务通知提供一个事务管理器引用</span></span><br><span class="line"><span class="comment">	3.配置AOP中的通用切入点表达式</span></span><br><span class="line"><span class="comment">	4.建立事务通知和切入点表达式的对应关系</span></span><br><span class="line"><span class="comment">	5.配置事务的属性</span></span><br><span class="line"><span class="comment">		在 tx:advice 标签的内部使用 tx:attributes 标签进行配置</span></span><br><span class="line"><span class="comment">		tx:attributes 标签的属性：</span></span><br><span class="line"><span class="comment">			isolation：用于指定事务的隔离级别，默认值为DEFAULT，表示使用数据库的默认隔离级别</span></span><br><span class="line"><span class="comment">			propagation：用于指定事务的传播行为，默认值为REQUIRED,表示一定有事务，增删改方法选择默认值。查询方法使用SUPPORTS</span></span><br><span class="line"><span class="comment">			read-only：用于指定方法是否只读，查询方法设置为true，增删改设置为false，表示读写</span></span><br><span class="line"><span class="comment">			time-out：用于指定事务的超时时间，默认值为-1，表示永不超时，时间单位为秒</span></span><br><span class="line"><span class="comment">			rollback-for：用于指定一个异常，当产生该异常时，事务回滚；当产生其他异常时，事务不回滚，不指定异常，表示任何异常都回滚</span></span><br><span class="line"><span class="comment">			no-rollback-for:用于指定一个异常，当产生该异常时，事务不回滚；当产生其他异常时，事务回滚，不指定异常，表示任何异常都回滚</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置事务的通知 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置事务的属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 为方法配置事务属性 --&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">read-only</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"find*"</span> <span class="attr">propagation</span>=<span class="string">"SUPPORTS"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置AOP --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 配置通用切入点表达式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pt1"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.pika.service.impl.*.*(..))"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:pointcut</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 建立事务通知和切入点表达式的对应关系 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JDBCTemplate</tag>
        <tag>Spring事务</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC_数据库连接池</title>
    <url>/2019/05/06/Java/1.Java%E5%9F%BA%E7%A1%80/JDBC_%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    <content><![CDATA[<p>C3P0 &amp; druid</p>
<a id="more"></a>

<h2 id="JDBC-数据库连接池"><a href="#JDBC-数据库连接池" class="headerlink" title="JDBC_数据库连接池"></a>JDBC_数据库连接池</h2><p>1、数据库连接池的<strong>概念</strong>：数据库连接池就是一个容器，里面存放的是数据库的连接对象</p>
<p>2、JDBC 中提供的接口：DataSource</p>
<ul>
<li>获取连接的方法：<code>getConnection()</code> </li>
</ul>
<blockquote>
<p>如果连接是从连接池中获取，当连接对象调用 close() 方法时，并不是关闭连接，而是归还连接</p>
</blockquote>
<p>3、学习两种数据库连接池：</p>
<ul>
<li>C3P0：一款比较老的数据库连接池（仅学习一下）</li>
<li>druid：阿里巴巴出品的一款效率很高的、使用很广的数据库连接池（以后就用这个）</li>
</ul>
<h3 id="一、C3P0"><a href="#一、C3P0" class="headerlink" title="一、C3P0"></a>一、C3P0</h3><p>使用步骤：</p>
<ul>
<li>导入 jar 包</li>
<li>定义配置文件<ul>
<li>名称：必须为：c3p0.properties 或者 c3p0-config.xml</li>
<li>路径：放在 src 目录下</li>
</ul>
</li>
<li>创建连接池对象<ul>
<li><code>DataSource ds = new ComboPooledDataSource();</code></li>
</ul>
</li>
<li>获取连接<ul>
<li><code>Connection conn = ds.getConnection();</code></li>
</ul>
</li>
</ul>
<h3 id="二、druid"><a href="#二、druid" class="headerlink" title="二、druid"></a>二、druid</h3><p>使用步骤：</p>
<ul>
<li>导入 jar 包</li>
<li>定义配置文件<ul>
<li>定义 properties 类型的配置文件</li>
<li>可以为任意名称，可以放在任意目录下</li>
</ul>
</li>
<li>加载配置文件<ul>
<li><code>Properries pro = new Properties();</code></li>
<li><code>pro.load(类名.class.getClassLoader().getResourceAsStream(&quot;配置文件名&quot;));</code></li>
</ul>
</li>
<li>获取连接池对象<ul>
<li><code>DataSource ds = DruidDataSourceFactory.createDataSource(pro);</code></li>
</ul>
</li>
<li>获取连接<ul>
<li><code>Connection conn = ds.getConnection();</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
        <tag>数据库连接池</tag>
      </tags>
  </entry>
  <entry>
    <title>继承&amp;多态&amp;内部类</title>
    <url>/2019/05/04/Java/1.Java%E5%9F%BA%E7%A1%80/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<p>继承是多态的前提</p>
<a id="more"></a>

<h1 id="继承与多态"><a href="#继承与多态" class="headerlink" title="继承与多态"></a>继承与多态</h1><h2 id="一、继承"><a href="#一、继承" class="headerlink" title="一、继承"></a>一、继承</h2><p>关键字：<strong>extends</strong></p>
<p>在继承关系中，“子类就是一个父类”  关系：<strong>is-a</strong></p>
<p>父类不知道子类，子类知道父类</p>
<hr>
<p>在父子类的继承关系中，如果<strong>成员变量重名</strong>，则访问成员变量有两种方式：</p>
<ul>
<li>直接通过对象名称访问成员变量：看<strong>等号左边是谁</strong>，则优先用谁，没有则向上找</li>
<li>间接通过成员方法访问成员变量：看<strong>该方法属于谁</strong>，则优先用谁，没有则向上找</li>
</ul>
<p>在继承关系中，成员方法的访问特性：</p>
<ul>
<li><strong>创建对象是谁</strong>，就优先用谁，如果没有则向上找</li>
</ul>
<hr>
<p>关于<strong>变量的定位</strong>（在子类方法中）：</p>
<ul>
<li>局部变量：直接写局部变量名</li>
<li>本类成员变量：this.成员变量名</li>
<li>父类成员变量：super.成员变量名</li>
</ul>
<hr>
<p>在子类构造方法中，通过<code>super();</code>调用父类的构造方法，</p>
<p>注意：<code>super();</code>在子类的构造方法中如果存在，就必须是第一个语句</p>
<hr>
<p><strong>super &amp; this</strong></p>
<p>super关键字的用法有三种：</p>
<ul>
<li><p>在子类的成员方法中，访问父类的成员变量。</p>
</li>
<li><p>在子类的成员方法中，访问父类的成员方法。</p>
</li>
<li><p>在子类的构造方法中，访问父类的构造方法。</p>
</li>
</ul>
<p>super关键字用来访问父类内容，而this关键字用来访问本类内容。用法也有三种：</p>
<ul>
<li><p>在本类的成员方法中，访问本类的成员变量。</p>
</li>
<li><p>在本类的成员方法中，访问本类的另一个成员方法。</p>
</li>
<li><p>在本类的构造方法中，访问本类的另一个构造方法。</p>
<ul>
<li>在第三种用法当中要注意：<ul>
<li>this(…)调用也必须是构造方法的第一个语句，唯一一个。</li>
<li>super和this两种构造调用，不能同时使用。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>关键字：<strong>abstract</strong></p>
<p><strong>抽象方法</strong>和<strong>抽象类</strong>：</p>
<ul>
<li>抽象方法所在的类必须为抽象类</li>
<li>抽象类中不一定有抽象方法</li>
</ul>
<p>抽象类的特点：</p>
<ul>
<li>抽象类不能创建对象</li>
<li>继承了抽象类的子类必须<strong>实现</strong>抽象类中<strong>所有</strong>的<strong>抽象方法</strong></li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口是一种<strong>公共的规范标准</strong></p>
<p>关键字：</p>
<ul>
<li><strong>interface</strong>（定义接口）</li>
<li><strong>implements</strong>（实现接口）</li>
</ul>
<p><strong>接口中的内容：</strong></p>
<ol>
<li><p>成员变量其实是<strong>常量</strong>，格式：<br>[public] [static] [final] 数据类型 常量名称 = 数据值;<br>注意：<br> 常量必须进行赋值，而且一旦赋值不能改变。<br> 常量名称完全大写，用下划线进行分隔。</p>
</li>
<li><p>接口中最重要的就是<strong>抽象方法</strong>，格式：<br>[public] [abstract] 返回值类型 方法名称(参数列表);<br>注意：实现类必须覆盖重写接口所有的抽象方法，除非实现类是抽象类。</p>
</li>
<li><p>从Java 8开始，接口里允许定义<strong>默认方法</strong>，格式：<br>[public] default 返回值类型 方法名称(参数列表) { 方法体 }<br>注意：默认方法也可以被覆盖重写</p>
</li>
<li><p>从Java 8开始，接口里允许定义<strong>静态方法</strong>，格式：<br>[public] static 返回值类型 方法名称(参数列表) { 方法体 }<br>注意：应该通过接口名称进行调用，不能通过实现类对象调用接口静态方法</p>
</li>
<li><p>从Java 9开始，接口里允许定义<strong>私有方法</strong>，格式：<br>普通私有方法：private 返回值类型 方法名称(参数列表) { 方法体 }<br>静态私有方法：private static 返回值类型 方法名称(参数列表) { 方法体 }<br>注意：private的方法只有接口自己才能调用，不能被实现类或别人使用。</p>
</li>
</ol>
<p>使用接口的注意事项：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 接口是没有静态代码块或者构造方法的。</span><br><span class="line"><span class="number">2</span>. 一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。</span><br><span class="line">格式：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterfaceImpl</span> <span class="keyword">implements</span> <span class="title">MyInterfaceA</span>, <span class="title">MyInterfaceB</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 覆盖重写所有抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3</span>. 如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可。</span><br><span class="line"><span class="number">4</span>. 如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类。</span><br><span class="line"><span class="number">5</span>. 如果实现类锁实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。</span><br><span class="line"><span class="number">6</span>. 一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先用父类当中的方法。</span><br></pre></td></tr></table></figure>





<blockquote>
<ol>
<li>类与类之间是<strong>单继承</strong>的。直接父类只有一个。</li>
<li>类与接口之间是<strong>多实现</strong>的。一个类可以实现多个接口。</li>
<li><strong>接口与接口之间是多继承的</strong>。</li>
</ol>
<p>注意事项：</p>
<ol>
<li>多个父接口当中的抽象方法如果重复，没关系。</li>
<li>多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写，【而且带着default关键字】。</li>
</ol>
</blockquote>
<h2 id="二、多态"><a href="#二、多态" class="headerlink" title="二、多态"></a>二、多态</h2><blockquote>
<p>动物是父类，狗是子类，金毛是子类对象</p>
<p>金毛既有狗的形态，又有动物的形态</p>
<p>这就叫做<strong>对象</strong>的多态性</p>
<p>PS：多态性是针对于<strong>对象</strong>来说的</p>
</blockquote>
<p>定义格式：<code>Animal animal = new Dog();</code></p>
<hr>
<p><strong>多态</strong>中成员变量和成员方法的访问规则和<strong>继承</strong>中是一模一样的</p>
<p>在多态中访问规则口诀：</p>
<ul>
<li>成员变量：编译看左边，运行还看左边</li>
<li>成员方法：<strong>编译看左边，运行看右边</strong></li>
</ul>
<hr>
<p><strong>向上转型 ** 和 **向下转型</strong></p>
<p>向上转型：<code>Animal animal = new Dog();</code></p>
<p>向下转型：<code>Dog dog = (Dog)animal;</code></p>
<blockquote>
<p>向上转型一定是安全的，但有一个问题：</p>
<ul>
<li>向上转型后，便<strong>无法调用子类原本特有的方法</strong></li>
</ul>
<p>如果想要调用子类原本特有的方法就要 向下转型</p>
<p>但是向下转型一定要注意安全性问题（不要把Cat转为Dog）</p>
</blockquote>
<p>向下转型时要进行判断，通过 关键字：<strong>instanceof</strong></p>
<p><code>变量名 instanceof 类名</code> –&gt; 判断该变量是不是属于该类</p>
<h2 id="三、final"><a href="#三、final" class="headerlink" title="三、final"></a>三、final</h2><p>final 关键字代表最终的、不可改变的</p>
<p>final 可以修饰：</p>
<ul>
<li>类<ul>
<li>final 修饰的类不能有子类，故其中的方法也不能被重写</li>
</ul>
</li>
<li>方法<ul>
<li>final 修饰的方法不能被重写（final 和 abstract 不能同时使用）</li>
</ul>
</li>
<li>局部变量<ul>
<li>final 修饰的局部变量，只能经过一次赋值，且其中的值不可变<ul>
<li>如果变量是基本数据类型，其中的<strong>数据</strong>不可变</li>
<li>如果变量是引用数据类型，其中的<strong>地址值</strong>不可变</li>
</ul>
</li>
</ul>
</li>
<li>成员变量<ul>
<li>final 修饰的成员变量必须进行赋值，<ul>
<li>在定义时赋值 或 在构造方法中赋值<ul>
<li>在构造方法中赋值的时候，必须所有重载的构造方法中都有赋值语句才可以</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="四、权限修饰符"><a href="#四、权限修饰符" class="headerlink" title="四、权限修饰符"></a>四、权限修饰符</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">public</th>
<th align="center">protected</th>
<th align="center">(default)</th>
<th align="center">private</th>
</tr>
</thead>
<tbody><tr>
<td align="center">同一个类（我自己）</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">同一个包（我邻居）</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">不同包的子类（我儿子）</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">不同包非子类（陌生人）</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<h2 id="五、内部类"><a href="#五、内部类" class="headerlink" title="五、内部类"></a>五、内部类</h2><p>内部类有哪几种：</p>
<ul>
<li>成员内部类</li>
<li>局部内部类（<strong>匿名内部类</strong>属于局部内部类）</li>
</ul>
<h3 id="1、成员内部类"><a href="#1、成员内部类" class="headerlink" title="1、成员内部类"></a>1、成员内部类</h3><p><strong>概念：</strong>定义在<strong>类内部</strong>的类</p>
<p><strong>定义：</strong>成员内部类和普通类的定义没有差别</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义成员内部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>访问：</strong>内用外，随意访问；外用内，需要内部类对象</p>
<p><strong>使用成员内部类有两种方式：</strong></p>
<ol>
<li>间接方式：在外部类的方法当中，使用内部类；然后main只是调用外部类的方法。</li>
<li>直接方式，公式：<br>类名称 对象名 = new 类名称();<br><code>外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();</code></li>
</ol>
<p>在内部类的方法中使用外部类的成员变量（重名）：</p>
<ul>
<li><code>外部类名称.this.外部类成员变量名;</code></li>
</ul>
<h3 id="2、局部内部类"><a href="#2、局部内部类" class="headerlink" title="2、局部内部类"></a>2、局部内部类</h3><p><strong>概念：</strong>局部内部类：定义在<strong>方法内部</strong>的类</p>
<p>“局部”：这个类只有在当前方法的内部可以使用，出了方法就不能再用了</p>
<p><strong>定义：</strong> <em>class 的前面没有权限修饰符</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OuterMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>PS：定义类时，权限修饰符的使用规则</p>
<ul>
<li>外部类：<strong>public / (default)</strong></li>
<li>成员内部类：4种权限修饰符都可用</li>
<li>局部内部类：<strong>不用</strong> 权限修饰符</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是【有效final的】。</span><br><span class="line"></span><br><span class="line">备注：从Java 8+开始，只要局部变量事实不变，那么final关键字可以省略。</span><br><span class="line"></span><br><span class="line">原因：</span><br><span class="line">1. new出来的对象在堆内存当中。</span><br><span class="line">2. 局部变量是跟着方法走的，在栈内存当中。</span><br><span class="line">3. 方法运行结束之后，立刻出栈，局部变量就会立刻消失。</span><br><span class="line">4. 但是new出来的对象会在堆当中持续存在，直到垃圾回收消失。</span><br></pre></td></tr></table></figure>



<h3 id="3、匿名内部类"><a href="#3、匿名内部类" class="headerlink" title="3、匿名内部类"></a>3、匿名内部类</h3><p><strong>概念：</strong></p>
<ul>
<li>如果接口的实现类（或者是父类的子类）<strong>只需要使用唯一的一次</strong>，<br>那么这种情况下就可以<strong>省略掉该类的定义</strong>，而改为使用【<strong>匿名内部类</strong>】。</li>
</ul>
<p><strong>定义：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">匿名内部类的定义格式：</span></span><br><span class="line"><span class="comment">接口名称 对象名 = new 接口名称() &#123;</span></span><br><span class="line"><span class="comment">    // 覆盖重写所有抽象方法</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">上述定义格式中，大括号内部的部分为 匿名内部类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 定义一个匿名内部类，实现了 MyInterface 接口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyInterface obj = <span class="keyword">new</span> MyInterface()&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"实现了接口的方法"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对格式“new 接口名称() &#123;...&#125;”进行解析：</span><br><span class="line">1. new代表创建对象的动作</span><br><span class="line">2. 接口名称就是匿名内部类需要实现哪个接口</span><br><span class="line">3. &#123;...&#125;这才是匿名内部类的内容</span><br><span class="line"></span><br><span class="line">另外还要注意几点问题：</span><br><span class="line">1. 匿名内部类，在【创建对象】的时候，只能使用唯一一次。</span><br><span class="line">如果希望多次创建对象，而且类的内容一样的话，那么就需要使用单独定义的实现类了。</span><br><span class="line">2. 匿名对象，在【调用方法】的时候，只能调用唯一一次。</span><br><span class="line">如果希望同一个对象，调用多次方法，那么必须给对象起个名字。</span><br><span class="line">3. 匿名内部类是省略了【实现类&#x2F;子类名称】，但是匿名对象是省略了【对象名称】</span><br><span class="line">强调：匿名内部类和匿名对象不是一回事！！！</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>继承</tag>
        <tag>多态</tag>
        <tag>抽象</tag>
        <tag>接口</tag>
        <tag>final</tag>
        <tag>内部类</tag>
        <tag>权限修饰符</tag>
      </tags>
  </entry>
  <entry>
    <title>Java常用API</title>
    <url>/2019/05/03/Java/1.Java%E5%9F%BA%E7%A1%80/Java%E5%B8%B8%E7%94%A8API/</url>
    <content><![CDATA[<p>Scanner, Random, ArrayList, String, static关键字, Arrays, Math</p>
<a id="more"></a>

<h1 id="Java常用API"><a href="#Java常用API" class="headerlink" title="Java常用API"></a>Java常用API</h1><p>API（<strong>A</strong>pplication <strong>P</strong>rogramming <strong>I</strong>nterface）：应用程序接口</p>
<p>API 文档是Java程序员的字典</p>
<blockquote>
<p>引用类型一般使用步骤：</p>
<p>​    1、导包：除了 java.lang 包下的内容不需要导包，其他包下的内容都需要使用 import 导入</p>
<p>​    2、创建：类名 对象变量名 = new 类名();</p>
<p>​    3、使用：对象变量名.成员方法名();</p>
</blockquote>
<h2 id="1、Scanner"><a href="#1、Scanner" class="headerlink" title="1、Scanner"></a>1、Scanner</h2><p>Scanner用于获取用户输入，它可以从文件、输入流、字符串中解析数据（使用不同的构造器可以将不同类型的数据作为数据源）</p>
<p>导包：<code>import java.util.Scanner;</code></p>
<p><code>System.in</code> 表示<strong>从键盘获取输入</strong></p>
<ul>
<li><p><code>Scanner sc = new Scanner(System.in);</code></p>
</li>
<li><p>从键盘获取int：<code>int a = sc.nextInt();</code></p>
</li>
<li><p>从键盘获取String：<code>String str = sc.next();</code></p>
</li>
</ul>
<p>也可用于<strong>读取文件内容</strong>：<code>Scanner scanner = new Scanner(new File(&quot;ScannerFileTest.java&quot;))</code></p>
<p>Scanner 主要提供两个方法来扫描输入：</p>
<ul>
<li>hasNextXxx(): 是否还有下一个输入项</li>
<li>nextXxx(): 获取下一个输入项</li>
</ul>
<blockquote>
<p>Scanner 的读取操作可能被<strong>阻塞</strong>，因为Scanner要等待信息的输入</p>
</blockquote>
<blockquote>
<p><strong>匿名对象：</strong>没有对象名，只是使用 new 来创建对象。</p>
<p>特点：匿名对象<strong>只能使用一次</strong>。</p>
<p>例：如果只想获取一次键盘输入，使用 Scanner 的匿名对象</p>
<ul>
<li><code>int num = new Scanner(System.in).nextInt();</code></li>
</ul>
</blockquote>
<h2 id="2、Random"><a href="#2、Random" class="headerlink" title="2、Random"></a>2、Random</h2><p>导包：<code>import java.util.Random;</code></p>
<p>创建：<code>Random r = new Random();</code></p>
<p>使用：</p>
<ul>
<li>（在整个int范围）获取一个随机的int：<code>int a = r.nextInt();</code></li>
<li>在 <strong>[0~i)</strong> 中获取一个随机的int：<code>int b = r.nextInt(int i);</code></li>
</ul>
<h2 id="3、ArrayList"><a href="#3、ArrayList" class="headerlink" title="3、ArrayList"></a>3、ArrayList</h2><p>导包：<code>java.util.ArrayList;</code></p>
<p>创建：<code>ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;();</code></p>
<blockquote>
<p> <strong>注意：</strong></p>
<p>泛型只能使用引用类型，不能使用基本数据类型</p>
<p>因为集合中只能放<strong>地址值</strong></p>
<p>要想往集合中存放数字、字符等，需要使用基本数据类型对应的<strong>包装类型</strong></p>
</blockquote>
<p>常用方法：</p>
<ul>
<li><code>public boolean add(E e);</code> –&gt; 添加元素,返回是否添加成功</li>
<li><code>public E get(int index)</code> –&gt; 根据索引获得元素，返回得到的元素</li>
<li><code>public E remove(int index);</code> –&gt; 根据索引删除元素，返回被删除的元素</li>
<li><code>public int size();</code> –&gt; 返回ArrayList的长度</li>
</ul>
<h2 id="4、String"><a href="#4、String" class="headerlink" title="4、String"></a>4、String</h2><blockquote>
<p>程序中出现的所有双引号字符串，都是String类的对象</p>
</blockquote>
<p>字符串的特点：</p>
<ul>
<li><p>字符串的内容永不变，所以字符串可以共享使用</p>
</li>
<li><p>字符串效果上是相当于 char[] 字符数组，但是<strong>底层原理是 byte[] 字节数组</strong></p>
</li>
</ul>
<p>字符串的创建方式（3+1）：</p>
<ul>
<li><p>3种构造方法创建：</p>
<ul>
<li><code>public String();</code> –&gt; 创建一个空的字符串</li>
<li><code>public String(char[] array)</code> –&gt; 根据字符数组创建字符串</li>
<li><code>public String(byte[] array)</code> –&gt; 根据字节数组创建字符串</li>
</ul>
</li>
<li><p>1种直接创建：</p>
<ul>
<li><code>String str = “Hello”；</code></li>
</ul>
</li>
</ul>
<blockquote>
<p> 直接创建的字符串位于 堆内存中的<strong>常量池</strong> 中</p>
<p>new 出来的字符串直接位于 <strong>堆内存</strong> 中</p>
</blockquote>
<p><img src="../images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%B8%B8%E9%87%8F%E6%B1%A0.png" alt=""></p>
<hr>
<p>字符串的比较：</p>
<blockquote>
<p>对于基本数据类型，== 是进行<strong>数值</strong>的比较</p>
<p>对于引用类型来说，== 是进行<strong>地址值</strong>的比较</p>
</blockquote>
<p>比较<strong>字符串内容</strong>的方法：</p>
<ul>
<li><code>public boolean equals(Object obj)</code><ul>
<li>如果比较双方一个常量一个变量，推荐使用 <code>&quot;abc&quot;.equals(str);</code> –&gt; 可预防空指针异常</li>
</ul>
</li>
<li><code>public boolean equalsIgnoreCase(String str)</code> –&gt; 忽略大小写比较字符串内容</li>
</ul>
<hr>
<ul>
<li><p>String 中与获取相关的方法：</p>
<ul>
<li><code>public int length();</code> –&gt; 获取字符串长度</li>
<li><code>public String concat(string str);</code> –&gt; 拼接字符串，返回一个新字符串</li>
<li><code>public char charAt(int index);</code> –&gt; 获取索引位置字符</li>
<li><code>public int indexOf(String str);</code> –&gt; 获取参数字符串在本字符串中首次出现的索引位置，没有返回 -1</li>
</ul>
</li>
<li><p>字符串的截取方法：</p>
<ul>
<li><code>public String substring(int index);</code> –&gt; 截取从 index 到字符串末尾，返回一个新字符串</li>
<li><code>public String substring(int begin, int end);</code> –&gt; 截取 <strong>[ begin, end )</strong> 之间的字符串，返回一个新字符串 </li>
</ul>
</li>
<li><p>与转换相关的方法：</p>
<ul>
<li><code>public char[] toCharArray();</code> –&gt; 将字符串转换成<strong>字符数组</strong>，并返回</li>
<li><code>public byte[] getBytes();</code> –&gt; 将字符串转换成<strong>字节数组</strong>，并返回（<em>IO流中常用</em>）</li>
<li><code>public String replace(charSequence oldString, charSequence newString);</code> –&gt; 将所有出现的老字符串替换成新字符串，并返回替换后的结果</li>
</ul>
</li>
<li><p>分割字符串的方法：</p>
<ul>
<li><code>public String[] split(String regex);</code> –&gt; 按照参数的规则，对字符串进行切分，返回一个字符串数组</li>
<li><strong>注意：</strong>正则表达式中有一些特殊字符需要转义后才能对字符串进行正常切分，如：<code>. --&gt; \\.</code></li>
</ul>
</li>
</ul>
<h2 id="5、static-关键字"><a href="#5、static-关键字" class="headerlink" title="5、static 关键字"></a>5、static 关键字</h2><p>静态成员属于类，所以在静态方法中<strong>不能使用 this</strong> </p>
<blockquote>
<p>静态不能直接访问非静态</p>
<p>因为：在内存中<strong>先</strong>有静态内容，<strong>后</strong>有非静态内容</p>
<p>正所谓：“先人不知道后人，后人知道先人”</p>
</blockquote>
<p><strong>静态的内存图：</strong></p>
<p><img src="/Users/pikachu/blog/source/images/%E9%9D%99%E6%80%81%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE.png" alt="静态的内存图"></p>
<p><img src="/Users/pikachu/blog/source/images/static_%E5%85%B3%E9%94%AE%E5%AD%97.JPG" alt="static_关键字"></p>
<p>静态代码块：**</p>
<ul>
<li>特点：<ul>
<li>在第一次用的本类时，静态代码块执行唯一一次</li>
<li>静态总是优先于非静态，故创建对象时，静态代码块先于构造方法执行</li>
</ul>
</li>
<li>典型用途：<ul>
<li>用于一次性的对静态成员变量进行赋值</li>
</ul>
</li>
</ul>
<h2 id="6、Arrays"><a href="#6、Arrays" class="headerlink" title="6、Arrays"></a>6、Arrays</h2><p><code>inport java.util.Arrays;</code></p>
<p>常用方法：</p>
<ul>
<li><code>public static String toString(数组)</code> –&gt; 将参数数组变成字符串（格式：[元素1, 元素2, 元素3]）</li>
<li><code>public static void sort(数组)</code> –&gt; 按照默认升序对数组元素进行排序</li>
</ul>
<h2 id="7、Math"><a href="#7、Math" class="headerlink" title="7、Math"></a>7、Math</h2><p><code>inport java.util.Math;</code></p>
<p>常用方法：</p>
<ul>
<li><code>public static double abs(double num);</code> –&gt; 获取绝对值</li>
<li><code>public static double ceil(double num);</code> –&gt; 向上取整</li>
<li><code>public static double floor(double num);</code> –&gt; 向下取整</li>
<li><code>public static long round(double num);</code> –&gt; 四舍五入  </li>
</ul>
<h2 id="8、main的签名-amp-system"><a href="#8、main的签名-amp-system" class="headerlink" title="8、main的签名 &amp; system"></a>8、main的签名 &amp; system</h2><h2 id="main-方法的签名"><a href="#main-方法的签名" class="headerlink" title="main 方法的签名"></a>main 方法的签名</h2><p>main 方法的签名：<code>public static void main(String[] args){}</code></p>
<p>使用该签名的原因：</p>
<ul>
<li>public：程序运行的入口是main方法，为了让JVM可以自由的调用main方法，所以要将main方法暴露出来</li>
<li>static：JVM 调用main方法时，直接通过类来调用，所以使用static修饰</li>
<li>void：将值返回给 JVM没有意义，故main方法使用void</li>
</ul>
<h2 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h2><p>System类代表<strong>当前Java程序运行的平台</strong></p>
<p>System中的变量和方法都为static</p>
<ul>
<li><p>提供了代表<strong>标准输入（System.in）</strong>、<strong>标准输出（System.out）</strong>、<strong>错误输出（System.err）</strong>的类变量</p>
</li>
<li><p>提供了获取系统当前时间的方法：<code>currentTimeMillis()</code>——毫秒为单位 和 <code>nonaTime()</code> —— 纳秒为单位</p>
</li>
<li><p>获取指定对象的精确hashCode值：<code>identityHashCode(object obj)</code></p>
<p>如果某个类的hashCode()方法被重写后，该类实例的hashCode()方法就不能唯一的标识该对象；</p>
<p>但是只要两个对象的identityHashCode值相同，则两个对象绝对是同一个对象</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java常用API</tag>
        <tag>String</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis</title>
    <url>/2019/04/28/Java/3.SSM%E6%A1%86%E6%9E%B6/MyBatis/</url>
    <content><![CDATA[<p>MyBatis 是一款优秀的持久层框架</p>
<a id="more"></a>

<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><blockquote>
<p>三层架构的概念:</p>
<ul>
<li>表现层：<pre><code>用于展示数据</code></pre></li>
<li>业务层：<pre><code>处理业务需求</code></pre></li>
<li>持久层：<pre><code>与数据库交互</code></pre></li>
</ul>
</blockquote>
<h2 id="MyBatis-概述："><a href="#MyBatis-概述：" class="headerlink" title="MyBatis 概述："></a><strong>MyBatis 概述：</strong></h2><p><strong>1、基本概念：</strong></p>
<p><strong>MyBatis</strong> 是一款<strong>持久层</strong>框架，由 Java 编写</p>
<p>它封装了 JDBC 操作的很多细节，使开发者只需要关注sql语句本身，而无需关注注册驱动，创建连接等繁杂过程</p>
<p>它使用了<strong>ORM思想</strong>实现了结果集的封装</p>
<blockquote>
<p><strong>ORM：</strong><br>        Object Relational Mappging 对象关系映射<br>        简单的说：<br>                就是把数据库表和实体类及实体类的属性对应起来<br>                让我们可以操作实体类就实现操作数据库表。</p>
<p><u>就是让类中的<strong>属性名</strong>称和数据库的<strong>列名</strong>相同</u></p>
</blockquote>
<p><strong>动态SQL</strong></p>
<p>动态SQL的作用是：查询时不确定是否有查询条件，可以用相关的标签 跟在查询语句后面来实现动态的SQL语句</p>
<p>标签：</p>
<ul>
<li><strong>if</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">select * from user where 1=1</span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span> = <span class="string">"username != null"</span>&gt;</span></span><br><span class="line">    and username = #&#123;username&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>where</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">select * from user</span><br><span class="line"><span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span> = <span class="string">"username != null"</span>&gt;</span></span><br><span class="line">        and username = #&#123;username&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span> = <span class="string">"address != null"</span>&gt;</span></span><br><span class="line">        and address = #&#123;address&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>foreach</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--相当于：select * from user where id in () --&gt;</span></span><br><span class="line">select * from user</span><br><span class="line"><span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"ids != null and ids.size() &gt; 0"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"ids"</span> <span class="attr">open</span>=<span class="string">"id in ( "</span> <span class="attr">close</span>=<span class="string">")"</span> <span class="attr">item</span>=<span class="string">"uid"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">            #&#123;uid&#125;  <span class="comment">&lt;!--大括号中的值与item属性的值一致--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>如果在映射配置文件中有出现次数较多的sql语句，可以使用sql标签把它提取出来</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--定义在mapper标签中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"selectUser"</span>&gt;</span></span><br><span class="line">       select * from user <span class="comment">&lt;!--此处不要加分号，因为别的语句调用它的时候可能会进行拼接，有分号会出错--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure>


</blockquote>
<h2 id="MyBatis-的基础使用"><a href="#MyBatis-的基础使用" class="headerlink" title="MyBatis 的基础使用"></a>MyBatis 的基础使用</h2><p>介绍使用maven来构建项目时，MyBatis该如何使用</p>
<p><strong>1、在maven的配置文件pom.xml中配置依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mybatis的依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- mysql的依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- log4j的依赖，用于打印日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- junit的依赖，用于单元测试 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>2、在main/java下，创建包：<code>com.pika.dao</code>，在包下创建UserDao接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pika.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询所有</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>3、在main/java下，创建包：<code>com.pika.domain</code>，在包下创建User类（封装数据库表查询结果的类）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pika.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 属性（属性名与数据库表的列名相同）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// getter&amp;setter</span></span><br><span class="line">    <span class="comment">// toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>4、在<strong>main/resource</strong>目录下，新建mybatis的<strong>主配置文件</strong>，通常命名为<strong>SqlMapConfig.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 环境配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 配置事务的类型 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 配置连接池 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql:///exam"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 映射文件的位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用xml配置文件时 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"com/pika/dao/UserDao.xml"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用注解时 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">"com.pika.dao.userDao"</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 使用别名的方式时，就不用配 mapper 了 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"cn.hellopika.dao"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>  MyBatis中DataSource的分类</p>
<ul>
<li><p>POOLED        –&gt; 使用“池”的概念创建连接</p>
</li>
<li><p>UNPOOLED  –&gt;  每次都新创建一个连接</p>
</li>
<li><p>JNDI               –&gt; 采用服务器提供的JNDI技术实现，获取DataSource对象  </p>
</li>
</ul>
</blockquote>
<p>5、在main/resource下，创建包：<code>com.pika.dao</code>，在包下创建<strong>UserDao.xml映射配置文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- namespace: 这个映射配置文件对应的dao --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.pika.dao.UserDao"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 查询所有 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- resultType: 结果集封装的实体类的全限定类名，如果配了别名可以直接写别名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultType</span>=<span class="string">"com.pika.domain.User"</span>&gt;</span></span><br><span class="line">        select * from user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>6、在test/Java下，创建测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 1.加载配置文件</span></span><br><span class="line">    InputStream in = Resources.getResourceAsStream(<span class="string">"SqlMapConfig.xml"</span>);</span><br><span class="line">    <span class="comment">// 2.创建工厂</span></span><br><span class="line">    SqlSessionFactoryBuilder builder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">    SqlSessionFactory factory = builder.build(in);</span><br><span class="line">    <span class="comment">// 3.获取SqlSession对象</span></span><br><span class="line">    SqlSession session = factory.openSession();</span><br><span class="line">    <span class="comment">// 4.创建dao代理对象</span></span><br><span class="line">    UserDao userdao = session.getMapper(UserDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 5.执行sql语句</span></span><br><span class="line">    List&lt;User&gt; users = userdao.findAll();</span><br><span class="line">    <span class="keyword">for</span> (User user:users) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.释放资源</span></span><br><span class="line">    session.close();</span><br><span class="line">    in.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>OGNL表达式：<code>#{}</code> 或 <code>${}</code></p>
<p>​    Object Graphic Navigation Language</p>
<p>它可以通过对象的getter方法来获取数据，在写法上把get给省略了</p>
<p>类中：<code>user.getUsername</code></p>
<p>表达式写法：<code>user.username</code></p>
</blockquote>
<p><strong>实体类属性名和数据库列名不一致时解决方法：</strong></p>
<p>在映射配置文件的<strong>mapper中添加resultMap标签</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置实体类属性名和数据库列名的对应关系--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- id可以任取，type为实体类的全限定类名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"userMap"</span> <span class="attr">type</span>=<span class="string">"com.pika.domain.User"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 主键字段的对应 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">""</span> <span class="attr">column</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 非主键字段的对应 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">""</span> <span class="attr">column</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">""</span> <span class="attr">column</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="properties标签、typeAliases标签、package标签"><a href="#properties标签、typeAliases标签、package标签" class="headerlink" title="properties标签、typeAliases标签、package标签"></a>properties标签、typeAliases标签、package标签</h3><p><strong>properties标签</strong>：定义主配置文件的configuration标签中</p>
<ul>
<li><p>可以直接在标签内部写连接数据库的信息</p>
</li>
<li><p>也可用于加载外部配置文件中的连接数据库的信息</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--属性：resource：指定外部配置文件的位置，按照类路径的写法来写--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"jdbc.properties"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt;</span></span><br><span class="line"><span class="comment">    &lt;property name="url" value="jdbc:mysql:///exam"/&gt;</span></span><br><span class="line"><span class="comment">    &lt;property name="username" value="root"/&gt;</span></span><br><span class="line"><span class="comment">    &lt;property name="password" value="root"/&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>typeAliases标签</strong>：定义在主配置文件的configuration标签中，使用typeAliases只能配置domain中类的别名</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--type属性是实体类的全限定类名，alias是别名，指定了别名之后就不再区分大小写了--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">"com.pika.domain.User"</span> <span class="attr">alias</span>=<span class="string">"user"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--指定要配置别名的包，指定之后该包下的所有实体类都会注册别名，类名就是别名，不再区分大小写--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.pika.domain"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>package标签</strong>：可以配置在typeAliases标签中以及mappers标签中</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--package标签指定dao接口所在的包，指定了之后mappers就算写完了，不再需要mapper标签以及resource或class--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.pika.dao"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h2 id="Mybatis对事务的管理"><a href="#Mybatis对事务的管理" class="headerlink" title="Mybatis对事务的管理"></a>Mybatis对事务的管理</h2><blockquote>
<p>Mybatis默认是开启事务的,也就是Mybatis中执行增删改操作时默认需要自己提交事务</p>
</blockquote>
<p>提交事务：SqlSession 对象的 commit() 方法</p>
<p>回滚事务：SqlSession 对象的 roolback() 方法</p>
<p>设置自动提交事务： SqlSession session = factory.openSession(true); // 在创建SQLSession对象时设置openSession的属性为true</p>
<h2 id="Mybatis的多表查询"><a href="#Mybatis的多表查询" class="headerlink" title="Mybatis的多表查询"></a>Mybatis的多表查询</h2><blockquote>
<p>mybatis 中把多对一的操作当成一对一</p>
</blockquote>
<h4 id="mybatis中一对一的查询"><a href="#mybatis中一对一的查询" class="headerlink" title="mybatis中一对一的查询:"></a>mybatis中一对一的查询:</h4><ol>
<li><p>在从表实体类中包含一个主表实体类 的对象引用</p>
</li>
<li><p>在从表的配置文件中配置resultMap</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--type: 从表的实体类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"accountUser"</span> <span class="attr">type</span>=<span class="string">"com.pika.domain.Account"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"aid"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"uid"</span> <span class="attr">column</span>=<span class="string">"uid"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"money"</span> <span class="attr">column</span>=<span class="string">"money"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--property: 从表实体类中的主表引用对象, column: 从表外键列, javaType: 主表实体类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"user"</span> <span class="attr">column</span>=<span class="string">"uid"</span> <span class="attr">javaType</span>=<span class="string">"com.pika.domain.User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"birthday"</span> <span class="attr">column</span>=<span class="string">"birthday"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"sex"</span> <span class="attr">column</span>=<span class="string">"sex"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"address"</span> <span class="attr">column</span>=<span class="string">"address"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="mybatis中一对多的查询"><a href="#mybatis中一对多的查询" class="headerlink" title="mybatis中一对多的查询:"></a>mybatis中一对多的查询:</h4><ol>
<li>在主表实体类中新建从表实体类的集合（List）</li>
<li>在主表的配置文件中配置resultMap</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"userAccountMap"</span> <span class="attr">type</span>=<span class="string">"com.pika.domain.User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"birthday"</span> <span class="attr">column</span>=<span class="string">"birthday"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"sex"</span> <span class="attr">column</span>=<span class="string">"sex"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"address"</span> <span class="attr">column</span>=<span class="string">"address"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- property: 从表的集合对象，ofType: 集合中的元素类型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"accounts"</span> <span class="attr">ofType</span>=<span class="string">"com.pika.domain.Account"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"aid"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"uid"</span> <span class="attr">column</span>=<span class="string">"uid"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"money"</span> <span class="attr">column</span>=<span class="string">"money"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="mybatis中多对多的查询"><a href="#mybatis中多对多的查询" class="headerlink" title="mybatis中多对多的查询:"></a>mybatis中多对多的查询:</h4><p>多对多查询  ==  双向一对多查询</p>
<h2 id="Mybatis的延迟加载"><a href="#Mybatis的延迟加载" class="headerlink" title="Mybatis的延迟加载"></a>Mybatis的延迟加载</h2><p>立即加载和延迟加载的概念</p>
<ul>
<li>立即加载：不管数据用不用，只要调用方法，马上发起查询<ul>
<li>一对一 、多对一（Mybatis中就是一对一）通常使用立即加载</li>
</ul>
</li>
<li>延迟加载：真正使用数据的时候才发起查询，按需加载（懒加载）<ul>
<li>一对多、多对多通常使用延迟加载</li>
</ul>
</li>
</ul>
<p>立即加载和延迟加载的实现方式：</p>
<ul>
<li><p>立即加载：多表查询时，直接在SQL语句中写内连接或外连接方式，就是立即加载</p>
</li>
<li><p>延迟加载：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--在主配置文件中开启延迟加载（默认就是开启的）--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 延迟加载的全局开关 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">&lt;!-- 开启后，任何方法的调用都会加载该对象的所有属性</span></span><br><span class="line"><span class="comment">          Mybatis 3.4.1 版本之后默认关闭 </span></span><br><span class="line"><span class="comment">      --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"aggressiveLazyLoading"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>一对一延迟加载的实现：查询所有账户，延迟加载账户的用户信息</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--在从表的resultMap中修改 association--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"accountUser"</span> <span class="attr">type</span>=<span class="string">"com.pika.domain.Account"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"aid"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"uid"</span> <span class="attr">column</span>=<span class="string">"uid"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"money"</span> <span class="attr">column</span>=<span class="string">"money"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--select:查询用户的唯一标识--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"user"</span> <span class="attr">column</span>=<span class="string">"uid"</span> <span class="attr">javaType</span>=<span class="string">"com.pika.domain.User"</span> <span class="attr">select</span>=<span class="string">"com.pika.dao.UserDao.findById"</span>&gt;</span><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultMap</span>=<span class="string">"accountUser"</span>&gt;</span></span><br><span class="line">    select * from account</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>一对多实现延迟加载</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--在主表的resultMap中修改 collection--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"userAccountMap"</span> <span class="attr">type</span>=<span class="string">"com.pika.domain.User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"birthday"</span> <span class="attr">column</span>=<span class="string">"birthday"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"sex"</span> <span class="attr">column</span>=<span class="string">"sex"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"address"</span> <span class="attr">column</span>=<span class="string">"address"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- property: 从表的集合对象，ofType: 集合中的元素类型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"accounts"</span> <span class="attr">ofType</span>=<span class="string">"com.pika.domain.Account"</span> <span class="attr">select</span>=<span class="string">"com.pika.dao.AccountDao.findByUid"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultMap</span>=<span class="string">"userAccountMap"</span>&gt;</span></span><br><span class="line">    select * from user;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>





</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Mybatis中的缓存"><a href="#Mybatis中的缓存" class="headerlink" title="Mybatis中的缓存"></a>Mybatis中的缓存</h2><p><strong>缓存的概念：</strong>存在于内存中的临时数据</p>
<p><strong>为什么使用缓存：</strong>减少和数据库的交互次数，提高执行效率</p>
<p><strong>什么样的数据能使用缓存：</strong>经常查询、不经常修改、数据的对错对最终结果影响不大</p>
<p><strong>Mybatis中的一级缓存和二级缓存：</strong></p>
<ul>
<li><p>一级缓存：</p>
<ul>
<li><p>概念：</p>
<p>指的是SQLSession对象的缓存，执行查询之后，查询结果会同时存入一级缓存中，一级缓存的结构是一个Map，再次查询同样的数据时，Mybatis会先去一级缓存中找是否有，有的话直接拿来用。</p>
<p>SqlSession对象消失时，Mybatis的一级缓存也就消失了</p>
</li>
<li><p>一级缓存的清空：</p>
<p>当调用SQLSession的 修改、添加、删除、commit()、close()、clearCache() 等方法时，就会清空一级缓存。（当执行增删改操作时，一级缓存会自动同步）</p>
</li>
</ul>
</li>
<li><p>二级缓存：</p>
<ul>
<li><p>概念：</p>
<p>指的是SQLSessionFactory对象的缓存，由同一个SQLSessionFactory对象创建的SQLSession共享其缓存</p>
</li>
<li><p>二级缓存的使用步骤：</p>
<ol>
<li><p>让Mybatis框架支持二级缓存</p>
<p>在 SqlMapConfig.xml 中配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"True"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ul>
</li>
</ul>
<pre><code>2. 让当前的映射文件支持二级缓存

   在 UserDao.xml 中配置：直接在 mapper 中添加`&lt;cache/&gt;`

3. 让当前的操作支持二级缓存

   在 select 标签中配置：在 select 标签中添加属性 `useCache=“true”`</code></pre><ul>
<li><blockquote>
<p>二级缓存中存放的是数据而不是对象</p>
</blockquote>
</li>
</ul>
<h2 id="Mybatis的注解开发"><a href="#Mybatis的注解开发" class="headerlink" title="Mybatis的注解开发"></a>Mybatis的注解开发</h2><blockquote>
<p> 使用注解代替Dao的映射配置文件，但是Mybatis的主配置文件是不动的</p>
</blockquote>
<p>增删改查对应的注解：<code>@insert, @delete, @update, @select</code></p>
<p><strong>注解的基本使用方式：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询所有</span></span><br><span class="line">    <span class="meta">@select</span>(<span class="string">"select * from user"</span>)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>使用注解配置实体类属性名和表的列名对应关系：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询所有用户(实体类属性名和表的列名不一致的情况)</span></span><br><span class="line">    <span class="meta">@select</span>(<span class="string">"select * from user"</span>)</span><br><span class="line">    <span class="meta">@Results</span>(id=<span class="string">"userMap"</span>, value=&#123;</span><br><span class="line">        	<span class="meta">@Result</span>(id=<span class="keyword">true</span>, property=<span class="string">"userId"</span>, column=<span class="string">"id"</span>),</span><br><span class="line">        	<span class="meta">@Result</span>(property=<span class="string">"userName"</span>, column=<span class="string">"username"</span>),</span><br><span class="line">        	<span class="meta">@Result</span>(property=<span class="string">"userAddress"</span>, column=<span class="string">"address"</span>),</span><br><span class="line">        	<span class="meta">@Result</span>(property=<span class="string">"userSex"</span>, column=<span class="string">"sex"</span>),</span><br><span class="line">        	<span class="meta">@Result</span>(property=<span class="string">"userBirthday"</span>, column=<span class="string">"birthday"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>注解开发一对一查询配置：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询所有账户(并查询每个账户所属的用户)</span></span><br><span class="line">    <span class="meta">@select</span>(<span class="string">"select * from account"</span>)</span><br><span class="line">    <span class="meta">@Results</span>(id=<span class="string">"accountMap"</span>, value=&#123;</span><br><span class="line">        <span class="meta">@Result</span>(id=<span class="keyword">true</span>, property=<span class="string">"id"</span>, column=<span class="string">"id"</span>),</span><br><span class="line">        <span class="meta">@Result</span>(property=<span class="string">"uid"</span>, column=<span class="string">"uid"</span>),</span><br><span class="line">        <span class="meta">@Result</span>(property=<span class="string">"money"</span>, column=<span class="string">"money"</span>),</span><br><span class="line">        <span class="meta">@Result</span>(property=<span class="string">"user"</span>, column=<span class="string">"uid"</span>, one=<span class="meta">@One</span>(select=<span class="string">"com.pika.dao.UserDao.findById"</span>, fetchType=FetchType.EAGER))</span><br><span class="line">    &#125;) <span class="comment">// fetchType：立即加载还是延迟加载</span></span><br><span class="line">    <span class="function">List&lt;Acount&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>注解开发一对多查询配置：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询所有(实体类属性名和表的列名不一致的情况)</span></span><br><span class="line">    <span class="meta">@select</span>(<span class="string">"select * from user"</span>)</span><br><span class="line">    <span class="meta">@Results</span>(id=<span class="string">"userMap"</span>, value=&#123;</span><br><span class="line">        <span class="meta">@Result</span>(id=<span class="keyword">true</span>, property=<span class="string">"userId"</span>, column=<span class="string">"id"</span>),</span><br><span class="line">        <span class="meta">@Result</span>(property=<span class="string">"userName"</span>, column=<span class="string">"username"</span>),</span><br><span class="line">        <span class="meta">@Result</span>(property=<span class="string">"userAddress"</span>, column=<span class="string">"address"</span>),</span><br><span class="line">        <span class="meta">@Result</span>(property=<span class="string">"userSex"</span>, column=<span class="string">"sex"</span>),</span><br><span class="line">        <span class="meta">@Result</span>(property=<span class="string">"userBirthday"</span>, column=<span class="string">"birthday"</span>),</span><br><span class="line">        <span class="meta">@Result</span>(property=<span class="string">"accounts"</span>, column=<span class="string">"id"</span>, many=<span class="meta">@Many</span>(select=<span class="string">"com.pika.dao.AccountDao.findAccountByUid"</span>, fetchType=FetchType.LAZY))</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven</title>
    <url>/2019/04/28/Java/Maven/</url>
    <content><![CDATA[<p>Maven 是一款 Java 项目的自动化构建工具</p>
<a id="more"></a>

<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><p><strong>maven的功能</strong></p>
<ul>
<li>依赖管理</li>
<li>一键构建</li>
</ul>
<p>构建的概念：**以“Java源文件” 、 “框架配置文件” 、“HTML” 、“图片” 等资源为 “原材料”，去 “生产” 一个可运行项目的过程</p>
<p><strong>构建过程中的各个环节：</strong></p>
<ul>
<li>清理：将以前编译得到的旧的 class 字节码文件删除，为下一次编译做准备</li>
<li>编译：将 Java 源程序编译成 class 字节码文件</li>
<li>测试：自动调用 <strong>Junit</strong> 程序进行测试</li>
<li>报告：返回测试程序执行的结果</li>
<li>打包：<strong>动态Web程序打 .war 包，Java 工程打 .jar 包</strong></li>
<li>安装：Maven特定的概念 –&gt; 将打包得到的文件复制到“仓库”中的指定位置</li>
<li>部署：将 .war 包复制到指定 Servlet 容器中，使其可以运行</li>
</ul>
<p><strong>Maven的常用命令：</strong></p>
<ul>
<li>mvn clean：清理</li>
<li>mvn compile：编译主程序</li>
<li>mvn test-compile：编译测试程序</li>
<li>mvn test：执行测试</li>
<li>mvn package：打包</li>
<li>mvn install：安装</li>
<li>mvn site：生成站点</li>
</ul>
<h2 id="Maven的核心概念"><a href="#Maven的核心概念" class="headerlink" title="Maven的核心概念"></a>Maven的核心概念</h2><p>1、<strong>约定的目录结构</strong></p>
<p>2、<strong>POM</strong></p>
<p>3、<strong>坐标</strong></p>
<p>4、<u><strong>依赖</strong></u></p>
<p>5、仓库</p>
<p>6、生命周期/插件/目标</p>
<p>7、继承</p>
<p>8、聚合</p>
<hr>
<p><strong>约定的目录结构：</strong></p>
<blockquote>
<ul>
<li>Hello –&gt; 项目名<ul>
<li>src –&gt; 源码<ul>
<li>main –&gt; 主程序<ul>
<li>java –&gt; 存放 Java 源文件</li>
<li>resources –&gt; 存放框架或其他工具的配置文件</li>
</ul>
</li>
<li>text –&gt; 测试程序<ul>
<li>java</li>
<li>resources</li>
</ul>
</li>
</ul>
</li>
<li>pom.xml –&gt; Maven 工程的核心配置文件</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>POM：</strong></p>
<p>Project Object Model –&gt; 项目对象模型</p>
<p>pom.xml 是 Maven 工程的核心配置文件，与构建过程相关的一切设置都在这个文件中进行配置</p>
<p><strong>坐标：</strong></p>
<p>使用三个向量在仓库中唯一定位一个 Maven 工程</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupid</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupid</span>&gt;</span> <span class="comment">&lt;!-- 公司或组织域名倒序 + 项目名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactid</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactid</span>&gt;</span> <span class="comment">&lt;!-- 模块名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile/provided/runtime/test/system/import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span><span class="comment">&lt;!--限定该依赖的作用范围--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">	上述坐标对应的文件路径：</span></span><br><span class="line"><span class="comment">	org/springframework/spring-core/4.0.0.RELEASE/spring-core-4.0.0.RELEASE.jar</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>依赖：</strong></p>
<p>在pom.xml中放置项目所依赖的jar包的坐标，便是依赖管理</p>
<p><strong>仓库：</strong></p>
<ul>
<li><p>仓库的分类：</p>
<ul>
<li>本地仓库</li>
<li>远程仓库<ul>
<li>私服：位于局域网中的仓库</li>
<li>中央仓库：位于互联网上的仓库</li>
<li>中央仓库镜像：为了分担中央仓库流量</li>
</ul>
</li>
</ul>
</li>
<li><p>仓库中存储的内容：Maven 工程</p>
<ul>
<li>Maven 自身所需的插件</li>
<li>第三方框架或工具的 jar 包</li>
<li>自己开发的 Maven 工程</li>
</ul>
</li>
</ul>
<p><strong>生命周期：</strong>（在执行后面的明亮的时候会把前面的命令执行一遍）</p>
<ul>
<li>清理生命周期<ul>
<li>clean命令单独的就是一个生命周期</li>
</ul>
</li>
<li>默认生命周期<ul>
<li>编译</li>
<li>测试</li>
<li>打包</li>
<li>安装</li>
<li>发布</li>
</ul>
</li>
<li>站点生命周期<ul>
<li>实际开发中不常用</li>
</ul>
</li>
</ul>
<h2 id="maven高级"><a href="#maven高级" class="headerlink" title="maven高级"></a>maven高级</h2><h3 id="1、jar包冲突"><a href="#1、jar包冲突" class="headerlink" title="1、jar包冲突"></a>1、jar包冲突</h3><p>maven在导入jar包坐标时，如果导入的jar包与其他导入的jar包的依赖包相同但版本号不同，就会产生jar包冲突的问题</p>
<p><strong>解决jar包冲突的方式有三种：</strong></p>
<ul>
<li><p>方式一：</p>
<pre><code>**第一声明优先原则**：哪个jar包的坐标在靠上的位置，这个jar包就是先声明的。
先声明的jar包坐标下的依赖包，可以优先进入项目中。</code></pre></li>
<li><p>方式二：<br>  <strong>路径近者优先原则</strong>。直接依赖路径比传递依赖路径近，那么最终项目进入的jar包会是路径近的直接依赖包。</p>
<ul>
<li>直接依赖与传递依赖的概念：<br>  直接依赖：项目中直接导入的jar包，就是该项目的直接依赖包。<br>  传递依赖：项目中没有直接导入的jar包，可以通过项目直接依赖jar包传递到项目中去。</li>
</ul>
</li>
<li><p>方式三【<strong>推荐使用</strong>】：<br>  <strong>直接排除法</strong>（<strong>使用exclusions标签</strong>）。<br>  当我们要排除某个jar包下依赖包，在配置exclusions标签的时候，内部可以不写版本号。<br>  因为此时依赖包使用的版本和默认和本jar包一样。</p>
</li>
</ul>
<h3 id="2、pom-xml中的相关标签"><a href="#2、pom-xml中的相关标签" class="headerlink" title="2、pom.xml中的相关标签"></a>2、pom.xml中的相关标签</h3><p><code>&lt;properties&gt;</code>：里面定义一些键值对，可用于统一管理jar包版本</p>
<p><code>&lt;dependencyManagement&gt;</code>：用于锁定jar包版本</p>
<ul>
<li>注意：该标签中所写的jar包仅用于锁定jar包版本，不能导入jar包</li>
</ul>
<blockquote>
<p>锁定jar包版本的作用：</p>
<p>当jar包版本被锁定后，如有其它从Maven工程依赖当前Maven工程，那么即使其它的工程中的jar包与当前工程冲突，当前工程被锁定的jar包也不会被覆盖</p>
</blockquote>
<blockquote>
<p>idea创建maven项目时解决创建速度慢的一个小技巧:</p>
<p>添加一对key-value</p>
<ul>
<li>key:  archetypeCatalog</li>
<li>value:  internal</li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/2019/04/25/Java/3.SSM%E6%A1%86%E6%9E%B6/Spring/</url>
    <content><![CDATA[<p>Spring 的核心：IOC &amp; AOP</p>
<a id="more"></a>

<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p><strong>核心功能：</strong></p>
<ul>
<li><strong>IoC</strong> (Inversion of Control)：控制反转</li>
<li><strong>AOP</strong> (Aspect Oriented Programming)：面向切面编程</li>
</ul>
<blockquote>
<p>耦合：程序间的依赖关系</p>
<ul>
<li>类之间的依赖关系</li>
<li>方法之间的依赖关系</li>
</ul>
<p>解耦：降低程序间的依赖关系</p>
<p>实际开发中应该：编译时不依赖，运行时依赖</p>
<p>解耦的思路</p>
<ul>
<li>第一步：使用反射创建对象，而避免使用 new 关键字</li>
<li>第二步：通过读配置文件来获取要创建对象的全限定类名</li>
</ul>
</blockquote>
<h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><p>控制反转：</p>
<ul>
<li>控制：控制对象</li>
<li>反转：转交给Spring负责</li>
</ul>
<p>IoC的作用：创建和管理对象</p>
<p>IoC的最大优点：解耦（解<strong>程序员</strong>与<strong>对象管理</strong>之间的耦合）</p>
<h4 id="怎么使用IOC"><a href="#怎么使用IOC" class="headerlink" title="怎么使用IOC"></a>怎么使用IOC</h4><ol>
<li><p>创建对象</p>
<p> maven工程中，在<code>resource</code>目录下创建<code>applicationContext.xml</code>配置文件</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">     https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 通过bean标签来创建对象，默认在配置文件被加载时创建对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"peo1"</span> <span class="attr">class</span>=<span class="string">"com.pika.sxt.People"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用对象</p>
<ul>
<li><p>通过依赖注入使用对象</p>
</li>
<li><p>从容器中获取对象</p>
<ul>
<li><p>Spring 的核心容器：ApplicationContext  –&gt;  它是一个接口，有三个常用实现类</p>
<ul>
<li>ClassPathXmlApplicationContext：加载<strong>类路径</strong>下的配置文件</li>
<li>FileSystemXmlApplicationContext：加载<strong>磁盘任意路径</strong>的配置文件</li>
<li>AnnotationConfigApplicationContext：读取<strong>注解</strong>创建容器</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="创建对象的三种方式："><a href="#创建对象的三种方式：" class="headerlink" title="创建对象的三种方式："></a>创建对象的三种方式：</h4><p><strong>1、通过构造方法创建</strong></p>
<ul>
<li><p>无参构造方法创建：为默认情况</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"peo1"</span> <span class="attr">class</span>=<span class="string">"com.pika.sxt.People"</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>有参构造方法创建：需要明确配置</p>
<p>使用有参构造方法创建对象，只需要在配置文件中新建<code>&lt;bean&gt;&lt;/bean&gt;</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"peo1"</span> <span class="attr">class</span>=<span class="string">"com.pika.sxt.People"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  </span></span><br><span class="line"><span class="comment">		index：	参数的索引，从0开始</span></span><br><span class="line"><span class="comment">		name：	参数名</span></span><br><span class="line"><span class="comment">		type：	参数类型（要区分基本数据类型和包裹数据类型）		</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">type</span>=<span class="string">"int"</span> <span class="attr">value</span>=<span class="string">"8"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"pika"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<p><strong>2、实例工厂创建</strong></p>
<p>特点：需要先创建工厂，才能生产对象</p>
<ul>
<li><p>第一步：创建一个实例工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeopleFactory</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> People <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> People();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二步：在配置文件中配置工厂对象和需要创建的对象</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"factory"</span> <span class="attr">class</span>=<span class="string">"com.pika.sxt.PeopleFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"peo2"</span> <span class="attr">factory-bean</span>=<span class="string">"factory"</span> <span class="attr">factory-method</span>=<span class="string">"newInstance"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<p><strong>3、静态工厂创建</strong></p>
<p>特点：不需要创建工厂bean，快速创建对象</p>
<ul>
<li><p>第一步：创建一个静态工厂(在实例工厂的方法前面加上 static )</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeopleFactory</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> People <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> People();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二步：在配置文件中创建对象</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"peo2"</span> <span class="attr">class</span>=<span class="string">"com.pika.sxt.PeopleFactory"</span> <span class="attr">factory-method</span>=<span class="string">"newInstance"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h4 id="Bean的作用范围："><a href="#Bean的作用范围：" class="headerlink" title="Bean的作用范围："></a>Bean的作用范围：</h4><p>使用bean标签中的<strong>scope属性</strong>调整bean的作用范围</p>
<p>scope属性的取值：</p>
<ul>
<li><strong>singleton</strong> –&gt; 单例的（默认）</li>
<li><strong>prototype</strong> –&gt; 多例的</li>
<li><strong>request</strong> –&gt; 作用于web应用的请求范围</li>
<li><strong>session</strong> –&gt; 作用于web应用的会话范围</li>
<li><strong>global-session</strong> –&gt; 作用于集群环境的会话范围（全局会话范围）</li>
</ul>
<hr>
<h4 id="Bean的生命周期："><a href="#Bean的生命周期：" class="headerlink" title="Bean的生命周期："></a>Bean的生命周期：</h4><ul>
<li>单例对象<ul>
<li>随着容器的创建而创建，随着容器的销毁而销毁</li>
</ul>
</li>
<li>多例对象<ul>
<li>当我们使用对象时创建，当对象长时间不用时，由GC自动回收销毁</li>
</ul>
</li>
</ul>
<hr>
<h4 id="DI"><a href="#DI" class="headerlink" title="DI"></a><strong>DI</strong></h4><p><strong>DI：</strong>(Dependency Injection)：<strong>依赖注入</strong></p>
<p><strong>概念：</strong>当一个类（A）中需要依赖另一个类（B）的对象时，将 B 的对象赋值给 A 的属性的过程称为依赖注入。</p>
<hr>
<p><strong>能注入的数据有三类：</strong></p>
<ul>
<li>基本类型和String</li>
<li>其他bean类型</li>
<li>集合类型/复杂类型</li>
</ul>
<hr>
<h4 id="注入的方式有三种："><a href="#注入的方式有三种：" class="headerlink" title="注入的方式有三种："></a>注入的方式有三种：</h4><ul>
<li><p>通过<strong>构造方法</strong>注入</p>
<ul>
<li>在 bean 标签内部使用 <strong>constructor-arg</strong> 标签</li>
<li>constructor-arg 标签的<strong>属性</strong>：<ul>
<li>type：用于指定要注入的<strong>数据类型</strong>，该数据类型也是构造函数中某个或某些参数的类型</li>
<li>index：用于指定要注入的数据给构造函数中<strong>指定索引位置</strong>的参数赋值，索引从 0 开始</li>
<li>name：用于指定构造函数中要赋值的参数名称    <strong>—- 常用方式 —-</strong></li>
<li>value：用于提供基本类型和String类型的数据</li>
<li>ref：用于指定其他的bean类型数据，它指的是核心容器中出现过的bean</li>
</ul>
</li>
<li><strong>优势：</strong>在获取bean对象时，必须传入数据，否则无法创建成功</li>
<li><strong>劣势：</strong>即使用不到某些数据，也必须传入</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"now"</span> <span class="attr">class</span>=<span class="string">"java.util.Date"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"peo1"</span> <span class="attr">class</span>=<span class="string">"com.pika.sxt.People"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"8"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"pika"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor</span> <span class="attr">name</span>=<span class="string">"date"</span> <span class="attr">ref</span>=<span class="string">"now"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>通过<strong>set方法</strong>注入</p>
<ul>
<li><p>在 bean 标签内部使用 <strong>property</strong> 标签</p>
</li>
<li><p>property 标签的属性：</p>
<ul>
<li>name：用于指定注入时所调用的set方法的名称（setName –&gt; name）</li>
<li>value：用于提供基本类型和String类型的数据</li>
<li>ref： 用于指定其他的bean类型数据，它指的是核心容器中出现过的bean</li>
</ul>
</li>
<li><p>优势：创建对象时没有明确限制，可以直接使用默认构造函数</p>
</li>
<li><p>劣势：如果有某个成员必须有值，则set方法无法保证一定注入值</p>
<ul>
<li><p>属性是基本数据类型或String等简单的引用类型</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"peo1"</span> <span class="attr">class</span>=<span class="string">"com.pika.sxt.People"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"23"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"张三三"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 下面这种赋值的效果等同于上面 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>18<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>李四四<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果属性是其他bean类型</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- People 类依赖SmartPhone类，将SmartPhone类的对象注入到People类中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"peo"</span> <span class="attr">class</span>=<span class="string">"com.pika.sxt.People"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sp"</span> <span class="attr">ref</span>=<span class="string">"phone"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>   </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"phone"</span> <span class="attr">class</span>=<span class="string">"com.pika.sxt.SmartPhone"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"size"</span> <span class="attr">value</span>=<span class="string">"5.5"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"price"</span> <span class="attr">value</span>=<span class="string">"6399"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果属性是集合 set&lt;?&gt;</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"set1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>a<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>b<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>c<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>d<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果属性是 List&lt;?&gt;</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"list1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>aa<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>bb<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>cc<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>dd<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- 如果list中只有一个值 (重要)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"list1"</span> <span class="attr">value</span>=<span class="string">"aa"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果属性是数组</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"strs"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>ddd<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果属性是<code>Map&lt;?,?&gt;</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"map1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"a"</span> <span class="attr">value</span>=<span class="string">"aa"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"b"</span> <span class="attr">value</span>=<span class="string">"bb"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"c"</span> <span class="attr">value</span>=<span class="string">"cc"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果属性是properties</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"demo"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"key1"</span>&gt;</span>value1<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"key2"</span>&gt;</span>value2<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>用于给List结构的集合类型注入的标签：list，array，set<br>用于给Map结构的集合类型注入的标签：map，props</p>
</blockquote>
<hr>
<h3 id="IOC基于注解配置："><a href="#IOC基于注解配置：" class="headerlink" title="IOC基于注解配置："></a>IOC基于注解配置：</h3><p>IOC常用注解：</p>
<ul>
<li>用于<u>创建对象</u>的<ul>
<li><code>@Component</code><ul>
<li>默认创建出的对象的id为：类名首字母改小写。</li>
<li>可使用value属性自定义名称：<code>@Component(value=&quot;自定义名称&quot;)</code>，value可省略</li>
</ul>
</li>
<li><em>以下三个注解和Component作用完全一样，他们是Spring为我们提供三层架构的注解</em></li>
<li><code>@Controller</code>：一般用在表现层</li>
<li><code>@Service</code>：一般用在业务层</li>
<li><code>@Repository</code>：一般用在持久层</li>
</ul>
</li>
<li>用于<u>注入数据</u>的<ul>
<li><code>@AutoWired</code>：自动<strong>按照类型</strong>注入</li>
<li><code>@Qualifier</code>：在按照类型注入的基础上再<strong>按照名称</strong>注入<ul>
<li>在给类成员注入时<strong>无法单独使用</strong>（需配合AutoWired使用），但在给方法参数注入时可以单独使用</li>
</ul>
</li>
<li><code>@Resource</code>：直接按照bean的id注入，可以单独使用<ul>
<li>属性：name，用于指定bean的id</li>
</ul>
</li>
<li><em>以上三个注解都只能注入其他bean类型的数据，无法注入基本数据类型和String类型，且集合类型的注入只能通过XML来实现</em></li>
<li><code>@Value</code>：用于注入基本数据类型和String类型<ul>
<li>属性：value –&gt; 用于指定属性的值，可以使用SpEl 表达式（Spring中的el表达式）<ul>
<li>SpEl 的写法：${表达式}</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>用于<u>改变作用范围</u>的<ul>
<li><code>@Scope</code>：用于指定bean的作用范围<ul>
<li>属性：value –&gt; 常用取值：singleton，prototype</li>
</ul>
</li>
</ul>
</li>
<li>和<u>生命周期相关</u>的<ul>
<li><code>@PostConstruct</code>：用于指定初始化方法</li>
<li><code>@PreDestory</code>：用于指定销毁方法</li>
</ul>
</li>
</ul>
<p><strong>在有配置文件的情况下如何使用注解：</strong></p>
<ul>
<li><p>先在相应位置添加注解，然后在配置文件中告诉Spring在创建容器时要扫描的包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">&lt;!-- 使用该标签配置要扫描的包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"cn.hellopika"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>





</li>
</ul>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>面向切面编程的概念：</p>
<p>​        在程序原有纵向执行流程中，针对某一个或某一些方法添加通知，形成横切面的过程就叫做面向切面编程。</p>
<p><strong>常用概念：</strong></p>
<ul>
<li>原有功能（方法）：切点，pointcut</li>
<li>前置通知：在切点之前执行的功能，before advice</li>
<li>后置通知：在切点之后执行的功能，after advice</li>
<li>异常通知：切点执行过程中出现异常，会触发异常通知，throw advice</li>
<li>切面：前置通知+切点+后置通知</li>
<li>织入：把切面嵌入到原有功能的过程</li>
</ul>
<h3 id="AOP-的实现"><a href="#AOP-的实现" class="headerlink" title="AOP 的实现"></a>AOP 的实现</h3><p>实现前置、后置、异常、最终通知</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在java类中配置相应的通知</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Aspect</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"前置通知"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myAfterReturning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"后置通知"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"异常通知"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myAfter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"最终通知"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置切面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"Aspect"</span> <span class="attr">class</span>=<span class="string">"com.pika.aspect.Aspect"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置AOP --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"Aspect"</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(* com.pika.sxt.Demo.demo01())"</span> <span class="attr">id</span>=<span class="string">"mypointcut"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"myBefore"</span> <span class="attr">pointcut-ref</span>=<span class="string">"mypointcut"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">"myAfterReturning"</span> <span class="attr">pointcut-ref</span>=<span class="string">"mypointcut"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">"myException"</span> <span class="attr">pointcut-ref</span>=<span class="string">"mypointcut"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"myAfter"</span> <span class="attr">pointcut-ref</span>=<span class="string">"mypointcut"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="使用注解配置AOP"><a href="#使用注解配置AOP" class="headerlink" title="使用注解配置AOP"></a>使用注解配置AOP</h3><p>几种常用注解：</p>
<ul>
<li><code>@Component</code><ul>
<li>相当于<code>&lt;bean/&gt;</code></li>
<li>如果注解中没有参数，会把类名的首字母变成小写后，作为 bean 的 id</li>
<li>自定义名称方式：<code>@Component(&quot;自定义名称&quot;)</code></li>
</ul>
</li>
<li><code>@Aspect</code><ul>
<li>相当于<code>&lt;aop:aspect&gt;&lt;/aop:aspect&gt;</code>标签</li>
</ul>
</li>
<li><code>@Pointcut</code><ul>
<li>用法：<code>@Pointcut(&quot;execution(* com.pika.sxt.Demo.demo01())&quot;)</code></li>
</ul>
</li>
<li><code>@Before</code><ul>
<li>用法：<code>@Before(&quot;com.pika.sxt.Demo.demo01()&quot;)</code>, <strong>下同</strong></li>
</ul>
</li>
<li><code>@AfterReturning</code></li>
<li><code>@AfterThrowing</code></li>
<li><code>@After</code></li>
</ul>
<p>配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">                http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">                http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"myadvice, com.pika.sxt"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment"> 		proxy-target-class</span></span><br><span class="line"><span class="comment">		true:使用 cglib 动态代理</span></span><br><span class="line"><span class="comment">		false:使用 jdk 动态代理</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"demo"</span> <span class="attr">class</span>=<span class="string">"com.pika.sxt.Demo"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>Demo类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Pointcut</span>(<span class="string">"execution(* com.pika.sxt.Demo.demo01())"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"demo01"</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>通知类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAdvice</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"com.pika.sxt.Demo.demo01()"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"前置通知"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="meta">@AfterReturning</span>(<span class="string">"com.pika.sxt.Demo.demo01()"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myAfter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"后置通知"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="meta">@AfterThrowing</span>(<span class="string">"com.pika.sxt.Demo.demo01()"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"异常通知"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"com.pika.sxt.Demo.demo01()"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"最终通知"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="自动注入的配置"><a href="#自动注入的配置" class="headerlink" title="自动注入的配置"></a>自动注入的配置</h3><p>两种配置方法：</p>
<ul>
<li>在<code>&lt;bean&gt;</code>中通过<code>autowire=&quot;&quot;</code>进行配置，只对当前<code>&lt;bean&gt;</code>生效</li>
<li>在<code>&lt;beans&gt;</code>中通过<code>default-autowire=&quot;&quot;</code>配置，对配置文件中的所有<code>&lt;bean&gt;</code>都生效</li>
</ul>
<p><code>autowire=&quot;&quot;</code>的取值：</p>
<ul>
<li><p>default：默认值，在<code>&lt;bean&gt;</code>中配置的默认值为全局<code>default-autowire=&quot;&quot;</code>的值，如果在全局和局部都没有配置的情况下，相当于no</p>
</li>
<li><p>no：不自动注入</p>
</li>
<li><p>byName：根据名称匹配进行自动注入</p>
</li>
<li><p>byType：根据类型匹配自动注入</p>
<blockquote>
<p>使用 byType 时在 Spring 容器中不能出现两个相同类型的<code>&lt;bean&gt;</code></p>
</blockquote>
</li>
</ul>
<ul>
<li>constructor：根据构造方法进行自动注入<ul>
<li>提供对应参数的构造方法</li>
<li>底层使用的时 byName，匹配的是构造方法的参数名</li>
</ul>
</li>
</ul>
<h2 id="Spring-新注解"><a href="#Spring-新注解" class="headerlink" title="Spring-新注解"></a>Spring-新注解</h2><p>如果想要完全使用注解配置Spring的IOC，就需要使用一些其他的注解</p>
<blockquote>
<p>完全使用注解配置Spring的IOC的步骤：</p>
<p>1、首先，需要新建一个配置类，把需要配置的内容都放到配置类中</p>
<p>2、创建容器时，使用 <code>AnnotationConfigApplicationContext(配置类名.class)</code> 实现类</p>
</blockquote>
<ul>
<li><code>@Configuration</code><ul>
<li>作用：指定当前类为一个配置类</li>
<li>细节：当配置类作为 AnnotationConfigApplicationContext 的参数时，该注解可以不写</li>
</ul>
</li>
<li><code>@ComponentScan(“包名”)</code><ul>
<li>作用：用于通过注解指定Spring在创建容器时要扫描的包</li>
<li>属性：value，basePackages， 两个属性其实是一样的。</li>
</ul>
</li>
<li><code>@Bean</code><ul>
<li>作用：用于把当前<strong>方法的返回值</strong>作为bean对象，存入Spring的IOC容器中</li>
<li>属性：name –&gt; 用于指定bean的id，如果不写，<strong>默认是方法的名称</strong></li>
<li>细节：使用注解配置时，如果方法有参数，Spring会去容器中查找有没有可用的bean对象，查找的方式和Autowired注解一样</li>
</ul>
</li>
<li><code>@Import(配置类名.class)</code><ul>
<li>作用：如果有多个配置类时，<strong>将其他的配置类导入主配置类</strong>中使用该注解</li>
<li>细节：被导入的配置类不需要使用 @configuration 注解</li>
</ul>
</li>
<li><code>@propertySource(配置文件路径及名称 例 &quot;classpath:jdbcConfig.properties&quot;)</code><ul>
<li>作用：用于指定 properties 文件的位置</li>
<li>classpath：表示在类路径下</li>
</ul>
</li>
</ul>
<blockquote>
<p>PS：注解和xml配置方式的选择：</p>
<p>使用注解和xml相结合的方式是最优选择</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC</title>
    <url>/2019/04/18/Java/1.Java%E5%9F%BA%E7%A1%80/JDBC/</url>
    <content><![CDATA[<p>Java数据库连接器</p>
<a id="more"></a>

<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><p>JDBC：Java DataBase Connectivity</p>
<ul>
<li>JDBC 是Java官方编写的一套接口，用于操作所有的关系型数据库</li>
<li>每个数据库厂商都为自己的数据库实现了该接口，提供了数据库驱动 jar 包</li>
<li>我们使用这套接口编程，真正执行的是厂商提供的 jar 包中的实现类</li>
</ul>
<blockquote>
<p><strong>JDBC 中常用的接口及其方法</strong></p>
<ul>
<li>DriverManager<ul>
<li><code>static void registerDriver(Driver driver)</code> –&gt; 注册驱动</li>
<li><code>static Connection getConnection(String url, String user, String password)</code> –&gt; 获取 Connection 对象</li>
</ul>
</li>
<li>Connection<ul>
<li><code>Statement createStatement()</code> –&gt; 获取 Statement 对象</li>
<li><code>PreparedStatement prepareStatement(String sql)</code> –&gt; 获取 PreparedStatement 对象</li>
<li><strong>事务相关方法</strong><ul>
<li>开启事务：<code>setAutoCommit(boolean autoCommit)</code> –&gt; 参数为 false，开启事务</li>
<li>回滚事务：<code>roolback()</code></li>
<li>提交事务：<code>commit()</code></li>
</ul>
</li>
</ul>
</li>
<li>Statement<ul>
<li><code>int executeUpdate(String sql)</code> –&gt; 执行 DML和DDL(基本不用) 语句，返回被修改行数，可以通过返回值判断DML语句是否执行成功，返回值 &lt; 0,则表示执行失败</li>
<li><code>ResultSet executeQuery(String sql)</code> –&gt; 执行 DQL 语句，返回 ResultSet</li>
</ul>
</li>
<li>PreparedStatement<ul>
<li><code>setXxx(参数1，参数2)</code><ul>
<li>参数1：? 的位置</li>
<li>参数2：给 ? 赋的值</li>
</ul>
</li>
</ul>
</li>
<li>ResultSet<ul>
<li><code>boolean next()</code> –&gt; 将<strong>行光标</strong>向下移动一行，并判断该行是否有数据，返回boolean</li>
<li>getXxx(列编号/列名称) –&gt; 获取该行中某一列的属性值，Xxx为类型名称</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>一、使用 Java 操作数据库的基础三步：</strong></p>
<p>1、导 jar 包</p>
<p>2、注册驱动</p>
<ul>
<li><p>使用<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code>注册驱动</p>
<ul>
<li><p><strong>注册驱动底层原理：</strong></p>
<p>使用反射加载 Driver 驱动类之后，自动调用 Driver 类的静态初始化块，</p>
<p>其中调用了<code>DriverManager.registerDriver(Driver driver)</code>方法</p>
<p>这个方法为注册驱动的核心方法</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>在 mysql-1.5 jar 包版本之后，可以省略注册驱动的步骤 </p>
</blockquote>
<p>3、给出 url、username、password 得到连接对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);<span class="comment">// 加载驱动类</span></span><br><span class="line"></span><br><span class="line">String url = <span class="string">"jdbc:mysql://localhost:3306/exam"</span>;</span><br><span class="line">String username = <span class="string">"root"</span>;</span><br><span class="line">String password = <span class="string">"root"</span>;</span><br><span class="line"><span class="comment">// 得到连接对象</span></span><br><span class="line">Connection conn = DriverManager.getConnection(url,username,password);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果是连接本机的MySQL，且端口为默认的3306，那么url可以简写为：jdbc:mysql:///exam</p>
</blockquote>
<p><strong>二、对数据库进行增、删、改</strong></p>
<ol>
<li>通过 Connection 对象创建 Statement（语句发送器，向数据库发送sql语句）</li>
<li>调用Statement的 executeUpdate(String sql) ，可以发送 DDL、DML</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	对数据进行增 删 改</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 通过 Connection 对象创建 Statement</span></span><br><span class="line">Statement stmt = conn.createStatement();</span><br><span class="line">String sql =  <span class="string">"create table jdbctable(name varchar(30), age int)"</span>;</span><br><span class="line"><span class="comment">// 调用Statement的 executeUpdate(String sql),返回一个int，代表所修改的行数</span></span><br><span class="line"><span class="keyword">int</span> count = stmt.executeUpdate(sql);</span><br></pre></td></tr></table></figure>



<p><strong>三、对数据进行查询操作</strong></p>
<ol>
<li>通过 Connection 对象创建 Statement</li>
<li>调用 Statement 的ResultSet rs = stmt.executeQuery(String querysql)，发送DQL</li>
<li>解析 ResultSet <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 Statement </span></span><br><span class="line">Statement stmt = conn.createStatement();</span><br><span class="line"><span class="comment">// 调用 executeQuery()方法</span></span><br><span class="line">ResultSet rs = stmt.executeQuery(<span class="string">"select * from emp"</span>);</span><br><span class="line"><span class="comment">// 解析 ResultSet</span></span><br><span class="line"><span class="keyword">while</span>(rs.next())&#123; <span class="comment">// 将行光标移动到下一行，并判断下一行是否存在，返回boolean</span></span><br><span class="line">    <span class="keyword">int</span> empno = rs.getInt(<span class="number">1</span>);<span class="comment">// 通过编号来获取该列的值</span></span><br><span class="line">    String ename = rs.getString(<span class="string">"ename"</span>);<span class="comment">// 通过列名来获取该列的值</span></span><br><span class="line">    <span class="keyword">double</span> sal = rs.getDouble(<span class="string">"sal"</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(empno + <span class="string">","</span> + ename +<span class="string">","</span> + sal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rs.close();</span><br><span class="line">stmt.close();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure>




</li>
</ol>
<h2 id="JDBC中相关接口及类的介绍"><a href="#JDBC中相关接口及类的介绍" class="headerlink" title="JDBC中相关接口及类的介绍"></a>JDBC中相关接口及类的介绍</h2><p>4、<strong>ResultSet</strong><br>ResultSet 表示结果集，它是一个二维的表格，其内部有一个<strong>行光标</strong>    </p>
<ul>
<li><strong>previous()</strong> –&gt; 把光标向上移动一行</li>
<li><strong>next()</strong> –&gt; 把光标向下移动一行</li>
<li><strong>getRow()</strong> –&gt; 返回当前光标所在行<br>获取结果集<strong>元数据</strong>：</li>
<li>得到元数据 <strong>rs.getMetaData()</strong> ,返回值为 <strong>ResultSetMetaData</strong></li>
<li>获取结果集列数：<strong>getColumnCount()</strong></li>
<li>获取指定列名：<strong>getColumnName(int index)</strong></li>
</ul>
<p>5、<strong>preparedStatement</strong><br>PreparedStatement 是 Statement 接口的子接口<br>PreparedStatement 的<strong>优点</strong>：</p>
<ul>
<li>防止SQL攻击</li>
<li>提高代码的可读性、可维护性</li>
<li>提高效率</li>
</ul>
<p>PreparedStatement 的<strong>使用步骤</strong>：</p>
<ol>
<li>新建 sql模板，用 ? 代替参数</li>
<li>使用 Connection 的 PreparedStatement(String sql) 创建，创建时就与sql模板绑定</li>
<li>使用setXxxx 方法为模板中的 ? 赋值</li>
<li>调用 executeUpdate() 或 executeQuery() 方法，调用的方法时<strong>没有参数</strong>的</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PreparedStatement 的使用步骤：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.新建 sql模板</span></span><br><span class="line">String sql = <span class="string">"select * from tab_stu where username=? password=?"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建PreparedStatement对象</span></span><br><span class="line">PreparedStatement pstmt = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.使用setXxxx 方法为参数赋值</span></span><br><span class="line">pstmt.setString(<span class="number">1</span>,username);</span><br><span class="line">pstmt.setString(<span class="number">2</span>,password);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.调用executeQuery() 方法</span></span><br><span class="line">ResultSet rs = pstmt.executeQuery();</span><br></pre></td></tr></table></figure>
<p><strong>预处理：</strong></p>
<ul>
<li>数据库服务器的工作<ul>
<li>校验：校验sql语句的语法</li>
<li>编译：将sql语句编译成一个与函数类似的东西</li>
<li>执行：调用函数</li>
</ul>
</li>
<li>PreparedStatement预处理过程：<ul>
<li>每个 pstmt 都与一个sql模板绑定，第一次调用时，先把sql模板给数据库，数据库先进行校验，再进行编译，执行时只是把参数传递过去。</li>
<li>以后执行时，就不用再进行校验和编译。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>PS：使用properties集合类加载配置文件的方式：</strong></p>
<p>1、创建 Properties 集合类</p>
<p><code>Properties pro = new Properties();</code></p>
<p>2、加载配置文件</p>
<p><code>pro.load(类名.class.getClassLoader().getResourceAsStream(&quot;配置文件名&quot;));</code></p>
<p>3、获取配置文件中的数据</p>
<p><code>pro.getProperty(&quot;key&quot;);</code></p>
</blockquote>
]]></content>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL数据库</title>
    <url>/2019/04/16/Java/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p>MySQL数据库是最受欢迎的关系型数据库</p>
<a id="more"></a>

<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="一、使用文件保存数据"><a href="#一、使用文件保存数据" class="headerlink" title="一、使用文件保存数据"></a>一、使用文件保存数据</h2><p><strong>序列化和反序列化：</strong></p>
<ul>
<li><p>序列化：将对象写入到文件中或网络中，</p>
</li>
<li><p>序列化的实质：将对象的信息（完整类名信息，实例属性信息等）写入到文件中或网络中</p>
</li>
<li><p>反序列化：将文件或者网络中的对象取出</p>
</li>
<li><p>反序列化的实质：从文件或者网络中读取对象信息，根据这些对象信息创建一个新的对象，相当于克隆了一份原对象</p>
</li>
</ul>
<p>序列化和反序列化是使用文件保存数据的方式，</p>
<p><strong>使用文件保存数据的缺点：</strong> </p>
<ul>
<li>文件不能被共享</li>
<li>文件的安全性没有保障</li>
</ul>
<h2 id="二、使用数据库保存数据"><a href="#二、使用数据库保存数据" class="headerlink" title="二、使用数据库保存数据"></a>二、使用数据库保存数据</h2><p><strong>DBMS</strong>(DataBase Management System)：数据库管理系统</p>
<ul>
<li>用来管理数据库（一个DBMS下可以由多个DB）</li>
</ul>
<p><strong>DB</strong>(DataBase)：数据库</p>
<ul>
<li>通过一个个的表(table)来保存数据</li>
</ul>
<blockquote>
<p>通常我们所说的数据库包含了<strong>数据库</strong>和<strong>数据库管理系统</strong></p>
</blockquote>
<p><strong>RDBMS</strong>：关系型数据库管理系统 = 管理员（manager）+仓库（database）</p>
<p><strong>database：</strong>N个 table</p>
<p><strong>table：</strong></p>
<ul>
<li>表结构：定义表的列名和列类型</li>
<li>表记录：一行一行的记录</li>
</ul>
<h2 id="三、SQL"><a href="#三、SQL" class="headerlink" title="三、SQL"></a>三、SQL</h2><p><strong>SQL</strong>(Structured Query language)：结构化查询语句</p>
<p><strong>作用：</strong></p>
<ul>
<li><p>客户端使用SQL来操作服务器，</p>
</li>
<li><p>后期会使用Java程序连接服务器，然后使用SQL操作服务器</p>
</li>
</ul>
<p><strong>SQL语法：</strong></p>
<ul>
<li>SQL语句可以在单行或多行进行书写，以分号结尾</li>
<li>可使用空格和缩进来增强语句的可读性</li>
<li>MySQL中不区分SQL语句的大小写，关键字建议使用<strong>大写</strong></li>
</ul>
<p><strong>SQL语句分类：</strong></p>
<ul>
<li>DDL(Data Difinition Language)：数据库定义语言，对数据库或<strong>表的结构</strong>进行操作</li>
<li>DML(Data Manipulation Language)：数据库操作语言，对表进行<strong>增删改</strong></li>
<li>DQL(Data Query language)：数据库查询语言，对表进行<strong>查询</strong></li>
<li>DCL(Data Control Language)：数据库控制语言，创建用户及<strong>授权</strong></li>
</ul>
<h3 id="Ⅰ、DDL"><a href="#Ⅰ、DDL" class="headerlink" title="Ⅰ、DDL"></a>Ⅰ、DDL</h3><p><strong>数据库相关操作：</strong></p>
<ul>
<li>查看所有数据库：<code>SHOW DATABASES;</code></li>
<li>切换（选择要操作的）数据库：<code>USE 数据库名;</code></li>
<li>新建数据库：<code>CREATE DATABASE [IF NOT EXISTS] 数据库名 [CHATSET=UTF8];</code></li>
<li>删除数据库：<code>DROP DATABASE [IF EXISTS] 数据库名;</code></li>
<li>修改数据库编码：<code>ALTER DATABASE 数据库名 CHARACTER SET UTF8;</code></li>
</ul>
<p><strong>数据类型：（列类型）</strong></p>
<ul>
<li>int：整型</li>
<li>double：浮点型；例如 double(5,2) 表示数字最长5位，且必须有2位小数，最大值999.99</li>
<li>decimal：浮点型；在表示钱的时候用该类型，不会出现精度缺失的问题</li>
<li>char：固定长度字符串类型；char(255) 数据长度不足指定长度时会自动补足</li>
<li>varchar：可变长度字符串类型；varchar(65535)</li>
<li>text(clob)：字符串类型，text为MySQL的方言，clob为SQL语句的标准语法<ul>
<li>很小 –&gt; tinytext</li>
<li>小 –&gt; text</li>
<li>中 –&gt; mediumtext</li>
<li>大 –&gt; longtext</li>
</ul>
</li>
<li>blob：字节类型<ul>
<li>很小 –&gt; tinyblob</li>
<li>小 –&gt; blob</li>
<li>中 –&gt; mediumblob</li>
<li>大 –&gt; longblob</li>
</ul>
</li>
<li>date：日期类型；YYYY-MM-DD</li>
<li>time：时间类型；hh:mm:ss</li>
<li>timestamp：时间戳类型；既有日期，又有时间</li>
</ul>
<p><strong>表相关操作：</strong></p>
<ul>
<li><p>创建表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 (</span><br><span class="line">  列名 列类型,</span><br><span class="line">列名 列类型,</span><br><span class="line">  ....</span><br><span class="line">列名 列类型</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看数据库中所有的表：<code>SHOW TABLES;</code></p>
</li>
<li><p>查看表的结构：<code>DESC 表名;</code></p>
</li>
<li><p>删除表：<code>DROP TABLE 表名;</code></p>
</li>
<li><p>修改表：<strong>前缀：ALTER TABLE 表名</strong></p>
<ul>
<li>添加列：<code>ADD(列名 列类型,列名 列类型, ... 列名 列类型);</code></li>
<li>修改列类型：<code>MODIFY 列名 列类型;</code></li>
<li>修改列名：<code>CHANGE 原列名 新列名 新列类型;</code></li>
<li>删除列：<code>DROP 列名;</code></li>
<li>修改表名：<code>RENAME TO 新表名;</code></li>
</ul>
</li>
</ul>
<h3 id="Ⅱ、DML"><a href="#Ⅱ、DML" class="headerlink" title="Ⅱ、DML"></a>Ⅱ、DML</h3><ol>
<li><p><strong>插入数据（增）</strong></p>
<p><code>INSERT INTO 表名 (列名1, 列名2, ... ) VALUES (值1, 值2, ...)</code></p>
</li>
<li><p><strong>修改数据（改）</strong></p>
<p><code>UPDATE 表名 SET 列名1 = 列值1,列名2 = 列值2, ...[WHERE 条件]</code></p>
<p>条件必须是一个Boolean类型，</p>
<p>运算符：=、!=、&gt;、&lt;、&gt;=、&lt;=、BETWEEN….AND、IN(…)、IS NULL、NOT、OR、AND</p>
</li>
<li><p><strong>删除数据（删）</strong></p>
<p><code>DELECT FROM 表名 [WHERE 条件]</code></p>
<p><em>不加where就会把整个表都清空</em></p>
</li>
</ol>
<h3 id="Ⅲ、DQL"><a href="#Ⅲ、DQL" class="headerlink" title="Ⅲ、DQL"></a>Ⅲ、DQL</h3><p><strong>SELECT * FROM 表名：</strong>查询表记录</p>
<p><strong>1、基础查询：列控制</strong></p>
<ul>
<li><p><strong>查询所有列</strong></p>
<p><code>SELECT * FROM 表名;</code></p>
</li>
<li><p><strong>查询指定列</strong></p>
<p><code>SELECT 列名1 [,列名2...] FROM 表名;</code></p>
</li>
<li><p><strong>查询时去重</strong></p>
<p><code>SELECT DISTINCT  列名1 [,列名2...] FROM 表名;</code></p>
</li>
<li><p><strong>列运算</strong></p>
<ul>
<li><p><strong>数量</strong>类型的列可以做数字<strong>运算</strong></p>
<p><code>SELECT 列名*1.5 FROM 表名;</code></p>
</li>
<li><p><strong>字符串</strong>类型可以做<strong>连接</strong>运算</p>
<p><code>SELECT CONCAT(&#39;我是&#39;, 列名) FROM 表名;</code></p>
</li>
<li><p><strong>转换NULL</strong>值</p>
<p><code>SELECT IFNULL(列名, 0) FROM 表名;</code></p>
<p>如果列里面存在NULL就转换为0</p>
</li>
<li><p>给列起<strong>别名</strong></p>
<p><code>SELECT 列名 AS 别名 FROM 表名;</code><em>AS可省略</em></p>
</li>
</ul>
</li>
</ul>
<p><strong>2、条件查询</strong></p>
<p><code>SELECT * FROM 表名 WHERE 条件;</code></p>
<p>运算符：</p>
<ul>
<li><code>=、!=、&gt;、&lt;、&gt;=、&lt;=</code></li>
<li><code>BETWEEN...AND...</code></li>
<li><code>IN(...)</code></li>
<li><code>IS NULL</code></li>
<li><code>NOT、OR、AND</code></li>
</ul>
<p><strong>3、模糊查询</strong></p>
<p>关键字：<code>LIKE</code></p>
<p>符号：</p>
<ul>
<li>_ ：表示一个字符</li>
<li>%：表示0 ~ N个字符</li>
</ul>
<p><code>SELECT * FROM 表名 WHERE 列名 LIKE &#39;张_&#39;;</code></p>
<p><code>SELECT * FROM 表名 WHERE 列名 LIKE &#39;%小%&#39;;</code></p>
<p><strong>4、排序</strong></p>
<p>关键字：</p>
<ul>
<li>ORDER BY</li>
<li>ASC：升序排列（默认）</li>
<li>DESC：降序排列</li>
</ul>
<p><code>SELECT * FROM 表名 ORDER BY 列名 关键字，列名 关键字，列名 关键字;</code></p>
<p><strong>5、聚合函数：将一列数据作为一个整体，进行纵向的计算</strong></p>
<ul>
<li>count(*) –&gt; 计数</li>
<li>sum(sal) –&gt; 求和</li>
<li>max(sal) –&gt; 最大值</li>
<li>min(sal) –&gt; 最小值</li>
<li>avg(sal) –&gt; 平均值</li>
</ul>
<blockquote>
<p>聚合函数使用时，自动排除了null值</p>
</blockquote>
<p><strong>6、分组查询</strong></p>
<p><code>SELECT 列名，聚合函数  FROM 表名 WHERE 条件 GROUP BY 列名 HAVING 条件 ORDER BY 列名 关键字;</code></p>
<p><code>SELECT deptno,count(*) FROM emp WHERE  sal &gt;= 15000 GROUP BY deptno HAVING count(*)&gt;1;</code></p>
<blockquote>
<p>分组查询时 WHERE 和 HAVING 的区别：</p>
<ul>
<li>WHERE: 在分组之前限定条件，如果不满足条件，则不参与分组； 后面不可以跟聚合函数</li>
<li>HAVING: 在分组之后限定条件，如果不满足条件，则不会被查询出来； 后面可以跟聚合函数</li>
</ul>
</blockquote>
<blockquote>
<p>SQL关键字书写顺序：</p>
<p>​    SELECT –&gt; FROM –&gt; WHERE –&gt; GROUP BY –&gt; HAVING –&gt; ORDER BY </p>
</blockquote>
<p><strong>7、limit子句 – 分页查询（MySQL方言）</strong></p>
<p><code>SELECT * FROM 表名 LIMIT 3,5;</code></p>
<p>上面的表达式代表：</p>
<ul>
<li><p>从<em>标号为3的行</em>（<strong>第四行</strong>）开始查，共查询5行。</p>
</li>
<li><p>3为每页开始的索引，5为每页显示的条数</p>
</li>
</ul>
<p>LIMIT 适用于<strong>分页查询</strong></p>
<p><strong>查询公式:</strong></p>
<p>一页记录数：m</p>
<p>查询第n页</p>
<p>查询开始的索引 =（n-1）* m</p>
<p>SELECT * FROM 表名 LIMIT <strong>(n-1)*m,m</strong>;</p>
<h3 id="Ⅳ、约束"><a href="#Ⅳ、约束" class="headerlink" title="Ⅳ、约束"></a>Ⅳ、约束</h3><blockquote>
<p>概念：对表中的数据进行限定，保证数据的正确性、有效性和完整性</p>
</blockquote>
<p>约束的分类：</p>
<ul>
<li>主键约束：primary key</li>
<li>非空约束：not null</li>
<li>唯一约束：unique</li>
<li>外键约束：foreign key</li>
</ul>
<ol>
<li><p><strong>主键约束（唯一标识）</strong></p>
<p><strong>三个特性：</strong></p>
<ul>
<li>非空</li>
<li>唯一</li>
<li>可被引用</li>
</ul>
<p><strong>指定方式：</strong></p>
<ul>
<li><p>创建表时指定主键</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tab_stu(</span><br><span class="line"><span class="keyword">id</span>  <span class="built_in">INT</span> **PRIMARY <span class="keyword">KEY</span>**,</span><br><span class="line"><span class="keyword">name</span>  <span class="built_in">VARCHAR</span>(<span class="number">30</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tab_stu(</span><br><span class="line"><span class="keyword">id</span>  <span class="built_in">INT</span>,</span><br><span class="line"><span class="keyword">name</span>  <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">**PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)**</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改表时指定主键 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tab_stu <span class="keyword">ADD</span> PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<p><strong>删除主键：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tab_stu <span class="keyword">DROP</span> PRIMARY <span class="keyword">KEY</span>;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li><p><strong>主键自增长</strong></p>
<p>关键字：AUTO_INCREMENT</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tab_stu(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	name VARCHAR(30)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>主键自增长在集群环境下会失效 </p>
</blockquote>
<ol start="3">
<li><p><strong>非空和唯一约束</strong></p>
<p>关键字：</p>
<ul>
<li>非空：NOT NULL</li>
<li>唯一：UNIQUE</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tab_stu(</span><br><span class="line">  id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  name VARCHAR(30) NOT NULL UNIQUE</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>非空和唯一可以组合使用</p>
</blockquote>
<ol start="4">
<li><strong>外键约束</strong><ul>
<li>外键必须是另一表的主键的值</li>
<li>外键可以重复</li>
<li>外键可以为空</li>
<li>一张表中可以有多个外键</li>
</ul>
</li>
</ol>
<p>外键的作用：让表和表之间产生关系，从而保证数据的正确性。</p>
<blockquote>
<p>概念模型：?</p>
<p>对象模型：可以双向关联，而且引用的是对象，而不是一个主键。</p>
<p>关系模型：只能多方（从表）引用一方（主表），而且引用的只是主键，而不是一行记录。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*创建表时添加外键*&#x2F;</span><br><span class="line">CREATE TABLE dept(</span><br><span class="line">  deptno INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  dname VARCHAR(50)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">CREATE TABLE emp(</span><br><span class="line">  empno INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  ename VARCHAR(50),</span><br><span class="line">  deptno INT, &#x2F;*一对多的关系*&#x2F;</span><br><span class="line">  CONSTRAINT fk_emp_dept FOREIGN KEY(deptno) REFERENCES dept(deptno)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;*修改表时添加外键*&#x2F;</span><br><span class="line">ALTER TABLE emp</span><br><span class="line">ADD CONSTRAINT fk_emp_dept FOREIGN KEY(deptno) REFERENCES dept(deptno)</span><br><span class="line"></span><br><span class="line">&#x2F;*删除外键*&#x2F;</span><br><span class="line">ALTER TABLE emp DROP FOREIGN KEY fk_emp_dept</span><br><span class="line"></span><br><span class="line">&#x2F;*一对一的关系*&#x2F;</span><br><span class="line">CREATE TABLE hasband(</span><br><span class="line">  hid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  hname VARCHAR(50)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE wife(</span><br><span class="line">  wid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  wname VARCHAR(50),</span><br><span class="line">  CONSTRAINT fk_wife_hasband FOREIGN KEY(wid) REFERENCES hasband(hid)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&#x2F;*多对多的关系*&#x2F;</span><br><span class="line">CREATE TABLE student(</span><br><span class="line">  sid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  sname VARCHAR(50)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE teacher(</span><br><span class="line">  tid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  tname VARCHAR(50)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE stu_tea(</span><br><span class="line">  sid INT,</span><br><span class="line">  tid INT,</span><br><span class="line">  CONSTRAINT fk_stu FOREIGN KEY(sid) REFERENCES student(sid),</span><br><span class="line">  CONSTRAINT fk_tea FOREIGN KEY(tid) REFERENCES teacher(tid)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<p>外键约束_级联操作：</p>
<ul>
<li>级联更新：ON UPDATE CASCADE</li>
<li>级联删除：ON DELETE CASCADE</li>
</ul>
<blockquote>
<p>级联操作可以使通过外键链接的字段在一个字段更新时相关字段自动更新，有其方便之处，但也有危险，尤其是级联删除</p>
</blockquote>
<h3 id="Ⅴ、多表操作"><a href="#Ⅴ、多表操作" class="headerlink" title="Ⅴ、多表操作"></a>Ⅴ、多表操作</h3><p><strong>多表之间的关系：</strong></p>
<ul>
<li>一对一：了解即可，在程序开发中很少会有一对一的关系</li>
<li>一对多（多对一）：用的最多</li>
<li>多对多</li>
</ul>
<p><strong>实现多表之间的关系：</strong></p>
<ul>
<li><p>一对多：在多的一方建立外键，指向一的一方的主键。</p>
</li>
<li><p>多对多： 需要借助第三张中间表，中间表至少包含两个字段，这两个字段作为中间表的两个外键外键，分别指向两张表的主键。</p>
</li>
<li><p>一对一：可以在任意一方添加<strong>唯一</strong>外键指向另一方的主键</p>
</li>
</ul>
<p><strong>多表查询：</strong></p>
<ul>
<li><p>合并结果集</p>
<p>要求被合并的结果集中，列的类型和列数完全相同。</p>
<p>UNION：去除重复行</p>
<p>UNION ALL：不去除重复行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM 表一；</span><br><span class="line">UNION ALL;</span><br><span class="line">SELECT * FROM 表二；</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>内连接&amp;外连接</p>
<ul>
<li><p>内连接</p>
<ul>
<li><p>隐式内连接：MySQL 方言写法</p>
<p><code>SELECT 字段 FROM 表名1,表名2 WHERE 条件</code></p>
</li>
<li><p>显式内连接：SQL 标准写法</p>
<p><code>SELECT 字段 FROM 表名1 [INNER] JOIN 表名2 ON 条件</code></p>
</li>
</ul>
</li>
<li><p>外连接</p>
<ul>
<li><p>左外连接：将左表所有行都显示，不符合条件的右表使用NULL</p>
<p><code>SELECT 字段 FROM 表名1 LEFT [OUTER] JOIN 表名2 ON 条件</code></p>
</li>
<li><p>右外连接：将右表所有行都显示，不符合条件的左表使用NULL</p>
<p><code>SELECT 字段 FROM 表名1 RIGHT [OUTER] JOIN 表名2 ON 条件</code></p>
</li>
<li><p>全外连接（MySQL不支持）</p>
<p>使用<code>UNION</code>连接左外和右外，在MySQL中实现全外连接</p>
</li>
</ul>
</li>
<li><p>自然连接</p>
</li>
</ul>
</li>
<li><p>子查询</p>
<p><strong>概念：</strong>查询中有查询（查询中有多个 SELECT 关键字）</p>
<p><strong>出现的位置：</strong></p>
<ul>
<li>FROM后作为表存在（多行多列）</li>
<li>WHERE后作为条件存在（单行单列、多行单列、单行多列）</li>
</ul>
<p><strong>子查询的三种情况：</strong></p>
<ul>
<li>子查询的结果是<strong>单行单列</strong>的：子查询可以作为条件，使用运算符（&gt;,&lt;…）做判断</li>
<li>子查询的结果是<strong>多行单列</strong>的：子查询可以作为条件，使用运算符（in）做判断</li>
<li>子查询的结果是<strong>多行多列</strong>的：子查询可以作为一张虚拟表参与查询</li>
</ul>
</li>
</ul>
<h3 id="Ⅵ、事务"><a href="#Ⅵ、事务" class="headerlink" title="Ⅵ、事务"></a>Ⅵ、事务</h3><p><strong>概念：</strong>如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败</p>
<p><strong>操作：</strong></p>
<ul>
<li>开启事务：<code>start transaction;</code></li>
<li>回滚事务：<code>rollback;</code></li>
<li>提交事务：<code>commit;</code></li>
</ul>
<p><strong>事务的提交方式：</strong></p>
<ul>
<li>自动提交：<ul>
<li>执行一次DML语句就会自动提交一次事务</li>
<li>MySQL数据库中的事务是默认自动提交的</li>
</ul>
</li>
<li>手动提交：<ul>
<li>需要先开启事务，再commit手动提交事务</li>
<li>Oracle数据库中的事务是默认手动提交的</li>
</ul>
</li>
<li>修改事务的提交方式：<ul>
<li>查询事务的默认提交方式：<code>select @@autocommit;</code><ul>
<li>0 –&gt; 手动提交 </li>
<li>1 –&gt; 自动提交</li>
</ul>
</li>
<li>修改事务的默认提交方式：<code>select @@autocommit = 0;</code></li>
</ul>
</li>
</ul>
<p><strong>☆事务的四大特征☆</strong></p>
<ul>
<li>原子性：事务是不可分割的最小操作单位，要么同时成功，要么同时失败</li>
<li>持久性：事务提交或回滚后，数据库会持久化的保存数据</li>
<li>隔离性：多个事务之间相互独立</li>
<li>一致性：事务操作前后，数据总量不变</li>
</ul>
<h3 id="Ⅶ、三大范式"><a href="#Ⅶ、三大范式" class="headerlink" title="Ⅶ、三大范式"></a>Ⅶ、三大范式</h3><p>数据库范式：设计关系型数据库时，需要遵循的规范要求</p>
<blockquote>
<p>目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）</p>
</blockquote>
<p>一般只要遵循前三个范式即可</p>
<ul>
<li>第一范式：数据库表的每一列都是不可分割的原子数据项</li>
<li>第二范式：在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）</li>
<li>第三范式：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）</li>
</ul>
<p>对三大范式的简单理解：</p>
<ul>
<li>第一范式：每一列都要不可分割，也就是一个字段只存储一项信息</li>
<li>第二范式：在存在多个主键（联合主键）的情况下才会发生不符合第二范式的情况，比如存在两个主键，如果有一个属性只依赖于一个主键而不依赖于另一个，这就是不符合第二范式</li>
<li>第三范式：一张表中所有的非主键属性只能依赖主键属性</li>
</ul>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p><strong>简介:</strong></p>
<p>​    MySQL是一个数据库管理系统，现在属于Oracle公司，版本号5.5及以下不收费，以上收费。</p>
<p><strong>启动MySQL服务：</strong></p>
<ol>
<li>我的电脑(右键) –&gt; 管理 –&gt; 服务和应用程序 –&gt; 服务 –&gt; MySQL（右键启动）</li>
<li>cmd –&gt; services.msc –&gt; 服务和应用程序 –&gt; 服务 –&gt; MySQL（右键启动）</li>
<li>cmd(<strong>以管理员模式打开</strong>) –&gt; net start mysql 【关闭服务：net stop mysql】</li>
</ol>
<p><strong>登录MySQL服务器：</strong></p>
<ul>
<li>（本地）cmd  –&gt; <u>mysql -uroot -proot</u></li>
<li>（网络）cmd  –&gt; <u>mysql -uroot -proot <strong>-h192.168.137.4</strong> <strong>-P3306</strong></u></li>
</ul>
<p><strong>在cmd窗口退出mysql：</strong></p>
<ul>
<li><p>exit</p>
</li>
<li><p>quit</p>
</li>
</ul>
<p>数据库的备份与还原：</p>
<ul>
<li>备份：<ul>
<li>命令行形式：<code>mysqldump  -u用户名  -p密码  数据库名 &gt; 保存路径</code></li>
</ul>
</li>
<li>还原：<ul>
<li>登录数据库 –&gt; 创建数据库 –&gt; 使用数据库 –&gt; 执行文件：<code>source 文件路径</code></li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat服务器</title>
    <url>/2019/04/15/Java/2.JavaWeb/7.Tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>Tomcat服务器是一款免费、开源的轻量级Web应用服务器</p>
<a id="more"></a>

<h2 id="Tomcat服务器"><a href="#Tomcat服务器" class="headerlink" title="Tomcat服务器"></a>Tomcat服务器</h2><p><strong>什么是服务器？</strong></p>
<p>​    服务器其实就是一个代码编写的可以根据用户请求实时的调用执行对应逻辑代码的一个容器。</p>
<p><strong>Tomcat 服务器各文件夹作用：</strong></p>
<ul>
<li>\bin –&gt; 存放 Tomcat 的可执行文件</li>
<li>\conf –&gt; 存 Ttoncat 的配置文件</li>
<li>\lib –&gt; 存放Tomcat运行依赖的jar包</li>
<li>\logs  –&gt; 存放日志文件</li>
<li>\temp –&gt; 存放临时文件</li>
<li>\webapps –&gt; 存放web应用</li>
<li>work –&gt; 存放 JSP 转换后的 Servlet 文件</li>
</ul>
<blockquote>
<p>双击startup.bat启动Tomcat服务器时黑窗口一闪而过：</p>
<ul>
<li>原因：JAVA_HOME 环境变量配置的问题</li>
<li>解决：正确配置 JAVA_HOME 环境变量</li>
</ul>
</blockquote>
<blockquote>
<p> Tomcat默认端口号为8080，可在<code>conf/server.xml</code>配置文件中修改端口</p>
<p>后期常用的端口号为80，因为这是HTTP协议的默认端口号，访问时ip后面可以不输端口号</p>
</blockquote>
<p><strong>在Tomcat服务器上部署项目的方式：</strong></p>
<ol>
<li><p>直接将项目放到<code>webapps</code>目录下</p>
<ul>
<li>直接将项目文件夹放到<code>webapps</code>目录下（/项目文件夹名：项目的访问路径 &lt; 虚拟目录&gt;）</li>
<li>将项目打成<code>war</code>包，放到<code>webapps</code>目录下，此时war包会自动解压缩</li>
</ul>
</li>
<li><p>配置<code>conf/server.xml</code>文件</p>
<p>在<code>&lt;host&gt;</code>标签中配置：<code>&lt;Context docBase = &quot;项目路径&quot; path = &quot;虚拟目录&quot;/&gt;</code></p>
</li>
<li><p>在<code>conf/Catalina/localhost</code> 目录下创建任意名称的xml文件</p>
<p>在文件中编写：<code>&lt;Context docBase=&quot;项目路径&quot;/&gt;</code></p>
<p>此时<u>虚拟目录为xml文件的名称</u></p>
</li>
</ol>
<p><strong>webapps中java动态项目的目录结构：</strong></p>
<ul>
<li>项目根目录<ul>
<li>WEB-INF目录<ul>
<li>web.xml：web项目的核心配置文件</li>
<li>classes目录：放置字节码文件</li>
<li>lib目录：放置依赖的jar包</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Tomcat线程池概述：</strong></p>
<p>Tomcat自带线程池机制，线程都是由线程池进行管理。</p>
<h2 id="web开发中的常见问题"><a href="#web开发中的常见问题" class="headerlink" title="web开发中的常见问题"></a>web开发中的常见问题</h2><h3 id="服务器启动报错，如何进行错误排查"><a href="#服务器启动报错，如何进行错误排查" class="headerlink" title="服务器启动报错，如何进行错误排查"></a>服务器启动报错，如何进行错误排查</h3><p><strong>两种情况：</strong></p>
<ul>
<li>服务器中没有项目，服务器启动时报错，二话不说，删掉原来的服务器，重新解压一份新的。</li>
<li>服务器中有项目，服务器启动报错，则一定是项目中 web.xml 中的配置出现了错误<ul>
<li>url-pattern 前面没有加 / </li>
<li>servlet-name 没有匹配项</li>
</ul>
</li>
<li>servlet-class 配置错误，不会影响服务器的启动，但是在访问的时候会报 500 错误</li>
</ul>
<h3 id="修改哪些文件，需要重新启动服务器"><a href="#修改哪些文件，需要重新启动服务器" class="headerlink" title="修改哪些文件，需要重新启动服务器"></a>修改哪些文件，需要重新启动服务器</h3><p><strong>不需要</strong>重新启动的两种情况：</p>
<ul>
<li>修改了前端资源，不需要重新启动服务器</li>
<li>修改servlet，不用重新启动服务器，但是需要等待 Java 文件重新编译成 .class 文件后，才能访问到新的内容</li>
</ul>
<p><strong>需要</strong>重新启动的情况：</p>
<ul>
<li>修改了 web.xml 文件，必须重新启动服务器</li>
</ul>
<blockquote>
<p>在未来的工作中，会大量的在服务器中部署或移除项目，在部署和移除之前，必须关闭服务器</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Tomcat服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2019/04/15/Java/1.Java%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>深入理解设计模式能够帮助自己更好的体会编程的思想</p>
<a id="more"></a>

<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p><strong>设计模式</strong>（Design Pattern）是一套被反复使用、多人知晓的经过分类的代码设计经验的总结</p>
<p>使用设计模式的目的：为了代码的可重用性、可维护性</p>
<h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p>单例模式，是最常用的一种软件设计模式，在它的核心结构中只包含一个被称为单例的特殊类，通过过单例模式可以保证系统中：应用该模式的一个类只有一个实例。</p>
<p><strong>单例由两种实现形式：</strong></p>
<ul>
<li>饿汉式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接创建好对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Person p = <span class="keyword">new</span> Person();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Person <span class="title">getPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>懒汉式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等待有需求时创建对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Person p = <span class="keyword">null</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Person <span class="title">getPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span>)&#123;</span><br><span class="line">            p = <span class="keyword">new</span> Person();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>在实际开发中一般用的都时饿汉式，因为懒汉式存在<strong>线程安全</strong>的问题</p>
</blockquote>
<h2 id="工厂设计模式"><a href="#工厂设计模式" class="headerlink" title="工厂设计模式"></a>工厂设计模式</h2><p>作用：实现了<strong>创建者</strong>和<strong>调用者</strong>的分离</p>
<p>分类：</p>
<ul>
<li><p>简单工厂模式</p>
<p>虽然某种成都不符合设计原则，但实际使用最多</p>
</li>
<li><p>工厂方法模式</p>
<p>不修改已有类的前提下，通过增加新的工厂实现拓展</p>
</li>
<li><p>抽象工厂模式</p>
<p>不可以增加产品，可以增加产品族</p>
</li>
</ul>
<p>核心本质：</p>
<ul>
<li>实例化对象，用工厂方法代替new进行操作</li>
<li>将选择实现类、创建对象统一管理和控制，从而将调用者与实现类解耦</li>
</ul>
<blockquote>
<p>面向对象设计的基本原则：</p>
<ul>
<li>OCP（开闭原则，Open-closed Principle）：一个软件的实体应当对扩展开放，对修改关闭</li>
<li>DIP（依赖倒转原则，Dependence Inversion Principle）：要针对接口编程，不要针对实现编程</li>
<li>LoD（迪米特法则，Law of Demeter）：只与直接朋友通信，而避免和陌生人通信</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet</title>
    <url>/2019/04/14/Java/2.JavaWeb/8.Servlet/</url>
    <content><![CDATA[<p>Servlet = Server Applet –&gt; 服务器上的小程序</p>
<a id="more"></a>

<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><blockquote>
<p><strong>Servlet：</strong>是指任何实现了Servlet接口的类<br><strong>作用：</strong>接收并处理浏览器发出的请求</p>
</blockquote>
<h3 id="一-Servlet基础及其生命周期"><a href="#一-Servlet基础及其生命周期" class="headerlink" title="一. Servlet基础及其生命周期"></a>一. Servlet基础及其生命周期</h3><p><strong>自定义一个Servlet：</strong></p>
<ol>
<li><p>创建普通的Java类，并实现Servlet接口</p>
</li>
<li><p>实现接口中的抽象方法</p>
<ol>
<li><strong>init</strong> –&gt; 初始化方法</li>
<li><strong>service</strong> –&gt; 判断请求方式，并分配请求</li>
<li><strong>destroy</strong> –&gt; 销毁方法</li>
<li>getServletConfig</li>
<li>getServletInfo</li>
</ol>
</li>
<li><p>在web.xml 文件中配置 servlet</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>myservlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>cn.hellopika.servlet.MyServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>myservlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/myservleturl<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<blockquote>
<p>Servlet可以不用xml配置，改用注解配置（Servlet 3.0 之后才有）</p>
<p><code>@WebServlet(&quot;url-pattern&quot;)</code></p>
</blockquote>
<blockquote>
<p>JavaWeb 项目中<strong>src目录下</strong>的文件部署到服务器后会被放在<strong>WEB-INF下的classes目录下</strong></p>
</blockquote>
<p><strong>Servlet继承结构：</strong></p>
<p>​    <code>Servlet(接口)</code> –实现–&gt; <code>GenericServlet</code> –继承–&gt; <code>HttpServlet</code> –继承–&gt;<code>MyServlet(自己写的)</code></p>
<p><strong>Servlet的生命周期（以及 load-on-startup 的用法）：</strong></p>
<p>Servlet的生命周期是指Servlet对象从创建到销毁的全过程</p>
<ol>
<li>启动服务器，没有创建servlet对象</li>
<li>当浏览器发出请求，用到了指定的servlet来处理请求的时候，servlet对象创建</li>
<li>servlet对象创建后，立刻调用 <strong>init</strong> 方法执行初始化操作</li>
<li>servlet对象创建后，始终以<strong>单例</strong>的形式存储在服务器上</li>
<li>servlet以 doGet 和 doPost 方法来处理浏览器发出的请求</li>
<li>关闭服务器，servlet对象销毁</li>
<li>如果是正常关闭服务器，在servlet对象销毁前会调用 <strong>destory</strong> 方法执行最后的处理工作</li>
</ol>
<blockquote>
<p>加入 load-on-startup ，可以更改servlet对象的创建时机，在服务器启动期间创建对象</p>
<p>load-on-startup 标签放在 servlet-class 标签下面，其中的数字越小，越优先创建</p>
</blockquote>
<h3 id="二、servlet处理HTTP请求"><a href="#二、servlet处理HTTP请求" class="headerlink" title="二、servlet处理HTTP请求"></a>二、servlet处理HTTP请求</h3><blockquote>
<p>在继承了<code>HttpServlet</code> 之后, 自己的servlet便可以处理<code>get</code>和<code>post</code>请求</p>
</blockquote>
<p>处理get请求: <code>doGet()</code>方法</p>
<blockquote>
<p>使用get提交方式的操作：</p>
<ul>
<li>直接在浏览器地址栏输入url</li>
<li>点击超链接</li>
<li>提交表单，如果不设置form标签中 method 属性的值，默认为get提交</li>
</ul>
</blockquote>
<p>处理post请求: <code>dopost()</code>方法 </p>
<blockquote>
<p>使用get提交方式的操作：</p>
<ul>
<li>提交表单，设置form标签中 method 属性的值为post</li>
</ul>
</blockquote>
<ul>
<li>提交表单，设置 method = “post” .</li>
</ul>
<h3 id="三、对于Servlet代码结构的处理"><a href="#三、对于Servlet代码结构的处理" class="headerlink" title="三、对于Servlet代码结构的处理"></a>三、对于Servlet代码结构的处理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"调用了doGet方法"</span>);</span><br><span class="line">    <span class="comment">// 参数的接收</span></span><br><span class="line">    String str1 = request.getParameter(<span class="string">"str1"</span>);</span><br><span class="line">    String str2 = request.getParameter(<span class="string">"str2"</span>);</span><br><span class="line">    System.out.println(str1);</span><br><span class="line">    System.out.println(str2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 在doPost中直接调用doGet</span></span><br><span class="line">    <span class="keyword">this</span>.doGet(request,response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="四、url-pattern"><a href="#四、url-pattern" class="headerlink" title="四、url-pattern"></a>四、url-pattern</h3><blockquote>
<p>在<code>web.xml</code>中配置<code>&lt;servlet-mapping&gt;</code>时, 需要注意<code>url-pattern</code>的配置</p>
</blockquote>
<ol>
<li>url-pattern的<strong>配置方式</strong></li>
</ol>
<ul>
<li>精确路径匹配 –&gt; <code>/abc/MyServlet</code></li>
<li>部分路径匹配 –&gt; <code>/abc/*</code></li>
<li>通配符匹配 –&gt; <code>/*</code></li>
<li>后缀名匹配 –&gt; <code>*.do</code></li>
</ul>
<ol start="2">
<li>url-pattern的<strong>优先级</strong></li>
</ol>
<p>精确路径匹配 &gt; 部分路径匹配 &gt; 通配符匹配 &gt; 后缀名匹配</p>
<h3 id="五、ServletContext对象（上下文对象）"><a href="#五、ServletContext对象（上下文对象）" class="headerlink" title="五、ServletContext对象（上下文对象）"></a>五、ServletContext对象（上下文对象）</h3><p><strong>概念：</strong>代表整个web应用，可以和服务器通信</p>
<p><strong>生命周期：</strong></p>
<ul>
<li>创建：服务器启动，创建 <strong>单例</strong> ServletContext对象，</li>
<li>销毁：服务器关闭，ServletContext对象销毁</li>
</ul>
<p><strong>获取 ServletContext 对象</strong>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 request 对象来获取</span></span><br><span class="line">ServletContext application = request.getServletContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 HttpServlet 获取 （实际开发中常用）</span></span><br><span class="line">ServletContext application = <span class="keyword">this</span>.getServletContext();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：ServletContext对象的变量名必须叫 <strong>application</strong></p>
</blockquote>
<p><strong>功能：</strong></p>
<ul>
<li>使用ServletContext域对象存取值</li>
</ul>
<ol>
<li>上下文域对象<ul>
<li>上下文域对象的取值范围最为广泛(服务器整个生命周期)</li>
<li>上下文域对象中的值在服务器关闭时才会被销毁</li>
</ul>
</li>
<li>域对象的常用方法<ul>
<li>存值：<code>application.setAttribute(String key, Object value)</code></li>
<li>取值：<code>application.getAttribute(String key)</code> </li>
<li>移除值：<code>application.removeAttribute(String key)</code>   <em>不常用</em></li>
</ul>
</li>
</ol>
<ul>
<li><p>获取MIME类型: <code>String getMimeType(String file)</code></p>
<blockquote>
<p>MIME类型</p>
<ul>
<li><p>概念：互联网通信过程中定义的一种文件数据类型</p>
</li>
<li><p>格式：<code>大类型/小类型</code></p>
</li>
<li><p>例：<code>text/html</code></p>
</li>
</ul>
</blockquote>
</li>
</ul>
<ul>
<li>获取文件的真实路径：<code>String realPath = ServletContext.getRealPath(String Path)</code></li>
</ul>
<ul>
<li><p>使用上下文对象取得全局参数信息：</p>
<p><strong>1、全局参数：</strong>可以应用于所有的 servlet， 全局参数在 web.xml 中进行配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置全局参数，以键值对的方式呈现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">content-param</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>str1<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>abcd<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">content-param</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>2、使用上下文对象取得全局参数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取得上下文对象</span></span><br><span class="line">ServletContext application = <span class="keyword">this</span>.getServletContext();</span><br><span class="line"><span class="comment">// 使用上下文对象取得全局参数</span></span><br><span class="line">application.getInitparameter(<span class="string">"str1"</span>);</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="六、ServletConfig对象"><a href="#六、ServletConfig对象" class="headerlink" title="六、ServletConfig对象"></a>六、ServletConfig对象</h3><blockquote>
<p>ServletConfig 对象在企业级开发中用不到，在自己编写框架的时候会用到</p>
</blockquote>
<p><strong>概念：</strong>在Servlet对象创建出来之后，搭配每一个Servlet，会产生一个ServletConfig对象，ServletConfig对象是用来装饰Servlet对象的装饰对象</p>
<p><strong>取得方式：</strong><code>ServletConfig config = this.getServletConfig();</code></p>
<p><strong>注意：</strong>ServletConfig对象的名字必须为：<strong>config</strong></p>
<p><strong>常用方法：</strong></p>
<ul>
<li><p>获取 web.xml 文件中配置的servlet-name –&gt; <code>config.getServletName()</code></p>
</li>
<li><p>取得Servlet的参数值 –&gt; <code>config.getInitParameter(&quot;key&quot;)</code></p>
<ul>
<li><p>取得的参数值是当前Servlet的<strong>局部参数</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>str1<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>abcd<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<h3 id="七、配置欢迎页-index-html"><a href="#七、配置欢迎页-index-html" class="headerlink" title="七、配置欢迎页(index.html)"></a>七、配置欢迎页(index.html)</h3><p>欢迎页是在 web.xml 自动生成配置的，当我们没有指定具体的访问资源时，默认访问欢迎页</p>
<p>欢迎页一般命名为：<code>index.html</code></p>
<blockquote>
<p>欢迎页的正确打开方式：</p>
<ul>
<li>创建 index.html 文件，不做任何操作，只是跳转到一个作为欢迎页的网页（如登录页）</li>
</ul>
</blockquote>
<h3 id="八、配置404页面"><a href="#八、配置404页面" class="headerlink" title="八、配置404页面"></a>八、配置404页面</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/error/error_404.html<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="九、关于-Servlet-线程安全性的问题"><a href="#九、关于-Servlet-线程安全性的问题" class="headerlink" title="九、关于 Servlet 线程安全性的问题"></a>九、关于 Servlet 线程安全性的问题</h3><p>在 Servlet 中，<strong>成员变量</strong>会引起线程安全的问题，</p>
<p>要想解决这个问题，就<strong>不使用成员变量</strong>，因为在 Servlet 中一般也用不到成员变量</p>
<blockquote>
<p>在 idea 中不重启服务器就可以更新 servlet 到界面：</p>
<ul>
<li>在启动 tomcat 时使用 debug 模式启动</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript--2</title>
    <url>/2019/04/11/Java/2.JavaWeb/4.JavaScript--2/</url>
    <content><![CDATA[<p>BOM &amp; DOM</p>
<a id="more"></a>

<h1 id="JavaScript–BOM-amp-DOM"><a href="#JavaScript–BOM-amp-DOM" class="headerlink" title="JavaScript–BOM &amp; DOM"></a>JavaScript–BOM &amp; DOM</h1><h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><p><strong>BOM</strong> : Broswer Object Model：浏览器对象模型</p>
<p>对象：</p>
<ol>
<li><p><strong>Window（非常重要）</strong></p>
<p><strong>使用：</strong></p>
<p>Window里面的方法可以通过 <code>window.方法名()</code> 使用</p>
<p>也可以直接通过 <code>方法名()</code> 使用</p>
<p><strong>方法：</strong></p>
<ol>
<li>与<strong>弹出</strong>有关的方法<ul>
<li><code>alert()</code> –&gt; 在页面弹个警告框，显示内容</li>
<li><code>confirm()</code> –&gt; 确认提示框，带有一段消息和确认/取消按钮，<u><strong>后期常用</strong></u><ul>
<li>点击确认按钮，方法返回true</li>
<li>点击取消按钮，方法返回false</li>
</ul>
</li>
<li><code>prompt(&quot;text&quot;,&quot;defaultText&quot;)</code> –&gt; 输入对话框，返回用户输入的值<ul>
<li>text –&gt; 提示文本</li>
<li>defaultText –&gt; 默认输入的内容</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<ol start="2">
<li><p>与<strong>打开关闭</strong>有关的方法</p>
<ul>
<li><code>open(&quot;url&quot;,&quot;name&quot;,&quot;features&quot;)</code> –&gt; 打开一个新的窗口，返回新窗口的Window对象<ul>
<li>url –&gt; 新窗口中要打开的页面地址</li>
<li>name –&gt; 新窗口名称，可为空</li>
<li>features –&gt; 窗口特征，可设置宽高等</li>
</ul>
</li>
<li><code>close()</code> –&gt; 关闭窗口（浏览器兼容性比较差）<ul>
<li>谁调用close()，就关闭谁</li>
</ul>
</li>
</ul>
</li>
<li><p>与<strong>定时器</strong>有关的方法</p>
<ul>
<li><p><code>setTimeout(&quot;js代码&quot;,毫秒数)</code> –&gt; 在一定的毫秒数之后，只执行一次结束代码（一次）</p>
<ul>
<li>方法的返回值：一个唯一标识，用于取消定时器</li>
</ul>
</li>
<li><p><code>clearTimeout()</code> –&gt; 清除setTimeout设置的计时器</p>
</li>
</ul>
</li>
</ol>
<pre><code>- `setInterval(&quot;js代码&quot;,毫秒数)` --&gt; 每过一定的毫秒数，执行一次js代码（循环）

  - 方法的返回值：一个唯一标识，用于取消定时器
- `clearInterval()` --&gt; 清除setInterval设置的计时器</code></pre><p>   <strong>属性：</strong></p>
<ol>
<li>获取其他BOM对象<ul>
<li>navigator</li>
<li>screen</li>
<li>location</li>
<li>history</li>
</ul>
</li>
<li>获取DOM对象<ul>
<li>document</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>Navigator –&gt;  获取浏览器的信息</p>
</li>
<li><p>Screen –&gt; 获取屏幕的相关信息</p>
</li>
<li><p>Location –&gt; 请求的url地址</p>
<ul>
<li>href 属性：<ul>
<li><code>location.href</code> –&gt; 获取到请求的url地址</li>
<li><code>location.href = &quot;url&quot;;</code> –&gt; 设置url地址</li>
</ul>
</li>
<li>reload() 方法：<ul>
<li><code>location.reload();</code> –&gt; 刷新页面</li>
</ul>
</li>
</ul>
</li>
<li><p>History –&gt; 请求的url历史记录</p>
<ul>
<li>方法：<ul>
<li><code>back()</code>–&gt; 加载history列表的前一个url（到上一个页面）</li>
<li><code>forward()</code> –&gt; 加载history列表的后一个url（到下一个页面）</li>
<li><code>go(-1/1)</code> –&gt; 到上/下一个页面</li>
</ul>
</li>
<li>属性：<ul>
<li>length –&gt; 返回当前窗口历史列表的 URL 数量</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p><strong>DOM：</strong>Document Object Model：文档对象模型</p>
<ul>
<li>文档：超文本标记文档，HTML / XML</li>
<li>对象： 提供了属性和方法</li>
<li>模型：使用属性和方法操作文档</li>
</ul>
<p>一句话：将标记文档的各个组成部分，封装成对象。可以使用这些对象，对文档进行动态操作</p>
<p><strong>使用DOM解析HTML的过程:</strong></p>
<ul>
<li>根据HTML的结构，在内存中分配一个树形结构，然后把HTML 的每一部分都封装成对象<ul>
<li>document对象： 整个文档</li>
<li>element对象：标签对象</li>
<li>属性对象</li>
<li>文本对象</li>
</ul>
</li>
<li>Node节点对象：为上面几个对象的父对象<ul>
<li>如果在上面几个对象中找不到想要的对象，就到Node对象里面去找</li>
</ul>
</li>
</ul>
<p><strong>DHTML</strong>：是多种技术的简称</p>
<ul>
<li>HTML：封装数据</li>
<li>CSS： 使用属性和属性值设置样式</li>
<li>dom：操作HTML文档</li>
<li>JavaScript：专指ECMAScript</li>
</ul>
<h3 id="Document对象"><a href="#Document对象" class="headerlink" title="Document对象"></a>Document对象</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>通过window来创建： window.document</p>
<p>直接创建：document</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul>
<li><code>write()</code> –&gt; 直接向页面输出内容（变量值、HTML代码）<ul>
<li>输出变量值：document.write(str);</li>
<li>输出HTML代码：<code>document.write(&quot;&lt;hr/&gt;&quot;);</code></li>
</ul>
</li>
<li><code>getElementById()</code> –&gt; 通过<strong>id属性值</strong>获取<strong>element对象</strong></li>
<li><code>getElementsByName()</code> –&gt; 通过<strong>name属性值</strong>获取<strong>element对象数组</strong></li>
<li><code>getElementsByClass()</code> –&gt; 通过<strong>class属性值</strong>获取<strong>element对象数组</strong></li>
<li><code>getElementsByTagName()</code> –&gt; 通过<strong>标签名称</strong>获取<strong>element对象数组</strong></li>
<li><code>createElement()</code>–&gt; 创建元素对象</li>
</ul>
<h3 id="Element对象"><a href="#Element对象" class="headerlink" title="Element对象"></a>Element对象</h3><h4 id="获取-创建"><a href="#获取-创建" class="headerlink" title="获取/创建"></a>获取/创建</h4><p>使用document中的相应方法获取和创建</p>
<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><ul>
<li><code>getAttribute(&quot;属性名称&quot;)</code> –&gt; 获取属性里面的值</li>
<li><code>setAttribute(&quot;属性名&quot;,&quot;属性值&quot;)</code> –&gt; 设置某个属性的值</li>
<li><code>removeAttribute(&quot;属性名&quot;)</code> –&gt; 删除某个属性<ul>
<li>remove 不能删除<strong>value</strong>属性</li>
</ul>
</li>
</ul>
<p>获取标签下面的子标签</p>
<p>使用<code>getElementsByTagName(&quot;&quot;)</code>，这是唯一有效方法。</p>
<h3 id="Node对象"><a href="#Node对象" class="headerlink" title="Node对象"></a>Node对象</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>parentNode：返回当前节点的父节点</p>
<h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h4><ul>
<li>appendChild()方法 –&gt; 向当前节点的子节点列表末尾添加新的子节点</li>
<li>removeChild()方法 –&gt; 删除（并返回）当前节点的指定子节点</li>
<li>replaceChild(newnode,oldnode)方法 –&gt; 用新节点替换一个子节点</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>所有的DOM对象都可以被看成一个节点</p>
<blockquote>
<p>节点不能自己删除自己，插入、删除、替换都得通过父节点来进行操作</p>
</blockquote>
<h3 id="innerHTML属性（重要）"><a href="#innerHTML属性（重要）" class="headerlink" title="innerHTML属性（重要）"></a>innerHTML属性（<em>重要</em>）</h3><p>设置和获取标签体的内容</p>
<h3 id="控制元素样式"><a href="#控制元素样式" class="headerlink" title="控制元素样式"></a>控制元素样式</h3><ol>
<li><p>使用元素的style属性来设置</p>
<p><code>div1.style.border = &quot;1px solid red&quot;</code></p>
</li>
<li><p>提前定义好类选择器的样式，通过元素的className属性来设置其class属性值</p>
</li>
</ol>
<h3 id="事件☆"><a href="#事件☆" class="headerlink" title="事件☆"></a>事件☆</h3><p>概念：某些组件被执行了某些操作后，触发某些代码的执行</p>
<ul>
<li>事件：某些操作</li>
<li>事件源：组件</li>
<li>监听器：代码</li>
<li>注册监听：将事件、事件源、监听器绑定在一起</li>
</ul>
<p>常见的事件：</p>
<ol>
<li>点击事件<ol>
<li>onclick –&gt; 单击事件</li>
<li>ondblclick –&gt; 双击事件</li>
</ol>
</li>
<li>焦点事件<ol>
<li>onfocus –&gt; 得到焦点</li>
<li>onblur –&gt; 失去焦点</li>
</ol>
</li>
<li>加载事件<ol>
<li>onload –&gt; 一张网页或一幅图像完成加载</li>
</ol>
</li>
<li>鼠标事件<ol>
<li>onmousedown –&gt; 鼠标按钮按下<ul>
<li>定义方法时，定义一个形参，接收event对象，enent对象的button属性可以获取鼠标的那个键被点击了</li>
</ul>
</li>
<li>onmouseup –&gt; 鼠标按钮松开</li>
<li>onmousemove –&gt; 鼠标移动</li>
<li>onmouseover –&gt; 鼠标移动到某元素上</li>
<li>onmouseout –&gt; 鼠标从某元素上移开</li>
</ol>
</li>
<li>键盘事件<ol>
<li>onkeydown –&gt; 某个键盘按键被按下</li>
<li>onkeyup –&gt; 某个键盘按键被松开</li>
<li>onkeypress –&gt; 某个键盘按键按下后松开</li>
</ol>
</li>
<li>选择和改变<ol>
<li>onchange –&gt; 域的内容被改变（一般和select标签一起使用）<ul>
<li>实现 ‘省市联动’ 时使用</li>
</ul>
</li>
<li>onselect –&gt; 文本被选中</li>
</ol>
</li>
<li>表单事件<ol>
<li>onsubmit –&gt; 提交按钮被点击<ul>
<li>可以阻止表单的提交（方法返回false）</li>
</ul>
</li>
<li>onreset –&gt; 重置按钮被点击</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript</title>
    <url>/2019/04/10/Java/2.JavaWeb/3.JavaScript--1/</url>
    <content><![CDATA[<p>JavaScript是ECMAScript的一种实现</p>
<a id="more"></a>

<h1 id="JavaScript–ECMAScript"><a href="#JavaScript–ECMAScript" class="headerlink" title="JavaScript–ECMAScript"></a>JavaScript–ECMAScript</h1><h2 id="初识-JS"><a href="#初识-JS" class="headerlink" title="初识 JS"></a>初识 JS</h2><p>JS 是<strong>基于对象</strong>和<strong>事件驱动</strong>的语言，应用于客户端</p>
<p><strong>特点：</strong>交互性、安全性、跨平台性</p>
<p><strong>组成：</strong>ECMAScript、bom、dom</p>
<p><strong>作用：</strong></p>
<ul>
<li>让网页和用户之间进行直接简单的<strong>交互</strong></li>
<li>可以给网页添加特效和<strong>动画</strong></li>
</ul>
<blockquote>
<p>HTML –&gt; 定义了网页的<strong>内容</strong></p>
<p>CSS  –&gt; 描述了网页的<strong>布局</strong></p>
<p>JavaScript –&gt; 规定了网页的<strong>行为</strong></p>
</blockquote>
<h2 id="JS-的声明"><a href="#JS-的声明" class="headerlink" title="JS 的声明"></a>JS 的声明</h2><p>JS需要在HTML中进行声明</p>
<p><strong>声明方式：</strong></p>
<ul>
<li>使用<strong>script标签声明</strong> JS 代码域</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    alert(<span class="string">"去吧，皮卡丘"</span>);	</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用<strong>script标签引入</strong>外部声明的 JS 文件<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"相对路径"</span> &gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>script标签可以定义在HTML页面的任意位置，建议把script标签放到</body>后面</p>
<p>script可以定义多个</p>
</blockquote>
<h2 id="JS-的变量"><a href="#JS-的变量" class="headerlink" title="JS 的变量"></a>JS 的变量</h2><p>1、变量的声明：使用<strong>var</strong>关键字（JS 为<strong>弱类型</strong>语言）</p>
<p>var  变量名 = 初始值;</p>
<p>如 ： var  a = 1;</p>
<p>2、变量的特点：</p>
<ul>
<li>变量声明只有var关键字，声明的变量可以存储任意类型的数据</li>
<li>允许出现同名变量，后面的值会把前面的值覆盖</li>
<li>声明一个变量但不赋值，默认值为<strong>undefined</strong></li>
</ul>
<p>3、变量的<strong>数据类型</strong></p>
<ul>
<li>变量的数据类型<ul>
<li><strong>number：</strong>数字类型（实数）</li>
<li><strong>string：</strong>字符串类型（包括单个字符）</li>
<li><strong>boolean：</strong>布尔类型</li>
<li><strong>undefined：</strong>声明但未初始化的变量为此类型</li>
</ul>
</li>
<li>引用数据类型<ul>
<li><strong>object：</strong>对象类型</li>
</ul>
</li>
</ul>
<p>使用方法<strong>typeof(变量名)</strong>来判断变量的数据类型</p>
<p>4、变量的<strong>强制类型转换</strong></p>
<ul>
<li>使用<strong>Number</strong>函数，将其他数据类型转换为数值类型，转换失败返回NaN（Not a Number）</li>
<li>使用<strong>Boolean</strong>函数，将其他数据类型转换为布尔类型，有值返回true，无值返回false</li>
</ul>
<p>5、变量的<strong>自动类型转换</strong></p>
<ul>
<li>在需要数字的地方如果给了 其他的类型的变量，会将其他类型自动转换为数字，转换规则如下：<ul>
<li>字符串会按照字面值进行转换，如果字符串无法转换为数字，则运算结果为 NaN</li>
<li>boolean类型：true对应的数值为1，false对应的数值是0</li>
</ul>
</li>
<li>在需要boolean的地方如果给了 其他的类型的变量，会将其他类型自动转换为boolean，转换规则如下：<ul>
<li>number：0和NaN为false，其它为true</li>
<li>string：空字符串为false，其它为true</li>
<li>null &amp; undefined ：都为false</li>
<li>对象：所有对象都为true</li>
</ul>
</li>
</ul>
<p>6、特殊的值</p>
<ul>
<li>null –类型–&gt; object</li>
<li>undefined –类型–&gt;  undefined</li>
<li>NaN –类型–&gt; number</li>
</ul>
<p>7、JS 的全局变量和局部变量</p>
<ul>
<li><p>全局变量：</p>
<ul>
<li>在script标签中定义了一个变量，这个变量在页面中js部分（包括其他script标签）都可以使用</li>
</ul>
</li>
<li><p>局部变量</p>
<ul>
<li>在方法内部定义的变量，只能在方法内部使用，如果在方法外部调用，会报错</li>
</ul>
</li>
</ul>
<h2 id="JS-的运算符"><a href="#JS-的运算符" class="headerlink" title="JS 的运算符"></a>JS 的运算符</h2><p>JS 的大部分运算符都和Java是一样的，不一样的如下：</p>
<p>1、关于数值类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">123</span>;</span><br><span class="line">alert(a/<span class="number">1000</span>*<span class="number">1000</span>); <span class="comment">// 输出的结果是：123，因为JS的数据是不分整数和小数的</span></span><br><span class="line"><span class="comment">// 但是Java中得到的结果是0</span></span><br></pre></td></tr></table></figure>

<p>2、字符串和数字的相加相减操作</p>
<ul>
<li>相加的时候执行的是字符串的连接</li>
<li>相减的时候执行的是减法（做减法之前会先把字符串按照字面值转换为数字，如果字符串无法转换为数字，则运算结果为 NaN）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"456"</span>;</span><br><span class="line">alert(str+<span class="number">1</span>);<span class="comment">// 得到的结果是string："4561"</span></span><br><span class="line">alert(str<span class="number">-1</span>);<span class="comment">// 得到的结果是number：455</span></span><br></pre></td></tr></table></figure>

<p>3、boolean类型的运算</p>
<ul>
<li>如果boolean变量的值为true，则对应的数值为1</li>
<li>如果boolean变量的值为false，则对应的数值是0</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line">alert(flag+<span class="number">1</span>);<span class="comment">// 得到的结果是number：2</span></span><br><span class="line"><span class="keyword">var</span> flag1 = <span class="literal">false</span>;</span><br><span class="line">alert(flag1+<span class="number">1</span>);<span class="comment">// 得到的结果是number：1</span></span><br></pre></td></tr></table></figure>

<p>4、== 和 ===</p>
<ul>
<li>== 判断<strong>值</strong>是否相同，返回true/false</li>
<li>=== 判断<strong>值和类型</strong>是否相同，返回true/false</li>
</ul>
<h2 id="JS的语句"><a href="#JS的语句" class="headerlink" title="JS的语句"></a>JS的语句</h2><p>1、if判断语句</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">if</span>(m==<span class="number">5</span>) &#123;</span><br><span class="line">   alert(<span class="string">"m=5"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(m==<span class="number">6</span>) &#123;</span><br><span class="line">    alert(<span class="string">"m==5"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    alert(<span class="string">"m!=5 &amp; m!=6"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2、switch语句</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	在js中的switch语句和Java中不太一样</span></span><br><span class="line"><span class="comment">	Java中：switch只能接收：byte，short，int，String（jdk1.7之后），enum（jdk1.5之后）</span></span><br><span class="line"><span class="comment">	js中：switch可以接收所有原始数据类型：String，number，boolean，null,undefined</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">switch</span>(b)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">		alert(<span class="string">"3"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    	alert(<span class="string">"6"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        alert(<span class="string">"other"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>3、循环语句</p>
<ul>
<li>for语句</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">    alert(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>while语句</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">while</span>(a&lt;<span class="number">6</span>)&#123;</span><br><span class="line">    alert(a);</span><br><span class="line">    a++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>PS</p>
<p>直接向页面输出的语句：</p>
<p>document.write(“abc”);<br>document.write(“<code>&lt;hr&gt;</code>“);  // 可以输出HTML的标签</p>
</blockquote>
<h2 id="JS中的对象"><a href="#JS中的对象" class="headerlink" title="JS中的对象"></a>JS中的对象</h2><h3 id="String对象"><a href="#String对象" class="headerlink" title="String对象"></a>String对象</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>​    var str = “abc”;</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>length –&gt; 字符串的长度</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul>
<li>与HTML相关的方法<ul>
<li>bold() –&gt; 加粗</li>
<li>fontcolor(“color”) –&gt; 设置字体颜色</li>
<li>fontsize(1-7) –&gt; 设置字体大小，<em>1最小，7最大</em></li>
<li>link(“url”) –&gt; 将字符串设置成超链接</li>
<li>sub() 和 sup() –&gt; 设置上标和下标</li>
</ul>
</li>
<li>与Java相似的方法<ul>
<li>concat() –&gt; 连接字符串</li>
<li>charAt() –&gt; 返回指定位置的字符</li>
<li>indexOf() –&gt; 返回指定字符的索引</li>
<li>split() –&gt; 切分字符串</li>
<li>replace(“被替换”,”替换”) –&gt; 替换字符串</li>
<li>substr() 和 substring()<ul>
<li>substr(a,b) –&gt; 从第a位开始，向后截取b位</li>
<li>substring(a,b) –&gt; 从第a位开始，到第b位结束，不包含最后一位</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Function-函数（方法）对象"><a href="#Function-函数（方法）对象" class="headerlink" title="Function 函数（方法）对象"></a>Function 函数（方法）对象</h3><h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><ol>
<li><p>使用关键字 function</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 方法名（参数列表）</span>&#123;</span><br><span class="line">    <span class="comment">// 方法体；</span></span><br><span class="line">    <span class="comment">// 返回值；（可有可无）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>匿名函数，使用关键字 function，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fun = <span class="function"><span class="keyword">function</span>（参数列表）</span>&#123;</span><br><span class="line">	<span class="comment">// 方法体；</span></span><br><span class="line">	<span class="comment">// 返回值；（可有可无）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态函数（<em>了解即可</em>），使用内置对象 Function</p>
<p><code>(var a =) new Function (&quot;参数列表&quot;,&quot;方法体; 返回值;&quot;);</code></p>
</li>
</ol>
<h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><p>length：代表形参的个数</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>1、定义方法时，形参类型不用写，返回值类型也不用写</p>
<p>2、如果定义重名方法，后面定义的会把前面定义的覆盖</p>
<p>3、在 JS 中，方法的调用只与方法的名称有关，与方法的参数无关</p>
<p>4、在方法的声明中有一个隐藏的内置对象 arguments，它是一个数组，封装了所有的实际参数</p>
<blockquote>
<p><strong>JS 的函数重载</strong></p>
<p>问：</p>
<p>JS 中是否存在重载（面试题目）</p>
<p>答：</p>
<p>1、JS 中不存在重载</p>
<p>2、但是可以通过其他方式模拟重载的效果（利用arguments数组实现）</p>
</blockquote>
<h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><p><code>方法名称(参数列表)</code></p>
<h3 id="Array-对象"><a href="#Array-对象" class="headerlink" title="Array 对象"></a>Array 对象</h3><h4 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h4><ol>
<li>var arr = [元素列表];</li>
<li>var arr1 = new Array(默认长度);</li>
<li>var arr2 = new Array(元素列表); </li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="string">"2"</span>,<span class="literal">true</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种，使用内置对象Array</span></span><br><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>); <span class="comment">// 定义一个数组，长度为5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种，使用内置对象Array</span></span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// 定义一个数组，数组中的元素为：1 2 3</span></span><br></pre></td></tr></table></figure>

<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><ul>
<li>concat() –&gt; 连接两个数组</li>
<li>join() –&gt; 更换分割数组中元素的字符</li>
<li>push() –&gt; 向数组末尾添加元素，返回新的数组的长度</li>
<li>pop() –&gt; 删除数组的最后一个元素，并返回最后一个元素</li>
<li>reverse() –&gt; 将数组逆序</li>
</ul>
<h4 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h4><p>length：获取数组的长度</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>JS 的数组可以存放<strong>不同的数据类型</strong></p>
<p>JS 的数组<strong>长度是可变的</strong></p>
<h3 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象"></a>Date对象</h3><h4 id="创建-3"><a href="#创建-3" class="headerlink" title="创建"></a>创建</h4><p>var date = new Date();</p>
<h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h4><p>toLocaleString()：将获取到的时间转换成习惯的格式</p>
<p>获取当前年.月.日，时.分.秒，毫秒</p>
<ul>
<li>年 –&gt; getFullYear() –&gt; 获取四位数年份</li>
<li>月 –&gt; getMonth() –&gt; 返回 0 - 11</li>
<li>日(星期) –&gt; getDay() –&gt; 返回 0 - 6，星期日为 0</li>
<li>日(月) –&gt; getDate() –&gt; 返回 1 - 31</li>
<li>时 –&gt; getHours()</li>
<li>分 –&gt; getMinutes()</li>
<li>秒 –&gt; getSeconds()</li>
<li>毫秒 –&gt; getTime –&gt; 返回1970年1月1日至今的毫秒数</li>
</ul>
<h3 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h3><h4 id="创建-4"><a href="#创建-4" class="headerlink" title="创建"></a>创建</h4><p>Math对象不需要创建，直接 <strong>Math.方法名</strong> 使用</p>
<h4 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h4><p>PI –&gt; 圆周率</p>
<h4 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h4><ul>
<li><p>random() –&gt; 返回0~1之间的随机数，[0,1)</p>
</li>
<li><p>ceil() –&gt; 向上舍入</p>
</li>
<li><p>floor() –&gt; 向下舍入</p>
</li>
<li><p>round() –&gt; 四舍五入</p>
</li>
</ul>
<h3 id="RegExp对象"><a href="#RegExp对象" class="headerlink" title="RegExp对象"></a>RegExp对象</h3><h4 id="创建-5"><a href="#创建-5" class="headerlink" title="创建"></a>创建</h4><p>1、<code>var reg = new RegExp(&quot;正则表达式&quot;);</code></p>
<p>2、<code>var reg = /正则表达式/;</code>(常用)</p>
<h4 id="方法-4"><a href="#方法-4" class="headerlink" title="方法"></a>方法</h4><p><code>test(参数字符串)</code> –&gt; 验证指定的字符串是否符合定义的正则表达式的规范</p>
<h2 id="Global对象"><a href="#Global对象" class="headerlink" title="Global对象"></a>Global对象</h2><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><p>Global对象为全局对象，其中封装的方法不需要对象，可以直接写名称使用</p>
<h4 id="方法-5"><a href="#方法-5" class="headerlink" title="方法"></a>方法</h4><ul>
<li>eval() –&gt; 执行js代码（如果一个字符串的内容是js代码，使用此方法可以直接执行）</li>
<li>encodeURI() –&gt; 对字符进行编码</li>
<li>decodeURI() –&gt; 对字符进行解码</li>
<li>isNaN() –&gt; 判断是否不是数字，不是返回true，是返回false</li>
<li>parseInt() –&gt; 类型转换（将字符串转换为数字）<ul>
<li>逐一判断每一个字符是不是数字，直到不是数字为止，将数字部分转为number</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS</title>
    <url>/2019/04/08/Java/2.JavaWeb/2.CSS/</url>
    <content><![CDATA[<p>CSS主要是给HTML”美容“的</p>
<a id="more"></a>

<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="一、CSS的基本概念"><a href="#一、CSS的基本概念" class="headerlink" title="一、CSS的基本概念"></a>一、CSS的基本概念</h3><p><strong>CSS</strong>（Cascading Style Sheets）：层叠样式表</p>
<p><strong>作用：</strong>给HTML或XML添加样式的计算机语言</p>
<h3 id="二、CSS的声明"><a href="#二、CSS的声明" class="headerlink" title="二、CSS的声明"></a>二、CSS的声明</h3><p>1、在标签上使用style属性进行声明 (<em>内联样式</em>)–<u>不常用</u></p>
<p>​    作用：此声明会将css样式直接作用于<strong>当前标签</strong></p>
<p>2、在head标签中使用style标签声明 (<em>内部样式</em>)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作用：此声明一般声明<strong>当前网页</strong>的公共样式</p>
<p>3、在head标签中使用link标签引入外部声明好的css文件 (<em>外部样式</em>)</p>
<p>​    作用：此声明适用于<strong>不同网页</strong>间样式重复使用的问题</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在head标签中使用style标签声明 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    hr&#123;</span><br><span class="line">        width: 50%;</span><br><span class="line">        height: 10px;</span><br><span class="line">        background: red;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在head标签中使用link标签引入外部声明好的css文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"css文件路径"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在标签上使用style属性进行声明 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span> <span class="attr">style</span>=<span class="string">"background: blue;"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>不同的声明给同一个标签操作了同一个样式，遵循就近原则进行显示</p>
</blockquote>
<h3 id="三、CSS的选择器"><a href="#三、CSS的选择器" class="headerlink" title="三、CSS的选择器"></a>三、CSS的选择器</h3><ol>
<li><p><strong>标签选择器</strong>：将当前网页内的所有该标签增加相同的样式</p>
<p><code>标签名{样式名1:样式值1;......}</code></p>
</li>
<li><p><strong>id选择器</strong>：选择具体的id属性值的元素</p>
<p><code>#id属性值{样式名1:样式值1;......}</code></p>
</li>
<li><p><strong>类选择器</strong>：选择具有<strong>相同class属性值</strong>的元素</p>
<p><code>.class属性值{样式名1:样式值1;......}</code></p>
</li>
<li><p><strong>全部选择选择器</strong>：选择所有的HTML标签，并添加相同的样式</p>
<p><code>*{样式名1:样式值1;......}</code></p>
</li>
</ol>
<hr>
<ol>
<li><p><strong>组合选择器</strong>：解决不同的选择器之间重复样式的问题</p>
<p><code>选择器1,选择器2{样式名1:样式值1;......}</code></p>
</li>
<li><p><strong>子标签选择器</strong></p>
<p><code>选择器1 子标签选择器2{样式名1:样式值1;......}</code></p>
</li>
<li><p><strong>属性选择器</strong>：指定某属性为特定值的标签的样式</p>
<p><code>标签名[属性名=&quot;属性值&quot;]{样式名1:样式值1;......}</code></p>
</li>
<li><p><strong>伪类选择器</strong>：选择一些元素具有的状态,</p>
<p><code>元素:状态{}</code></p>
</li>
</ol>
<hr>
<p><strong>CSS的使用过程：</strong></p>
<ol>
<li>声明CSS代码域</li>
<li>使用选择器选择要添加样式的标签<ol>
<li>使用*选择器给整个页面添加基础样式</li>
<li>使用类选择器给不同的标签添加基础样式</li>
<li>使用标签选择器给某类标签添加基础样式</li>
<li>使用id选择器、属性选择器、style属性声明给单独标签添加样式</li>
</ol>
</li>
<li>书写样式单</li>
</ol>
<h2 id="CSS的常用样式"><a href="#CSS的常用样式" class="headerlink" title="CSS的常用样式"></a>CSS的常用样式</h2><ul>
<li><strong>边框</strong>设置<ul>
<li>border:solid 1px;</li>
</ul>
</li>
<li><strong>字体</strong>设置<ul>
<li>font-size:10px; –&gt; 设置字体大小</li>
<li>font-family:”宋体”； –&gt; 设置字体格式</li>
<li>font-weight:bold; –&gt; 加粗</li>
</ul>
</li>
<li><strong>字体颜色</strong>设置<ul>
<li>color:颜色;</li>
</ul>
</li>
<li><strong>背景颜色</strong>设置<ul>
<li>background-color:颜色;</li>
</ul>
</li>
<li><strong>背景图片</strong>设置<ul>
<li>background-image:url(图片路径); –&gt; 设置背景图片</li>
<li>background-repeat:no-repeat; –&gt; 设置图片不重复</li>
<li>background-size:cover; –&gt; 图片平铺整个页面</li>
</ul>
</li>
<li><strong>高和宽</strong>设置<ul>
<li>width:200px;</li>
<li>height:300px;</li>
</ul>
</li>
<li><strong>浮动</strong>设置<ul>
<li>float:left/right;</li>
<li>浮动设置可将列表横向显示</li>
</ul>
</li>
<li><strong>行高(行间距)</strong>设置<ul>
<li>line-height:10;</li>
</ul>
</li>
</ul>
<h2 id="CSS的盒子模型"><a href="#CSS的盒子模型" class="headerlink" title="CSS的盒子模型"></a>CSS的盒子模型</h2><p><strong>div标签：</strong></p>
<p>块级标签，主要是用来进行网页布局的，会将其中的子元素内容作为一个独立的整体存在</p>
<p>特点：</p>
<ul>
<li>默认宽度是页面的宽度，可以设置</li>
<li>默认没有高度，可以设置</li>
</ul>
<p><strong>盒子模型：</strong></p>
<p>由内向外以此为：</p>
<ul>
<li><p>内容区域：</p>
<ul>
<li>作用：改变内容区域的大小</li>
<li>设置宽和高即可改变内容区域的大小</li>
</ul>
</li>
<li><p>内边距：padding</p>
<ul>
<li>作用：设置<strong>内容和边框</strong>之间的距离</li>
<li>注意：内边距不会改变内容区域的大小</li>
<li>可以单独设置上下左右</li>
</ul>
</li>
<li><p>边框：border</p>
<ul>
<li>作用：用来设置元素边框的大小</li>
<li>可以单独设置上下左右</li>
</ul>
</li>
<li><p>外边距：margin</p>
<ul>
<li>作用：用于设置元素和元素之间的间隔</li>
<li>居中设置：margin: 0px auto; 上下间距为0，左右居中</li>
<li>可以单独设置上下左右</li>
</ul>
</li>
</ul>
<h2 id="CSS的定位"><a href="#CSS的定位" class="headerlink" title="CSS的定位"></a>CSS的定位</h2><p><strong>position：</strong></p>
<ul>
<li>相对定位：<strong>relative</strong><ul>
<li>作用：相对元素原有的位置移动指定的距离</li>
<li>注意：其他元素的位置是不改变的</li>
</ul>
</li>
<li>绝对定位：<strong>absolute</strong><ul>
<li>作用：相对于元素的参照界面进行移动</li>
<li>注意：默认参照元素为界面，如果父级元素使用了相对定位，则成为参照元素</li>
</ul>
</li>
<li>固定定位：<strong>fixed</strong><ul>
<li>作用：将元素固定在页面的指定位置</li>
</ul>
</li>
</ul>
<blockquote>
<p>以上定位都可以用top、bottom、left、right来进行移动</p>
</blockquote>
<p><strong>z-index：</strong>声明元素的显示级别</p>
<p><strong>hover：</strong>可用于设置与鼠标相关的动作</p>
<h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 去除无序列表前的黑点 --&gt;</span></span><br><span class="line">li&#123;list-style-type: none;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 去除超链接下滑线 --&gt;</span></span><br><span class="line">a&#123;text-decoration: none;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模拟360主页"><a href="#模拟360主页" class="headerlink" title="模拟360主页"></a>模拟360主页</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*&#123;<span class="attribute">margin</span>: <span class="number">0px</span>; <span class="attribute">padding</span>: <span class="number">0px</span>;&#125;</span><br><span class="line"><span class="selector-id">#header</span>&#123;<span class="attribute">width</span>: <span class="number">100%</span>; <span class="attribute">height</span>: <span class="number">36px</span>;&#125;</span><br><span class="line">	<span class="selector-id">#header_left</span>&#123;<span class="attribute">position</span>: absolute; <span class="attribute">left</span>: <span class="number">10px</span>; <span class="attribute">top</span>:<span class="number">10px</span>;&#125;</span><br><span class="line">	<span class="selector-id">#header_right</span>&#123;<span class="attribute">position</span>: absolute; <span class="attribute">right</span>: <span class="number">0px</span>; <span class="attribute">top</span>:<span class="number">10px</span>;&#125;</span><br><span class="line">	<span class="selector-id">#header_left</span> <span class="selector-tag">li</span>&#123;<span class="attribute">float</span>: left; <span class="attribute">list-style-type</span>: none; <span class="attribute">margin-right</span>: <span class="number">20px</span>;&#125;</span><br><span class="line">	<span class="selector-id">#header_right</span> <span class="selector-tag">li</span>&#123;<span class="attribute">float</span>: left; <span class="attribute">list-style-type</span>: none; <span class="attribute">margin-right</span>: <span class="number">20px</span>;&#125;</span><br><span class="line">	<span class="selector-id">#header_left</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span>&#123;<span class="attribute">font-size</span>: <span class="number">13px</span>; <span class="attribute">color</span>: <span class="number">#666666</span>; <span class="attribute">text-decoration</span>: none; &#125;</span><br><span class="line">	<span class="selector-id">#header_right</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span>&#123;<span class="attribute">font-size</span>: <span class="number">13px</span>; <span class="attribute">color</span>: <span class="number">#666666</span>; <span class="attribute">text-decoration</span>: none; &#125;</span><br><span class="line"><span class="selector-id">#main</span>&#123;<span class="attribute">width</span>: <span class="number">100%</span>; <span class="attribute">height</span>: <span class="number">532px</span>; <span class="attribute">text-align</span>: center;&#125;</span><br><span class="line">	<span class="selector-id">#img_logo</span>&#123;<span class="attribute">margin-top</span>: <span class="number">56px</span>;<span class="attribute">margin-bottom</span>: <span class="number">45px</span>;&#125;</span><br><span class="line">	<span class="selector-tag">input</span><span class="selector-attr">[type=text]</span>&#123;<span class="attribute">width</span>: <span class="number">441px</span>; <span class="attribute">height</span>: <span class="number">46px</span>;&#125;</span><br><span class="line">	<span class="selector-tag">input</span><span class="selector-attr">[type=submit]</span>&#123;<span class="attribute">width</span>: <span class="number">100px</span>; <span class="attribute">height</span>: <span class="number">46px</span>;<span class="attribute">border</span>: <span class="number">0px</span>;<span class="attribute">background-color</span>: <span class="number">#19B955</span>; <span class="attribute">position</span>: relative; <span class="attribute">right</span>: <span class="number">6px</span>; <span class="attribute">top</span>: <span class="number">1px</span>;&#125;</span><br><span class="line"><span class="selector-id">#footer</span>&#123;<span class="attribute">width</span>: <span class="number">100%</span>; <span class="attribute">height</span>: <span class="number">90px</span>; <span class="attribute">text-align</span>: center;&#125;</span><br><span class="line">	<span class="selector-id">#img_bottom</span>&#123;<span class="attribute">margin-top</span>: <span class="number">37px</span>;&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>360搜索<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"360搜索.css"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"shortcut icon"</span> <span class="attr">href</span>=<span class="string">"img/360so.ico"</span> <span class="attr">type</span>=<span class="string">"image/x-icon"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"header_left"</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>360导航<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>资讯<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>视频<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>图片<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>良医<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>地图<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>百科<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>英文<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"header_right"</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>设置<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>换肤<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>提醒<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">"img_logo"</span> <span class="attr">src</span>=<span class="string">"img/360搜索.png"</span>  /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"https://www.so.com/s"</span> <span class="attr">method</span>=<span class="string">"get"</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"q"</span> /&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"搜索"</span> /&gt;</span></span><br><span class="line"> 			<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"footer"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">"img_bottom"</span> <span class="attr">src</span>=<span class="string">"img/360bottom.png"</span>  /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML</title>
    <url>/2019/04/06/Java/2.JavaWeb/1.HTML/</url>
    <content><![CDATA[<p>HTML是互联网的三大基石之一</p>
<a id="more"></a>

<p><img src="/images/HTML.jpg" alt=""></p>
<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="一、HTML的基本概念"><a href="#一、HTML的基本概念" class="headerlink" title="一、HTML的基本概念"></a>一、HTML的基本概念</h2><p><strong>1、</strong>HTML（Hyper Text Markup Language）：<strong>超文本标记语言</strong></p>
<ul>
<li>HTML 是由<strong>浏览器</strong>解析执行的</li>
</ul>
<p><strong>2、</strong>作用：告诉浏览器接收到的数据以何种<strong>数据组织</strong>形式进行展示</p>
<p><strong>3、</strong>互联网的三大基石：</p>
<ul>
<li>URL</li>
<li>HTTP</li>
<li>HTML</li>
</ul>
<p><strong>4、</strong>HTML文档后缀名：<strong>html</strong> 或 <strong>htm</strong></p>
<p><strong>5、</strong>HTML的标签分类：</p>
<ul>
<li>围堵标签：有开始标签和结束标签，如<code>&lt;html&gt; &lt;/html&gt;</code></li>
<li>自闭和标签：开始标签和结束标签在一起，如<code>&lt;br/&gt;</code></li>
</ul>
<p><strong>6、</strong>HTML标签不区分大小写，建议使用小写</p>
<p><strong>7、</strong>在开始标签中可以定义属性。属性是由键值对构成，值需要用引号（单双都可）引起来</p>
<p><strong>8、</strong>标准文档结构：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">			这个标签是HTML的注释</span></span><br><span class="line"><span class="comment">			头标签里面主要是浏览器显示数据的配置信息</span></span><br><span class="line"><span class="comment">		--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        this is my first html</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br/>

<h2 id="二、head标签"><a href="#二、head标签" class="headerlink" title="二、head标签"></a>二、head标签</h2><p><strong>1、网页标题标签</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>好好学习，天天向上<span class="tag">&lt;/<span class="name">title</span>&gt;</span> <span class="comment">&lt;!-- 配置网页标题 --&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>2、编码格式标签</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>/&gt;</span> <span class="comment">&lt;!-- 告诉浏览器使用指定的编码格式解析文档（HTML5） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"content-type"</span> <span class="attr">content</span>=<span class="string">"text/html,charset=utf-8"</span>/&gt;</span> <span class="comment">&lt;!-- HTML4 --&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>3、网页搜索优化标签</strong>(认识即可)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"keywords"</span> <span class="attr">content</span>=<span class="string">"HTML,练习"</span>/&gt;</span> <span class="comment">&lt;!-- 网页关键字 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">"这个网页是学习HTML的一个练习网页"</span>/&gt;</span> <span class="comment">&lt;!-- 网页描述 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"author"</span> <span class="attr">content</span>=<span class="string">"me"</span>/&gt;</span> <span class="comment">&lt;!-- 网页作者 --&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>4、网页自动跳转标签</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"refresh"</span>  <span class="attr">content</span>=<span class="string">"5,url=http://www.baidu.com"</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>5、其他标签</strong></p>
<p>​    css引入标签、js引入标签</p>
<h2 id="三、body标签–文本标签"><a href="#三、body标签–文本标签" class="headerlink" title="三、body标签–文本标签"></a>三、body标签–文本标签</h2><p><strong>1、标题标签</strong></p>
<p><strong>h1到h6：</strong>将其中的文本<strong>加粗加黑</strong>显示，<strong>自动换行</strong>（块级标签）</p>
<p>属性：<strong>align</strong>：<strong>center  left  right</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span> Hello World <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>2、水平线标签</strong></p>
<p><strong>hr：</strong>会在页面中显示一条水平线，默认<strong>全尺寸</strong>居中显示</p>
<p>属性：</p>
<ul>
<li><strong>width</strong>=“宽度”</li>
<li><strong>size</strong>=“高度”</li>
<li><strong>color</strong>=“颜色”</li>
<li><strong>align</strong>=”位置”</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hr</span> <span class="attr">width</span>=<span class="string">"800px"</span> <span class="attr">size</span>=<span class="string">"20px"</span> <span class="attr">color</span>=<span class="string">"red"</span> <span class="attr">align</span>=<span class="string">"center"</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>3、段落标签</strong></p>
<p><strong>p：</strong>会将一段数据作为整体进行显示，方便css和js操作，<strong>自动换行</strong>（块级标签）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    这是一段文字，作为一个整体进行显示</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>4、换行标签</strong></p>
<p><strong>br：</strong>在此位置换行</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">你好<span class="tag">&lt;<span class="name">br</span> /&gt;</span>再见<span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>5、空格符</strong></p>
<p><strong>&amp;nbsp ;</strong> –&gt; 在此位置增加空格</p>
<p><strong>6、权重标签</strong></p>
<p><strong>b：</strong>将内容<strong>加黑</strong>显示</p>
<p><strong>i：</strong>将内容<strong>斜体</strong>显示</p>
<p><strong>u：</strong>将内容加<strong>下划线</strong></p>
<p><strong>del：</strong>将内容加<strong>删除线</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>加黑<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span>&gt;</span>斜体<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">u</span>&gt;</span>下划线<span class="tag">&lt;/<span class="name">u</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">del</span>&gt;</span>删除线<span class="tag">&lt;/<span class="name">del</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="四、body标签–列表标签"><a href="#四、body标签–列表标签" class="headerlink" title="四、body标签–列表标签"></a>四、body标签–列表标签</h2><p>无序列表</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>广州<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>有序列表</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 属性:type="1","a","A","I" --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">"a"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>早饭<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>午饭<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>晚饭<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>自定义列表</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>一线城市：<span class="tag">&lt;/<span class="name">dt</span>&gt;</span> <span class="comment">&lt;!-- 数据的标题 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>成都<span class="tag">&lt;/<span class="name">dd</span>&gt;</span> <span class="comment">&lt;!-- 数据的内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>西安<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>杭州<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="五、body标签–图片标签"><a href="#五、body标签–图片标签" class="headerlink" title="五、body标签–图片标签"></a>五、body标签–图片标签</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"图片路径"</span> <span class="attr">width</span>=<span class="string">200px</span> <span class="attr">title</span>=<span class="string">"图片"</span> <span class="attr">alt</span>=<span class="string">"图片丢失了"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 只修改图片的一个尺寸属性时，图片会等比例变化 --&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>1、</strong>图片标签支持<strong>静态图片</strong>和<strong>动态图片</strong></p>
<p><strong>2、</strong>图片标签为<strong>行内元素</strong>，不会自动换行</p>
<p><strong>3、</strong>图片路径：</p>
<ul>
<li>本地：相对路径或绝对路径，常用相对路径</li>
<li>网络：图片URL</li>
</ul>
<p><strong>4、</strong>属性：</p>
<ul>
<li>width=“图片宽度”</li>
<li>height=”图片高度”</li>
<li>title=“图片标题”，鼠标放到图片上的时候会显示</li>
<li>alt=“图片加载失败时显示的文字”</li>
</ul>
<h2 id="六、超链接标签"><a href="#六、超链接标签" class="headerlink" title="六、超链接标签"></a>六、超链接标签</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"链接路径"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>链接点击处<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>a标签属性：</strong></p>
<ul>
<li><p>超链接标签为<strong>行内元素</strong>，无自动换行功能</p>
</li>
<li><p><strong>href：</strong>要跳转的网页资源路径</p>
<ul>
<li>可以是本地资源（本地html文件，建议填写相对路径）</li>
<li>也可以是网络资源（URL）</li>
</ul>
</li>
<li><p><strong>target：</strong>指明跳转之后的网页显示的位置</p>
<ul>
<li>_self –&gt; 在当前页刷新显示</li>
<li>_blank –&gt; 在新的标签页中打开</li>
<li>_top –&gt; 在顶层页面中显示</li>
<li>_parent –&gt; 在父级页面中显示</li>
</ul>
</li>
</ul>
<p><strong>链接点击处：</strong></p>
<ul>
<li>可以是文字</li>
<li>也可以是图片</li>
</ul>
<p><strong>锚点标签：</strong></p>
<ul>
<li><p><strong>作用：</strong>在一张网页中进行资源跳转</p>
</li>
<li><p><strong>使用：</strong></p>
<ul>
<li><p>1、使用超链接标签在指定的位置增加锚点：</p>
</li>
<li><pre><code class="html"><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">"锚点名"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span>
<span class="comment"><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 2、使用a标签跳转到指定锚点：</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;html</span><br><span class="line">  &lt;a href&#x3D;&quot;#锚点名&quot;&gt;点击处&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure></span></code></pre>
</li>
</ul>
</li>
<li><p><strong>回到顶部：</strong></p>
</li>
</ul>
<p>在网页底部添加如下标签：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>回到顶部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="七、表格标签"><a href="#七、表格标签" class="headerlink" title="七、表格标签"></a>七、表格标签</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>表格标签<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        	表格标签学习：</span></span><br><span class="line"><span class="comment">        		table：声明一个表格</span></span><br><span class="line"><span class="comment">        			tr：声明一行，可以设置该行的高度</span></span><br><span class="line"><span class="comment">        				th：声明表头单元格，默认居中加黑显示,可通过表头设置该列的宽度</span></span><br><span class="line"><span class="comment">        				td：声明普通单元格，默认居左显示</span></span><br><span class="line"><span class="comment">        		属性：</span></span><br><span class="line"><span class="comment">        			border：给表格添加边框</span></span><br><span class="line"><span class="comment">        			width：设置表格宽度</span></span><br><span class="line"><span class="comment">        			height：设置表格高度</span></span><br><span class="line"><span class="comment">        			cellpadding：设置内容距边框的距离</span></span><br><span class="line"><span class="comment">        			cellspacing：设置边框的宽度</span></span><br><span class="line"><span class="comment">        		特点：默认根据数据的多少进行表格的大小显示	</span></span><br><span class="line"><span class="comment">        		</span></span><br><span class="line"><span class="comment">        	单元格的合并：</span></span><br><span class="line"><span class="comment">        		1、确保单元格是一个规整的表格</span></span><br><span class="line"><span class="comment">        		2、根据要合并的单元格，找到其源码位置</span></span><br><span class="line"><span class="comment">        		3、使用单元格合并属性进行合并</span></span><br><span class="line"><span class="comment">       				行合并：rowspan="要合并的单元格个数"</span></span><br><span class="line"><span class="comment">       				列合并：colspan="要合并的单元格个数"</span></span><br><span class="line"><span class="comment">       			4、删除被合并的位置的单元格	</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">h3</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span>学生信息统计表<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1px"</span> <span class="attr">cellpadding</span>=<span class="string">"10px"</span> <span class="attr">cellspacing</span>=<span class="string">"0px"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">tr</span> <span class="attr">height</span>=<span class="string">"75px"</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">th</span> <span class="attr">width</span>=<span class="string">"150"</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">th</span> <span class="attr">width</span>=<span class="string">"150"</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">th</span> <span class="attr">width</span>=<span class="string">"150"</span>&gt;</span>身高<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">th</span> <span class="attr">width</span>=<span class="string">"150"</span>&gt;</span>体重<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">td</span>&gt;</span>小明<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">td</span>&gt;</span>18<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">td</span>&gt;</span>175<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">td</span>&gt;</span>70<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">td</span>&gt;</span>小红<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>19<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>165<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>55<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">td</span>&gt;</span>小强<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">td</span>&gt;</span>20<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">td</span>&gt;</span>185<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">td</span>&gt;</span>80<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">table</span>&gt;</span>	</span><br><span class="line">		</span><br><span class="line">			<span class="tag">&lt;<span class="name">h3</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span>单元格合并<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1px"</span> <span class="attr">cellpadding</span>=<span class="string">"10px"</span> <span class="attr">cellspacing</span>=<span class="string">"0px"</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">tr</span> <span class="attr">height</span>=<span class="string">"50px"</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span> <span class="attr">width</span>=<span class="string">"100px"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span> <span class="attr">width</span>=<span class="string">"100px"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span> <span class="attr">width</span>=<span class="string">"100px"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span> <span class="attr">width</span>=<span class="string">"100px"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span> <span class="attr">width</span>=<span class="string">"100px"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span> <span class="attr">width</span>=<span class="string">"100px"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">tr</span> <span class="attr">height</span>=<span class="string">"50px"</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">tr</span> <span class="attr">height</span>=<span class="string">"50px"</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span> <span class="attr">rowspan</span>=<span class="string">"2"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">tr</span> <span class="attr">height</span>=<span class="string">"50px"</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">tr</span> <span class="attr">height</span>=<span class="string">"50px"</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"2"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">tr</span> <span class="attr">height</span>=<span class="string">"50px"</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="八、内嵌标签"><a href="#八、内嵌标签" class="headerlink" title="八、内嵌标签"></a>八、内嵌标签</h2><p><strong>iframe</strong></p>
<p><strong>作用：</strong>在当前网页中加载其他网页的资源，达到同一个页面显示多个网页资源的目的</p>
<p><strong>属性：</strong></p>
<ul>
<li>src：要显示的网页路径（本地或网络）</li>
<li>width：设置显示区域的宽度</li>
<li>height：设置显示区域的高度</li>
<li>name：设置内嵌区域的名字，结合超链接标签的target属性使用</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span> <span class="attr">target</span>=<span class="string">"_if"</span>&gt;</span>百度一下<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">width</span>=<span class="string">"50%"</span> <span class="attr">height</span>=<span class="string">"400px"</span> <span class="attr">name</span>=<span class="string">"_if"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://www.taobao.com"</span> <span class="attr">width</span>=<span class="string">"50%"</span> <span class="attr">height</span>=<span class="string">"400px"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="九、框架标签"><a href="#九、框架标签" class="headerlink" title="九、框架标签"></a>九、框架标签</h2><p><strong>frameset</strong>：可以实现iframe的功能，但更灵活</p>
<p><strong>作用：</strong>把当前页面切分成不同的块，每一块都可以独立的显示一个网页</p>
<p><strong>属性：</strong></p>
<ul>
<li><p>rows：按照行切分页面</p>
</li>
<li><p>cols：按照列切分页面</p>
</li>
<li><p><strong>子标签：frame</strong> –&gt; 进行切分区域的占位</p>
<ul>
<li>src：资源路径</li>
<li>name：区域名称，结合超链接使用</li>
</ul>
</li>
</ul>
<p><strong>注意事项：</strong></p>
<p>使用框架标签时要<strong>删除body标签</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>框架标签<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">frameset</span> <span class="attr">rows</span>=<span class="string">"50%,*"</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"http://www.baidu.com"</span>&gt;</span><span class="tag">&lt;/<span class="name">frame</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">name</span>=<span class="string">"_bottom"</span>&gt;</span><span class="tag">&lt;/<span class="name">frame</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="十、form标签-amp-表单域标签"><a href="#十、form标签-amp-表单域标签" class="headerlink" title="十、form标签&amp;表单域标签"></a>十、form标签&amp;表单域标签</h2><h3 id="form标签"><a href="#form标签" class="headerlink" title="form标签"></a>form标签</h3><p><strong>作用：</strong>收集并提交用户数据给指定服务器</p>
<p><strong>属性：</strong></p>
<ul>
<li>action：收集到的数据的提交地址</li>
<li>method：收集数据的提交方式<ul>
<li>get：适合小量数据，表单数据以<strong>?</strong>隔开写在URL后面，不安全</li>
<li>post：适合大量数据，安全</li>
</ul>
</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>form标签收集其<strong>内部</strong>的数据</li>
<li>要提交的表单项必须拥有<strong>name</strong>属性（作为<strong>键</strong>），否则不会提交</li>
<li>表单数据提交的是表单域标签的<strong>value值</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"#"</span> <span class="attr">method</span>=<span class="string">"get"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="form表单域标签"><a href="#form表单域标签" class="headerlink" title="form表单域标签"></a>form表单域标签</h3><p>form表单域标签写在form标签内部</p>
<p><strong>作用：</strong>给用户提供可以<strong>书写</strong>数据或<strong>选择</strong>的标签</p>
<p><strong>注意：</strong></p>
<ul>
<li>表单域标签为行内元素，需要借助 <strong>br</strong> 实现换行</li>
</ul>
<p><strong>文本框：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"uname"</span> /&gt;</span> <span class="comment">&lt;!-- 收集少量文本数据，用户可见 --&gt;</span></span><br><span class="line">密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"upwd"</span> /&gt;</span> <span class="comment">&lt;!-- 收集密码数据，不可见 --&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>单选框：</strong></p>
<p>属性：</p>
<ul>
<li><p><strong>name：</strong>name属性值相同的选择框只能选择一项数据​</p>
</li>
<li><p><strong>checked：</strong>带有checked=”checked”属性的为默认选中</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">男：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"1"</span> <span class="attr">checked</span>=<span class="string">"checked"</span> /&gt;</span></span><br><span class="line">女：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"0"</span> /&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>多选框：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">吃饭<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"fav"</span> <span class="attr">value</span>=<span class="string">"1"</span> <span class="attr">checked</span>=<span class="string">"checked"</span> /&gt;</span></span><br><span class="line">睡觉<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"fav"</span> <span class="attr">value</span>=<span class="string">"2"</span> /&gt;</span></span><br><span class="line">打豆豆<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"fav"</span> <span class="attr">value</span>=<span class="string">"3"</span> /&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>文件选择框：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file"</span> /&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>普通按钮：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"普通按钮"</span> /&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>登录按钮：</strong></p>
<p>登录按钮为<strong>提交数据</strong>的触发点</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"登录"</span> /&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>使用超链接标签提交数据：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"链接路径?username=12345"</span>&gt;</span>使用超链接标签提交<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>隐藏标签：</strong></p>
<blockquote>
<p> 隐藏的数据跟随用户数据的提交而提交，但是不能展示给用户。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"hidden"</span> <span class="attr">value</span>=<span class="string">"1"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>单选下拉框：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"city"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"2"</span>&gt;</span>南京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"3"</span> <span class="attr">selected</span>=<span class="string">"selected"</span>&gt;</span>济宁<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>文本域：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">"say"</span> <span class="attr">rows</span>=<span class="string">"10"</span> <span class="attr">cols</span>=<span class="string">"20"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="模拟百度"><a href="#模拟百度" class="headerlink" title="模拟百度"></a>模拟百度</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"https://www.baidu.com/s"</span> <span class="attr">method</span>=<span class="string">"get"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"wd"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"百度一下"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>Java动态代理</title>
    <url>/2019/04/04/Java/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p>通过动态代理，可以在不修改源码的基础上对方法进行增强</p>
<a id="more"></a>
<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>特点：字节码随用随创建，随用随加载</p>
<p>作用：不修改源码的基础上，对方法进行增强</p>
<p>分类：</p>
<ul>
<li>基于接口的动态代理</li>
<li>基于子类的动态代理</li>
</ul>
<hr>
<h4 id="基于接口的动态代理"><a href="#基于接口的动态代理" class="headerlink" title="基于接口的动态代理"></a>基于接口的动态代理</h4><p><strong>涉及的类：</strong>Proxy</p>
<p><strong>提供者：</strong>JDK官方</p>
<p><strong>如何创建代理对象：</strong>使用Proxy类中的<code>newProxyInstance</code>方法</p>
<p><strong>创建代理对象的要求：</strong>被代理类至少实现一个接口，没有则不能创建</p>
<p><strong>newProxyInstance方法的参数：</strong></p>
<ul>
<li>ClassLoader：类加载器<ul>
<li>用于加载代理对象字节码，和被代理对象使用相同的类加载器，<strong>固定写法</strong></li>
</ul>
</li>
<li>Class[]：字节码数组<ul>
<li>用于让代理对象和被代理对象有相同的方法，<strong>固定写法</strong></li>
</ul>
</li>
<li>InvocationHandler(接口)：用于提供增强的代码<ul>
<li>它让我们写如何进行代理。一般都是写InvocationHandler的实现类（匿名内部类）</li>
</ul>
</li>
</ul>
<p>代码体现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 该处成员方法设置为final，</span></span><br><span class="line"><span class="comment">         * 是因为在匿名内部类中要想调用外部类的方法，</span></span><br><span class="line"><span class="comment">         * 那么该外部类的方法必须是 final 的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> IProducer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 使用Proxy创建一个代理对象</span></span><br><span class="line">        IProducer proxyProducer = (IProducer) Proxy.newProxyInstance(producer.getClass().getClassLoader(),</span><br><span class="line">                producer.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 执行被代理对象的任何接口方法都会经过该方法</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> proxy     代理对象的引用(一般用不到)</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> method    当前执行的方法</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> args      当前执行的方法的参数</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@return</span>          和被代理对象有相同的返回值</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        <span class="comment">// 提供增强的代码</span></span><br><span class="line">                        Object returnValue = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 1、获取方法执行的参数</span></span><br><span class="line">                        Integer money = (Integer) args[<span class="number">0</span>];</span><br><span class="line">                        <span class="comment">// 2、判断当前方法是不是销售</span></span><br><span class="line">                        <span class="keyword">if</span>(<span class="string">"saleProduct"</span>.equals(method.getName()))&#123;</span><br><span class="line">                            returnValue = method.invoke(producer,(<span class="keyword">int</span>)(money*<span class="number">0.8</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> returnValue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">// 使用代理对象调用方法</span></span><br><span class="line">        proxyProducer.saleProduct(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="基于子类的动态代理"><a href="#基于子类的动态代理" class="headerlink" title="基于子类的动态代理"></a>基于子类的动态代理</h4><p><strong>涉及的类：</strong>Enhancer</p>
<p><strong>提供者：</strong>第三方cglib库</p>
<blockquote>
<p>maven坐标：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1_3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


</blockquote>
<p><strong>如何创建代理对象：</strong>使用Enhancer类中的<code>create</code>方法</p>
<p><strong>创建代理对象的要求：</strong>被代理的类不能被final修饰（不能为最终类）</p>
<p><strong>create方法的参数：</strong></p>
<ul>
<li>Class：字节码<ul>
<li>用于指定被代理对象的字节码</li>
</ul>
</li>
<li>Callback(接口)：用于提供增强的代码<ul>
<li>我们一般写的都是该接口的子接口的实现类：MethodInterceptor</li>
</ul>
</li>
</ul>
<p>代码体现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        Producer cglibProducer = (Producer) Enhancer.create(producer.getClass(),</span><br><span class="line">                <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     *  执行被代理对象的任何方法都会经过该方法</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> objects</span></span><br><span class="line"><span class="comment">                     *      以上三个方法参数和基于接口的动态代理中invoke方法的参数是一样的</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> methodProxy   当前执行方法的代理对象（一般用不到）</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        <span class="comment">// 提供增强的代码</span></span><br><span class="line">                        Object returnValue = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 1、获取方法执行的参数</span></span><br><span class="line">                        Integer money = (Integer) objects[<span class="number">0</span>];</span><br><span class="line">                        <span class="comment">// 2、判断当前方法是不是销售</span></span><br><span class="line">                        <span class="keyword">if</span>(<span class="string">"saleProduct"</span>.equals(method.getName()))&#123;</span><br><span class="line">                            returnValue = method.invoke(producer,(<span class="keyword">int</span>)(money*<span class="number">0.8</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> returnValue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">// 使用代理对象调用方法</span></span><br><span class="line">        cglibProducer.saleProduct(<span class="number">20000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>XML</title>
    <url>/2019/04/04/Java/1.Java%E5%9F%BA%E7%A1%80/XML/</url>
    <content><![CDATA[<p>XML是一种非常灵活的语言，通常用于信息的记录和传递</p>
<a id="more"></a>

<p><img src="/images/XML.jpg" alt=""></p>
<h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><h2 id="XML基本信息"><a href="#XML基本信息" class="headerlink" title="XML基本信息"></a>XML基本信息</h2><p><strong>1、</strong>XML(eXtensible Markup Language)：<strong>可扩展标记语言</strong></p>
<p><strong>2、</strong>XML是一种非常<strong>灵活</strong>的语言，<strong>没有固定的标签</strong>，任何标签都可以自定义</p>
<p><strong>3、</strong>XML通常被<strong>用于信息的记录和传递</strong>，因此，XML经常被<strong>用作配置文件</strong></p>
<p><strong>4、</strong>格式良好的XML：遵循XML文档的基本规则</p>
<ul>
<li>必须有XML声明语句</li>
<li>有且只有一个根元素</li>
<li>标签大小写敏感</li>
<li>属性的值用双引号</li>
<li>标签成对</li>
<li>元素正确嵌套</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">books</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">book</span> <span class="attr">id</span>=<span class="string">"01"</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">name</span>&gt;</span>西游记<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">author</span>&gt;</span>吴承恩<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">books</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>5、</strong>有效的XML文档</p>
<ul>
<li>首先应该是格式良好的XML文档</li>
<li>使用DTD和XSD定义语义约束</li>
</ul>
<h2 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h2><p>DTD（Document Type Definition）：文件类型定义</p>
<p><strong>作用：</strong>约束XML的文档格式，保证XML为一个有效的XML</p>
<p>DTD 分为<strong>内部DTD</strong> 和 <strong>外部DTD</strong></p>
<h3 id="内部DTD"><a href="#内部DTD" class="headerlink" title="内部DTD"></a>内部DTD</h3><blockquote>
<p>定义在XML文档内部的DTD</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">books</span> [</span></span><br><span class="line"><span class="meta">	<span class="meta">&lt;!ELEMENT <span class="meta-keyword">books</span> (<span class="meta-keyword">book</span>+)&gt;</span></span></span><br><span class="line"><span class="meta">	<span class="meta">&lt;!ELEMENT <span class="meta-keyword">book</span> (<span class="meta-keyword">name</span>,<span class="meta-keyword">author</span>,<span class="meta-keyword">type</span>)&gt;</span></span></span><br><span class="line"><span class="meta">	<span class="meta">&lt;!ELEMENT <span class="meta-keyword">name</span> (<span class="meta-keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">	<span class="meta">&lt;!ELEMENT <span class="meta-keyword">author</span> (<span class="meta-keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">	<span class="meta">&lt;!ELEMENT <span class="meta-keyword">type</span> (<span class="meta-keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">books</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">book</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>西游记<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">author</span>&gt;</span>吴承恩<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">type</span>&gt;</span>四大名著<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">book</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>三国演义<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">author</span>&gt;</span>罗贯中<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">type</span>&gt;</span>四大名著<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">books</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="外部DTD"><a href="#外部DTD" class="headerlink" title="外部DTD"></a>外部DTD</h3><blockquote>
<p>定义在XML外部的DTD，为一个单独的文件</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">books</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"bookdtd.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">books</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">book</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>西游记<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">author</span>&gt;</span>吴承恩<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">type</span>&gt;</span>四大名著<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">book</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>三国演义<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">author</span>&gt;</span>罗贯中<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">type</span>&gt;</span>四大名著<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">books</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>books的DTD文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!ELEMENT books (book+)&gt;</span><br><span class="line">&lt;!ELEMENT book (name,author,type)&gt;</span><br><span class="line">&lt;!ELEMENT name (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT author (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT type (#PCDATA)&gt;</span><br></pre></td></tr></table></figure>

<h2 id="XSD"><a href="#XSD" class="headerlink" title="XSD"></a>XSD</h2><p>XSD（XML Schema）: DTD的替代者</p>
<p>XSD不仅可以定义文档的结构，还可以规范文档的内容</p>
<blockquote>
<p>XSD和DTD基本都不需要我们自己写，能看懂即可</p>
</blockquote>
<h2 id="XML解析技术"><a href="#XML解析技术" class="headerlink" title="XML解析技术"></a>XML解析技术</h2><p><strong>1、</strong>XML解析：对XML文件进行操作，包括创建XML文件，对XML文件进行增删改查等操作</p>
<p><strong>2、</strong>XML常用的解析技术</p>
<ul>
<li>DOM –&gt; 官方提供，基于XML树解析，消耗资源大</li>
<li>SAX –&gt; 民间提供，基于事件，消耗资源小</li>
<li>JDOM –&gt; 第三方提供(解析器)，开源，速度比DOM快</li>
<li><strong>dom4j</strong> –&gt; 第三方提供(解析器)，开源，是JDOM的升级版</li>
</ul>
<p><strong>3、dom4j(Dom for Java) 解析XML</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.dom4j.Attribute;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Document;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.DocumentException;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Element;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.SAXReader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Dom4j读取XML</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pikachu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDom4j</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 创建SAXReader输入流,</span></span><br><span class="line">		SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">		<span class="comment">// 使用SAXReader输入流获取XML文件，创建Document对象</span></span><br><span class="line">		Document document = reader.read(<span class="keyword">new</span> File(<span class="string">"src/book2.xml"</span>));</span><br><span class="line">		<span class="comment">// 获取根元素</span></span><br><span class="line">		Element root = document.getRootElement();</span><br><span class="line"><span class="comment">//		System.out.println(root.getName());</span></span><br><span class="line">		<span class="comment">// 使用迭代器从根元素获取子元素</span></span><br><span class="line">		Iterator&lt;?&gt; it = root.elementIterator();</span><br><span class="line">		<span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">			Element ele = (Element)it.next();</span><br><span class="line">			System.out.println(ele.getName());</span><br><span class="line">			Attribute att = ele.attribute(<span class="string">"num"</span>);<span class="comment">// 获取元素的属性</span></span><br><span class="line">			System.out.println(att.getName()+<span class="string">" = "</span>+att.getData());</span><br><span class="line">			</span><br><span class="line">			Element name = ele.element(<span class="string">"name"</span>);</span><br><span class="line">			Element author = ele.element(<span class="string">"author"</span>);</span><br><span class="line">			Element type = ele.element(<span class="string">"type"</span>);</span><br><span class="line">			</span><br><span class="line">			System.out.println(name.getName()+<span class="string">" = "</span>+name.getText());</span><br><span class="line">			System.out.println(author.getName()+<span class="string">" = "</span>+author.getText());</span><br><span class="line">			System.out.println(type.getName()+<span class="string">" = "</span>+type.getText());</span><br><span class="line">			</span><br><span class="line">			System.out.println(<span class="string">"---------------------"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="利用dom4j生成XML"><a href="#利用dom4j生成XML" class="headerlink" title="利用dom4j生成XML"></a>利用dom4j生成XML</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Writer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.dom4j.Document;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.DocumentHelper;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Element;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.OutputFormat;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.XMLWriter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成XML文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pikachu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDom4j02</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 1.创建Document对象</span></span><br><span class="line">		Document document = DocumentHelper.createDocument();</span><br><span class="line">		<span class="comment">// 2.为Document对象添加根元素</span></span><br><span class="line">		Element root = document.addElement(<span class="string">"books"</span>);</span><br><span class="line">		<span class="comment">// 3.为根元素添加子元素</span></span><br><span class="line">		Element book = root.addElement(<span class="string">"book"</span>);</span><br><span class="line">		<span class="comment">// 4.为book元素添加属性</span></span><br><span class="line">		book.addAttribute(<span class="string">"id"</span>, <span class="string">"b01"</span>);</span><br><span class="line">		<span class="comment">// 5.为book元素添加子元素</span></span><br><span class="line">		Element name = book.addElement(<span class="string">"name"</span>);</span><br><span class="line">		Element author = book.addElement(<span class="string">"author"</span>);</span><br><span class="line">		Element type = book.addElement(<span class="string">"type"</span>);</span><br><span class="line">		<span class="comment">// 6.为子元素添加文本</span></span><br><span class="line">		name.addText(<span class="string">"红楼梦"</span>);</span><br><span class="line">		author.addText(<span class="string">"曹雪芹"</span>);</span><br><span class="line">		type.addText(<span class="string">"四大名著"</span>);</span><br><span class="line">		</span><br><span class="line"><span class="comment">//		// 7.将Document对象输出到文件</span></span><br><span class="line"><span class="comment">//		Writer writer = new FileWriter("src/boooook.xml");</span></span><br><span class="line"><span class="comment">//		document.write(writer);</span></span><br><span class="line"><span class="comment">//		writer.flush();</span></span><br><span class="line"><span class="comment">//		// 8.释放资源</span></span><br><span class="line"><span class="comment">//		writer.close();</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 7.将Document对象进行格式良好的输出</span></span><br><span class="line">		OutputFormat format = OutputFormat.createPrettyPrint();</span><br><span class="line">		XMLWriter writer = <span class="keyword">new</span> XMLWriter(<span class="keyword">new</span> FileWriter(<span class="string">"src/boooook.xml"</span>), format); </span><br><span class="line">		writer.write(document);</span><br><span class="line">		<span class="comment">// 8.关闭资源</span></span><br><span class="line">		writer.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2019/04/04/Java/1.Java%E5%9F%BA%E7%A1%80/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>正则表达式适用于复杂的文本处理</p>
<a id="more"></a>

<p><img src="/images/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.jpg" alt=""></p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p><strong>1、正则表达式（Regular Expression）简介：</strong></p>
<ul>
<li><strong>定义</strong>：正则表达式描述了一个规则，通过这个规则可以匹配一类字符串</li>
<li>正则表达式适用于<strong>文本的复杂处理</strong></li>
<li>大部分<strong>编程语言</strong>，<strong>数据库</strong>，<strong>文本编辑器</strong>，<strong>开发环境</strong>都支持正则表达式</li>
<li>学习正则表达式就是学习它的<strong>语法规则</strong></li>
</ul>
<hr>
<p><strong>2、开发中使用正则表达式的流程</strong></p>
<ul>
<li><strong>分析</strong>所要匹配的数据，写出测试用的典型数据</li>
<li>在<strong>工具软件（RegexBuddy）</strong>中进行匹配<strong>测试</strong></li>
<li>在程序中<strong>调用</strong>通过测试的正则表达式</li>
</ul>
<hr>
<p><strong>3、正则表达式语法</strong></p>
<ul>
<li><p><strong>普通字符</strong></p>
<p>字母、数字、汉字、下划线以及没有特殊定义的标点符号，都是”普通字符“，表达式中的普通字符，<strong>匹配一个与之相同的字符</strong></p>
</li>
<li><p><strong>普通的转义字符</strong></p>
<ul>
<li><strong>\n</strong> –&gt; 换行符</li>
<li><strong>\t</strong> –&gt; 制表符</li>
<li>*<em>\ \ *</em>–&gt; 匹配 \</li>
<li><strong>\ ^</strong>，<strong>\ $</strong>，<strong>\ .</strong> 等 –&gt; 匹配这些字符本身</li>
</ul>
</li>
<li><p><strong>标准字符集合</strong></p>
<ul>
<li><strong>\d</strong> –&gt; 匹配0~9中任意一个数字</li>
<li><em>（<strong>\D</strong> –&gt; 匹配0~9之外的所有字符）</em> <strong>大写表示相反下同</strong></li>
<li><strong>\w</strong> –&gt; 匹配任意一个<strong>字母</strong>或<strong>数字</strong>或<strong>下滑线</strong>，A<del>Z，a</del>z，0~9，_</li>
<li><strong>\s</strong> –&gt; 匹配任意一个<strong>空白字符</strong>，空格，制表符，换行符等</li>
<li><strong>.</strong> –&gt; 小数点可以匹配任意一个字符（不包括\n），匹配\n在内的所有字符用<strong>[\s\S]</strong></li>
</ul>
</li>
<li><p><strong>自定义字符集合</strong></p>
<blockquote>
<p>方括号匹配方式，可以匹配方括号中的任意一个字符</p>
</blockquote>
</li>
</ul>
<ul>
<li><p><strong>[ab5@]</strong> –&gt; 匹配”a“或”b“或”5“或”@“</p>
</li>
<li><p><strong>[^abc]</strong> –&gt; 匹配”a“，”b“，”c“<strong>之外</strong>的任意一个字符</p>
</li>
<li><p><strong>[c-s]</strong> –&gt; 匹配“c”~“s”之间的任意一个字符</p>
</li>
<li><p><strong>[^2-7b-g]</strong> –&gt; 匹配”2“<del>”7“，”b“</del>”g“<strong>之外</strong>的任意一个字符</p>
<blockquote>
<p>正则表达式中的特殊符号，被包含到中括号中，则失去了特殊含义，除了 <strong>^</strong> 和 <strong>-</strong></p>
<p>标准字符集合，除小数点外，如果被包含于中括号，自定义字符集合也将包含该集合</p>
</blockquote>
</li>
</ul>
<ul>
<li><p><strong>量词</strong></p>
<blockquote>
<p>修饰匹配次数的特殊符号</p>
</blockquote>
</li>
</ul>
<ul>
<li><p><strong>{n}</strong> –&gt; 表达式重复n次</p>
</li>
<li><p><strong>{m,n}</strong> –&gt; 表达式至少重复m次，最多重复n次</p>
</li>
<li><p><strong>{m,}</strong> –&gt; 表达式至少重复m次</p>
</li>
<li><p><strong>?</strong> –&gt; 匹配表达式0次或1次，相当于{0,1}</p>
</li>
<li><p><strong>+</strong> –&gt; 表达式至少出现1次，相当于{1,}</p>
</li>
<li><p>***** –&gt; 表达式至少出现0次,相当于{0,}</p>
<blockquote>
<p>匹配次数中的<strong>贪婪模式</strong>：匹配的字符越多越好，<em>默认</em></p>
<p>匹配次数中的<strong>非贪婪模式</strong>：匹配的字符越少越好，需要在修饰匹配次数的特殊符号后加”<strong>？</strong>“</p>
</blockquote>
</li>
</ul>
<ul>
<li><p><strong>字符边界</strong></p>
<blockquote>
<p>字符边界匹配的不是字符而是<strong>符合某种条件的位置</strong>（<strong>零宽</strong>）</p>
</blockquote>
</li>
</ul>
<ul>
<li><strong>^</strong> –&gt; 与字符串开始的地方匹配</li>
<li><strong>$</strong> –&gt; 与字符串结束的地方匹配</li>
<li><strong>\b</strong> –&gt; 匹配一个单词边界（前面的字符和后面的字符不全是<strong>\w</strong>）</li>
</ul>
<ul>
<li><p><strong>匹配模式</strong></p>
<ul>
<li><strong>IGNORECASE</strong> –&gt; 忽略大小写模式</li>
<li><strong>SINGLELINE</strong> –&gt; 单行模式<ul>
<li>整个文本看成一个字符串，只有一个开头和一个结尾</li>
<li>这种情况下小数点 ”<strong>.</strong>“ 可以匹配包括\n在内的所有字符</li>
</ul>
</li>
<li>MULTILINE –&gt; 多行模式<ul>
<li>每一行都是一个字符串</li>
<li>在多行模式下，如果仅要匹配<strong>最开始</strong>和<strong>最后</strong>的字符，可使用 “<strong>\A</strong>“和”<strong>\Z</strong>“</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>选择符和分组</strong></p>
<ul>
<li><strong>|</strong> –&gt; 分支结构，匹配左边或右边</li>
<li><strong>()</strong> –&gt; 捕获组</li>
<li><strong>(?:Expression)</strong> –&gt; 非捕获组</li>
</ul>
</li>
<li><p><strong>反向引用 (\nnn)</strong></p>
<ul>
<li>每一对()都会分配一个编号，根据<strong>左括号的顺序从1开始编号</strong></li>
<li>通过反向引用，可以对<strong>捕获组已捕获的字符串</strong>进行引用</li>
</ul>
</li>
<li><p><strong>预搜索（零宽断言）</strong></p>
<ul>
<li><strong>(?=exp)</strong> –&gt; 断言自身出现的位置<strong>后面能</strong>出现表达式exp</li>
<li><strong>(?&lt;=exp)</strong> –&gt; 断言自身出现的位置<strong>前面能</strong>出现表达式exp</li>
<li><strong>(?!exp)</strong> –&gt; 断言自身出现的位置<strong>后面不能</strong>出现表达式exp</li>
<li><strong>(?&lt;!exp)</strong> –&gt; 断言自身出现的位置<strong>前面不能</strong>出现表达式exp</li>
</ul>
</li>
</ul>
<h2 id="Java中正则表达式的使用"><a href="#Java中正则表达式的使用" class="headerlink" title="Java中正则表达式的使用"></a>Java中正则表达式的使用</h2><blockquote>
<p>import java.util.regex.Pattern</p>
<p>import java.util.regex.Matcher</p>
</blockquote>
<h3 id="创建正则表达式对象-进行匹配"><a href="#创建正则表达式对象-进行匹配" class="headerlink" title="创建正则表达式对象,进行匹配"></a>创建正则表达式对象,进行匹配</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pattern p = <span class="keyword">new</span> Pattern(<span class="string">"\\b"</span>);</span><br><span class="line">Matcher m = p.compile(<span class="string">"String8Str"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> flag = m.matches();<span class="comment">// 判断整个字符串是否与正则表达式匹配</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(m.find())&#123;<span class="comment">// 找到与该正则表达式匹配的第一个子字符串，然后找下一个</span></span><br><span class="line">	System.out.println(m.group());<span class="comment">// 按照捕获组来输出，0输出全部组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="利用正则表达式进行替换操作"><a href="#利用正则表达式进行替换操作" class="headerlink" title="利用正则表达式进行替换操作"></a>利用正则表达式进行替换操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pattern p = Pattern.compile(<span class="string">"[0-9]"</span>);</span><br><span class="line">Matcher m = p.matcher(<span class="string">"asd456fgh"</span>);</span><br><span class="line">String str = m.replaceAll(<span class="string">"!"</span>);<span class="comment">// 把与正则表达式匹配的元素替换成“!”</span></span><br></pre></td></tr></table></figure>

<h3 id="利用正则表达式进行分割操作"><a href="#利用正则表达式进行分割操作" class="headerlink" title="利用正则表达式进行分割操作"></a>利用正则表达式进行分割操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"a1b23243434343c33d4e5"</span>;</span><br><span class="line">String[] strarr = str.split(<span class="string">"\\d+"</span>);<span class="comment">//split(String Regex)</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习笔记_4.3</title>
    <url>/2019/04/03/Java/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>Linux在服务器端有着大量的应用</p>
<a id="more"></a>

<p><img src="/images/Linux.jpg" alt=""></p>
<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="一、前期准备"><a href="#一、前期准备" class="headerlink" title="一、前期准备"></a>一、前期准备</h2><p>资源准备：</p>
<ul>
<li>虚拟机：VMware</li>
<li>镜像文件：CentOS 7.iso</li>
</ul>
<h2 id="二、系统分区"><a href="#二、系统分区" class="headerlink" title="二、系统分区"></a>二、系统分区</h2><ol>
<li>分区：把大硬盘分成小的逻辑分区</li>
<li>格式化：写入文件系统</li>
<li>分区设备文件名：给每个分区定义设备文件名</li>
<li>挂载：给每个分区分配挂载点（必须是空文件夹）</li>
</ol>
<h2 id="三、远程连接"><a href="#三、远程连接" class="headerlink" title="三、远程连接"></a>三、远程连接</h2><p>远程连接工具：</p>
<ul>
<li>SecureCRT（远程连接管理工具）</li>
<li>WinSCP（文件拷贝工具）</li>
</ul>
<p>需要在Linux中进行的设置（两个命令（CentOS 7））：</p>
<ul>
<li><strong>ip addr</strong> （查看当前网络相关信息）</li>
<li><strong>ifcfg ens33 192.168.2.37</strong> （设置ip）</li>
</ul>
<h2 id="四、注意事项"><a href="#四、注意事项" class="headerlink" title="四、注意事项"></a>四、注意事项</h2><p><strong>1、</strong>Linux严格区分<strong>大小写</strong>，<strong>命令全为小写</strong></p>
<p><strong>2、</strong>Linux中所有的内容都是以<strong>文件</strong>保存的，包括硬件</p>
<p><strong>3、</strong>Linux<strong>不靠扩展名</strong>区分文件系统</p>
<p><strong>4、</strong>Linux所有的存储设备都必须<strong>挂载</strong>之后才能使用</p>
<p><strong>5、</strong>Windows下的程序不能在Linux中安装和运行</p>
<h2 id="五、Linux各目录简介"><a href="#五、Linux各目录简介" class="headerlink" title="五、Linux各目录简介"></a>五、Linux各目录简介</h2><p><strong>/bin/</strong> –&gt; 存放系统命令的目录，普通用户和超级用户都可以执行，在单用户模式下也可以执行</p>
<p><strong>/sbin/</strong> –&gt; 存放系统环境设置相关的命令，只有超级用户可以执行，</p>
<p><strong>/usr/bin/</strong> –&gt; 存放系统命令的目录，普通用户和超级用户都可以执行，单用户模式下不可执行</p>
<p><strong>/usr/sbin/</strong> –&gt; 存放根文件系统不必要的系统管理命令，只有超级用户可以执行</p>
<hr>
<p><strong>/boot/</strong> –&gt; 系统启动目录，保存启动相关文件，如内核文件和启动引导程序（grub）文件等</p>
<p><strong>/dev/</strong> –&gt; 硬件设备文件保存位置</p>
<p><strong>/etc/</strong> –&gt; 系统配置文件默认保存位置</p>
<hr>
<p><strong>/home/</strong> –&gt; 普通用户的家目录，如user用户的家目录就是/home/user/</p>
<p><strong>/lib/</strong> –&gt; 系统调用的函数库保存位置</p>
<p><strong>/lost+found/</strong> –&gt; 备份恢复目录，系统非正常关闭时，会产生一些文件碎片放在这里，当系统启动过程中fsck工具会检查这里，并修复已经损坏的文件系统</p>
<hr>
<p><strong>/media/</strong> –&gt; 挂载目录，系统建议用来挂载媒体设备，如光盘</p>
<p><strong>/mnt/</strong> –&gt; 挂载目录，早期Linux仅有这一个挂载目录，现在系统建议此目录挂载额外设备，如U盘</p>
<p><strong>/misc/</strong> –&gt; 挂载目录，系统建议用来挂载NFS服务的共享目录</p>
<hr>
<p><strong>/opt/</strong> –&gt; 第三方安装的文件保存位置，但是用的不多，<strong>/usr/local/</strong>用的比较多</p>
<hr>
<p><strong>/proc/</strong> –&gt; 虚拟文件系统，该目录中的数据保存在内存中，主要保存系统相关状态</p>
<p><strong>/sys/</strong> –&gt; 虚拟文件系统，数据也是保存在内存中，主要保存内核相关信息</p>
<hr>
<p><strong>/root/</strong> –&gt; 超级用户的家目录，位于/目录下</p>
<p><strong>/srv/</strong> –&gt; 服务数据目录</p>
<p><strong>/tmp/</strong> –&gt; 存放临时文件的目录</p>
<p><strong>/usr/</strong> –&gt; 系统软件资源目录，“<strong>U</strong>nix <strong>S</strong>oftware <strong>R</strong>esource”</p>
<p><strong>/var/</strong> –&gt; 动态数据保存目录，保存缓存、日志等</p>
<h2 id="服务器管理和维护建议"><a href="#服务器管理和维护建议" class="headerlink" title="服务器管理和维护建议"></a>服务器管理和维护建议</h2><ul>
<li>服务器不允许关机，只能重启</li>
<li>重启时应关闭服务</li>
<li>不要在服务器访问高峰运行运行高负载命令</li>
<li>远程配置防火墙时不要把自己踢出服务器</li>
<li>指定合乎规范的密码并定期更新</li>
<li>合理分配权限（够用就好，越少越好）</li>
<li>定期备份重要数据和日志（/erc/，/lib/，/var/，/usr/，/boot/等目录）</li>
</ul>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表&amp;排序</title>
    <url>/2019/04/02/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8&amp;%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p><strong>快速排序</strong>非常重要，一定要烂熟于心！！！</p>
<a id="more"></a>

<p><img src="/images/4.2.jpg" alt=""></p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="结构和特点"><a href="#结构和特点" class="headerlink" title="结构和特点"></a>结构和特点</h3><p>哈希表（hashtable）：也叫散列表</p>
<p><strong>结构：</strong>有很多种，最流行的是<strong>顺序表</strong>+<strong>链表</strong></p>
<p><strong>特点：</strong>快，<strong>很快</strong>，非常快</p>
<h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><p><strong>三步：</strong></p>
<ul>
<li>1、计算哈希码（hashcode，调用hashCode()方法获得）</li>
<li>2、计算在哈希表中的存储位置</li>
<li>3、存入哈希表</li>
</ul>
<p>存入哈希表中的数据<strong>唯一</strong>且<strong>无序</strong></p>
<h3 id="hashCode-和equals-的作用"><a href="#hashCode-和equals-的作用" class="headerlink" title="hashCode()和equals()的作用"></a>hashCode()和equals()的作用</h3><p><strong>hashCode()：</strong>获取哈希码，返回一个<strong>int</strong>，根据哈希码计算出数据在哈希表中的存储位置</p>
<p><strong>equals()：</strong>添加或查询数据是需要使用equals()进行对比，判断是否有相同数据</p>
<h3 id="如何获取哈希码"><a href="#如何获取哈希码" class="headerlink" title="如何获取哈希码"></a>如何获取哈希码</h3><p><strong>int：</strong>调用hashCode()方法，其实就是取自身</p>
<p><strong>其他类型：</strong>调用默认的hashCode()方法获取</p>
<h3 id="如何减少冲突"><a href="#如何减少冲突" class="headerlink" title="如何减少冲突"></a>如何减少冲突</h3><p><strong>1、装填因子</strong>：</p>
<p>装填因子 = 表中的记录数 / 哈希表的长度</p>
<p>装填因子越小，发生冲突的可能性就越小</p>
<p>研究标明：当装填因子为0.5时，哈希表的性能达到最优</p>
<p><strong>因此，一般情况下，装填因子取0.5</strong></p>
<hr>
<p><strong>2、哈希函数的选择</strong></p>
<p>直接定址法、平方取中法、折叠法、除留取余法等</p>
<hr>
<p><strong>3、处理冲突的方法</strong></p>
<p>链地址法、开放地址法、再散列法等</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="排序的分类"><a href="#排序的分类" class="headerlink" title="排序的分类"></a>排序的分类</h3><p><strong>1、内部排序和外部排序</strong></p>
<ul>
<li>内部排序：整个排序过程都在<strong>内存</strong>中进行。<em>本章介绍的排序都是内部排序</em></li>
<li>外部排序：数据量太大，无法全部放入内存，需要<strong>借助外存</strong>完成。</li>
</ul>
<p><strong>2、稳定排序和不稳定排序</strong></p>
<ul>
<li>稳定排序：排序完成后，相同关键字的<strong>前后</strong>相对位置<strong>没有发生变化</strong>。</li>
<li>不稳定排序：排序完成后，相同关键字的<strong>前后</strong>相对位置<strong>发生变化</strong>。</li>
</ul>
<p><strong>3、比较排序和非比较排序</strong></p>
<ul>
<li>比较排序：通过比较来判断大小，作为排序的依据。</li>
<li>非比较排序：不需要通过比较就能排序，如基数排序，计数排序。</li>
</ul>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><ul>
<li><p>比较排序</p>
<ul>
<li>插入排序<ul>
<li>直接插入排序（基本）</li>
<li>希尔排序（完善）</li>
</ul>
</li>
<li>选择排序<ul>
<li>直接选择排序（基本）</li>
<li>堆排序（完善）</li>
</ul>
</li>
<li>交换排序<ul>
<li>冒泡排序（基本）</li>
<li><strong>快速排序</strong>（完善）</li>
</ul>
</li>
<li>归并排序<ul>
<li>归并排序</li>
</ul>
</li>
</ul>
</li>
<li><p>非比较排序</p>
<ul>
<li>计数排序</li>
<li>基数排序</li>
</ul>
</li>
</ul>
<blockquote>
<p>建议先掌握：直接插入排序、直接选择排序、冒泡排序、快速排序</p>
</blockquote>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><blockquote>
<p>快速排序是冒泡排序的改进版，也是最好的一种内部排序，涉及分治和递归的思想，必须掌握</p>
</blockquote>
<p><strong>基本思想：</strong></p>
<ul>
<li>1、先从数列中取出一个数作为<strong>基准数</strong>（第一个数）</li>
<li>2、将比基准数小的放到它的左边，大于或等于它的放到右边（<strong>分区</strong>）</li>
<li>3、对左、右分区重复第一步、第二步，直到各区间只有一个数（<strong>递归</strong>）</li>
</ul>
<p><strong>代码实现:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 实现排序算法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="排序总结"><a href="#排序总结" class="headerlink" title="排序总结"></a>排序总结</h3><p><img src="/images/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.png" alt=""></p>
<p><strong>1、</strong>直接插入排序，直接选择排序，冒泡排序是三种最简单、最基本的排序，时间复杂度也最高（O(n<sup>2</sup>)）,三种都必须熟练掌握。</p>
<p><strong>2、</strong>快速排序和归并排序都使用了<strong>归并</strong>和<strong>递归</strong>的思想，面试时可能会被问到。</p>
<p><strong>3、</strong>在数据不大的情况下，从时间性能来看，快速排序时实际性能最优的排序算法。</p>
<p><strong>4、</strong>堆排序在任何情况下的时间复杂度都为O(nlog<sub>2</sub>n)，在元素较多时是很有效的排序算法。</p>
<p><strong>5、</strong>基于<strong>比较</strong>的排序的时间复杂度下限是<strong>Ω(nlog<sub>2</sub>n))</strong>，这已经是最高的效率了。</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>哈希表</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>查找</title>
    <url>/2019/04/01/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p><strong>查找</strong>和<strong>排序</strong>是数据结构中两个最重要的操作</p>
<a id="more"></a>

<p><img src="/images/4.1.jpg" alt=""></p>
<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="一、线性表查找"><a href="#一、线性表查找" class="headerlink" title="一、线性表查找"></a>一、线性表查找</h2><h3 id="1、顺序查找"><a href="#1、顺序查找" class="headerlink" title="1、顺序查找"></a>1、顺序查找</h3><p><em>非常简单</em></p>
<p><strong>查找方法</strong>：逐个比较查询，如果找到，返回数据或者索引，如果没找到，返回null</p>
<p>时间复杂度：T(n) = O(n)</p>
<h3 id="2、折半（二分）查找"><a href="#2、折半（二分）查找" class="headerlink" title="2、折半（二分）查找"></a>2、折半（二分）查找</h3><p>查找表进行折半查找必须满足<strong>两个条件</strong>：</p>
<ul>
<li>查找表必须使用<strong>顺序存储结构</strong></li>
<li>查找表必须按关键字大小<strong>有序排列</strong></li>
</ul>
<p>折半查找可以使用两种方式来实现：</p>
<ul>
<li><p><strong>非递归方式</strong></p>
<p>时间复杂度：T(n) = O(log<sub>2</sub>n)</p>
<p>空间复杂度：S(n) = O(1)</p>
</li>
</ul>
<ul>
<li><p><strong>递归方式</strong></p>
<p>时间复杂度：T(n) = O(log<sub>2</sub>n)</p>
<p>空间复杂度：S(n) = O(log<sub>2</sub>n)</p>
</li>
</ul>
<h2 id="二、查找树"><a href="#二、查找树" class="headerlink" title="二、查找树"></a>二、查找树</h2><p><strong>二叉查找树 BST</strong>（Binary Search Tree）：</p>
<p>或是一棵空树，</p>
<p>或是具有如下性质的二叉树：</p>
<ul>
<li>若它的左子树不为空，则左子树上的所有节点的值小于根节点的值</li>
<li>若它的右子树不为空，则右子树上的所有节点的值大于根节点的值</li>
<li>它的左、右子树也都为二叉查找树</li>
</ul>
<blockquote>
<p>对二叉查找树进行<strong>中序遍历</strong>，得到有序集合</p>
</blockquote>
<hr>
<p><strong>平衡二叉树</strong>（self-balance Binary Search Tree）:自平衡二叉查找树，又称<strong>AVL树</strong></p>
<p>或是一棵空树</p>
<p>或它的左、右子树的高度差（<strong>平衡因子（平衡度）</strong>）的绝对值不大于1</p>
<p><strong>意义：</strong>减少二叉查找树层次，提高查找速度</p>
<hr>
<p><strong>红黑树</strong>（R-B Tree）：是一种平衡二叉树</p>
<p><strong>特性：</strong></p>
<ul>
<li>每个节点都有颜色，或是黑色，或是红色</li>
<li>根节点是黑色</li>
<li>每个叶子节点（null）是黑色</li>
<li>如果一个节点是红色的，那么它的子节点一定是黑色的</li>
<li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点</li>
</ul>
<p><img src="/images/%E7%BA%A2%E9%BB%91%E6%A0%91.jpg" alt=""></p>
<p><strong>应用：</strong></p>
<p>Java集合中的TreeSet和TreeMap就是使用红黑二叉树实现的</p>
<hr>
<p><strong>B树</strong>（Balance Tree）: 平衡树</p>
<p>平衡树可以降低树的深度，提高查找效率</p>
<p>B树应<strong>文件系统</strong>的要求而发展起来的</p>
<p><img src="../images/B%E6%A0%91.jpg" alt=""></p>
<hr>
<p><strong>B+树：</strong></p>
<p>在B树的基础上，<strong>为叶子节点增加链表指针</strong>，所有关键字都在叶子节点中出现，非叶子节点只作为索引</p>
<p><strong>数据库的索引</strong>的默认结构采用的就是B+树</p>
<p><img src="/images/B+%E6%A0%91.jpg" alt=""></p>
<hr>
<p><strong>B*树：</strong></p>
<p>B+树的变体，在<strong>非根和非叶子节点再增加执行兄弟的指针</strong></p>
<p><img src="/images/B%E6%98%9F%E6%A0%91.jpg" alt=""></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title>图</title>
    <url>/2019/03/31/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/</url>
    <content><![CDATA[<p>图中最重要的操作就是求最短路径</p>
<a id="more"></a>

<p><img src="/images/3.31.jpg" alt=""></p>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>1、基本概念</p>
<p>图（graph）是一种网状数据结构，图是由非空的顶点集合和一个描述顶点之间关系的集合组成。</p>
<p>图中的元素称为<strong>顶点</strong>，顶点之间的关系称为边（edge）</p>
<p>图分为<strong>有向图</strong>（单向）和<strong>无向图</strong>（双向）</p>
<p>实际应用中，图的每条边都有与它相关的实数，称为 权，带有权的图称为<strong>带权图</strong></p>
<p>2、图的存储</p>
<ul>
<li>顺序结构：邻接矩阵 –&gt; 二维数组</li>
<li>链表结构：邻接表 –&gt; 类似于HashMap的存储结构</li>
</ul>
<p>3、图的遍历</p>
<ul>
<li>深度优先遍历（DFS  deep-first search）：类似与树的先根遍历，可利用递归或非递归（借助栈）实现</li>
<li>广度优先遍历（BFS  breadth-first search）：类似于树的层次遍历，非递归（借助队列）实现</li>
</ul>
<p>4、最短路径</p>
<ul>
<li><p><strong>段数最少</strong>的最短路径：</p>
<p>生活案例：换乘最少</p>
<p>解决方案：使用<strong>广度优先搜索</strong></p>
</li>
<li><p><strong>权值最小</strong>的最短路径：</p>
<p>生活案例：时间最少，距离最短等</p>
<p>解决方案：使用<strong>狄克斯特拉</strong>算法</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2019/03/30/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>二叉树是最常见的一种树</p>
<a id="more"></a>

<p><img src="/images/3.30.png" alt=""></p>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p><img src="/images/%E6%99%AE%E9%80%9A%E6%A0%91.jpg" alt=""></p>
<h3 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h3><p>树是n(n&gt;=0)个节点的有限集，</p>
<p>根据节点数量分为空树和非空树</p>
<p>树是一种非线性结构</p>
<h3 id="节点的度和树的度"><a href="#节点的度和树的度" class="headerlink" title="节点的度和树的度"></a>节点的度和树的度</h3><ul>
<li>节点拥有的子树的数目称为<strong>节点的度（degree）</strong></li>
<li>度为0的节点称为<strong>叶子节点（leaf）</strong>或<strong>终端节点</strong></li>
<li>度不为0的节点称为<strong>非终端节点</strong>或<strong>分支节点</strong>，除根之外的分支节点也称为<strong>内部节点</strong></li>
<li>树内<strong>节点的度的最大值</strong>称为<strong>树的度</strong></li>
</ul>
<h3 id="节点的层次和树的深度"><a href="#节点的层次和树的深度" class="headerlink" title="节点的层次和树的深度"></a>节点的层次和树的深度</h3><ul>
<li>节点的层次（level）：根节点的层次为1</li>
<li>树的深度（depth）：节点的最大层次数</li>
</ul>
<h3 id="有序树、m叉树、森林"><a href="#有序树、m叉树、森林" class="headerlink" title="有序树、m叉树、森林"></a>有序树、m叉树、森林</h3><ul>
<li>考虑<strong>节点的左右顺序</strong>的树，称为<strong>有序树</strong>，否则称为<strong>无序树</strong>。</li>
<li>如不特别指明，一般讨论的是有序树</li>
<li>树的<strong>度为m</strong>的树称为<strong>m叉树</strong></li>
<li><strong>森林（forest）</strong>是m（m&gt;=0）棵<strong>互不相交</strong>的树的集合</li>
</ul>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p><img src="/images/%E4%BA%8C%E5%8F%89%E6%A0%91.jpg" alt=""></p>
<p>每个节点的度<strong>均不超过2</strong>的<strong>有序树</strong>，称为二叉树（binary tree）</p>
<ul>
<li>满二叉树：每一层节点都是满的二叉树</li>
<li>完全二叉树：在一颗满二叉树中，在最下层从最右侧去掉相邻的若干叶子节点，即得到完全二叉树</li>
</ul>
<h3 id="二叉树的一些重要性质"><a href="#二叉树的一些重要性质" class="headerlink" title="二叉树的一些重要性质"></a>二叉树的一些重要性质</h3><ul>
<li>对于任意一棵二叉树，其叶子节点数量为n<sub>0</sub>,其度为2的节点数量为n<sub>2</sub>,则n<sub>0</sub>-n<sub>2</sub>=1</li>
<li>二叉树的第 i 层最多有2<sup>i-1</sup>个节点（根是第一层）</li>
</ul>
<h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><ul>
<li><p>顺序存储结构</p>
<p>适用于满二叉树和完全二叉树，将其中的元素逐层存放到一维数组中，</p>
<p>可以通过公式很快的确定节点之间的关系</p>
</li>
<li><p>链式存储结构</p>
<p>对于一般的二叉树而言，顺序存储结构会造成<strong>空间的浪费</strong></p>
<p>所以使用链式存储结构</p>
<ul>
<li><p>每个节点设置<strong>3个域</strong>：数据域，左子域、右子域，这样形成的链表称为<strong>二叉链表</strong></p>
</li>
<li><p>每个节点设置<strong>4个域</strong>：数据域，左子域、右子域、父亲域，这样形成的链表称为<strong>三叉链表</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>遍历（traverse）： 按照某种次序访问树中的所有节点，且每个节点恰好访问一次。</p>
<p>树的遍历可以看成是人为的将<strong>非线性结构线性化</strong></p>
<p>二叉树的三种遍历方式：–<em>规定先遍历左子树，再遍历右子树</em>–</p>
<ul>
<li>先序(根)遍历：根  左子树  右子树</li>
<li>中序(根)遍历：左子树  根  右子树</li>
<li>后序(根)遍历：左子树  右子树  根</li>
</ul>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>线性表</title>
    <url>/2019/03/29/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<p>顺序表、链表、栈、队列其实都是线性表</p>
<a id="more"></a>

<p><img src="/images/3.29.jpg" alt=""></p>
<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p>线性表是n个<strong>类型相同</strong>的数据元素的<strong>有限序列</strong></p>
<ul>
<li>类型相同：每个元素占用相同的内存空间，查询定位非常方便</li>
<li>有限：线性表的长度是一个有限值</li>
<li>序列：除表头和表尾元素外，每个元素都有且仅有一个直接前驱和直接后继</li>
</ul>
<h3 id="1、顺序表"><a href="#1、顺序表" class="headerlink" title="1、顺序表"></a>1、顺序表</h3><p><img src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/images/%E9%A1%BA%E5%BA%8F%E8%A1%A8.png" alt=""></p>
<p>特点：在内存中分配连续的空间，只存储数据，不存储地址<br>优点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 查询效率高</span><br><span class="line">- 空间占用小</span><br></pre></td></tr></table></figure>

<p>缺点：<br>    - 增删效率低<br>    - 必须提前分配确定的空间，如果存储数据少，可能造成空间浪费</p>
<h3 id="2、单链表"><a href="#2、单链表" class="headerlink" title="2、单链表"></a>2、单链表</h3><p><img src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/images/%E5%8D%95%E9%93%BE%E8%A1%A8.png" alt="单链表"></p>
<p>特点：</p>
<ul>
<li>在内存中存储不连续，每个节点同时存储数据和指针</li>
<li>只能通过前驱节点找到后续节点，无法通过后续节点找到前驱节点</li>
</ul>
<p>优点：<br>    - 增删效率高<br>    - 有元素的时候才分配节点，没有空间浪费</p>
<p>缺点：<br>    - 查询效率低<br>    - 因为每个节点都需要存储指针，空间占用大</p>
<h2 id="一、顺序表"><a href="#一、顺序表" class="headerlink" title="一、顺序表"></a>一、顺序表</h2><p>存储结构为顺序结构，典型应用为ArrayList</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自己实现简单的ArrayList功能</span></span><br></pre></td></tr></table></figure>

<h2 id="二、链表"><a href="#二、链表" class="headerlink" title="二、链表"></a>二、链表</h2><p>存储结构为链式结构，分为单链表和双向链表，<br>双向链表：LinkedList</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自己实现简单的SingleLinkedList --&gt; 单链表</span></span><br></pre></td></tr></table></figure>

<h2 id="三、栈"><a href="#三、栈" class="headerlink" title="三、栈"></a>三、栈</h2><p>栈（stack）又称堆栈，是<strong>运算受限</strong>的<strong>线性表</strong></p>
<p>限制是：仅允许在栈的一端进行插入和删除操作，不允许在其他位置进行插入、查找、删除操作。</p>
<p>可以进行操作的一端是栈顶（top），另一端叫栈底（bottom）</p>
<p>重要特性：后进栈的元素先出栈，故堆栈简称<strong>后进先出表</strong>（Last In First Out –&gt;LIFO）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Stack</span></span>&#123;</span><br><span class="line">    <span class="comment">// 返回堆栈的大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断堆栈是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据元素 e 入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(object e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈顶元素出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、队列"><a href="#四、队列" class="headerlink" title="四、队列"></a>四、队列</h2><p>队列（queue）简称队，同样是一种<strong>运算受限</strong>的<strong>线性表</strong></p>
<p>限制是：仅允许在一端（<strong>队尾–&gt;rear</strong>）进行插入，在另一端（<strong>队首–&gt;front</strong>）进行删除</p>
<p>重要特性：先入队的先出队。故队列简称<strong>先进先出表</strong>（First In First Out–&gt;FIFO）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span></span>&#123;</span><br><span class="line">    <span class="comment">// 返回队列的大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断队列是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据元素 e 入队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(object e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队首元素出队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">dequeue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取队首元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、双端队列"><a href="#五、双端队列" class="headerlink" title="五、双端队列"></a>五、双端队列</h2><p><strong>双端队列deque</strong>（double ended queue）<em>音：deck</em></p>
<p>顾名思义：队列的两端都可以进行入队和出队的操作</p>
<p>栈和队列都可以用双端队列实现</p>
<h2 id="六、Java中的栈和队列类"><a href="#六、Java中的栈和队列类" class="headerlink" title="六、Java中的栈和队列类"></a>六、Java中的栈和队列类</h2><p>Queue: 队列接口</p>
<p>Deque: 双端队列接口（栈操作时使用）</p>
<p>实现类：LinkedList，栈和队列操作都用这个</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法基本概念</title>
    <url>/2019/03/28/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>数据结构是计算机存储、组织数据的方式</p>
<p>算法是计算机解题的过程</p>
<a id="more"></a>

<p><img src="/images/3.28.jpg" alt=""></p>
<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h2><ul>
<li>逻辑结构<ul>
<li>线性结构（线性表、栈、队列、串、数组）</li>
<li>非线性结构（树、图）</li>
</ul>
</li>
<li>物理（存储）结构<ul>
<li>顺序结构</li>
<li>链表结构</li>
<li>索引结构</li>
<li>散列结构</li>
</ul>
</li>
<li>数据运算<ul>
<li>插入</li>
<li>删除</li>
<li>修改</li>
<li>查询</li>
<li>排序</li>
</ul>
</li>
</ul>
<blockquote>
<p>逻辑结构唯一<br>存储结构不唯一<br>运算的实现依赖与存储结构</p>
</blockquote>
<h2 id="二、算法"><a href="#二、算法" class="headerlink" title="二、算法"></a>二、算法</h2><p>算法是计算机解题的过程</p>
<p>算法优劣的评判依据：<strong>时间复杂度</strong>和<strong>空间复杂度</strong></p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p><strong>1、</strong>时间复杂度是表示<strong>问题的规模</strong>而不是指算法具体的运行时间或者<em>运行次数</em>（时间频度）<br><strong>2、</strong>时间复杂度的表示：T(n)=O(f(n))<br><strong>3、</strong>时间复杂度一般有<strong>最坏时间复杂度</strong>和<strong>平均时间复杂度</strong><br><strong>4、</strong>我们一般讨论的是<strong>最坏时间复杂度</strong></p>
<p><strong>5、</strong>时间复杂度的计算</p>
<ul>
<li>找出算法中的基本语句（执行次数最多的语句就是基本语句）</li>
<li>计算基本语句执行次数的数量级</li>
<li>将求得的数量级放入O()中</li>
</ul>
<p><strong>6、</strong>常见的时间复杂度</p>
<ul>
<li>常数阶O(1)</li>
<li>对数阶O(log<sub>2</sub>n)</li>
<li>线性阶O(n)</li>
<li>线性对数阶O(n*log<sub>2</sub>n)</li>
<li>平方阶O(n<sup>2</sup>)</li>
<li>立方阶O(n<sup>3</sup>)</li>
<li>…</li>
<li>k次方阶O(n<sup>k</sup>)</li>
<li>指数阶O(2<sup>n</sup>)</li>
<li>阶乘阶O(n!    )</li>
</ul>
<blockquote>
<p>上面的时间复杂度级别，执行效率越来越低</p>
</blockquote>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>S(n)=O(g(n))<br>空间复杂度比时间复杂度分析要少；<br>在使用递归时算法的空间复杂度会比较高</p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>注解&amp;反射&amp;junit</title>
    <url>/2019/03/27/Java/1.Java%E5%9F%BA%E7%A1%80/%E6%B3%A8%E8%A7%A3_%E5%8F%8D%E5%B0%84_junit/</url>
    <content><![CDATA[<p>注解和注释有相似之处，但也有比较大的差别<br>反射是实现Java动态性的方法之一</p>
<a id="more"></a>
<p><img src="/images/3.27.jpg" alt=""></p>
<h1 id="一、注解"><a href="#一、注解" class="headerlink" title="一、注解"></a>一、注解</h1><h2 id="注解-Annotation"><a href="#注解-Annotation" class="headerlink" title="注解-Annotation"></a>注解-Annotation</h2><blockquote>
<p>注解本质上就是一个接口，该接口默认继承 Annotation 接口</p>
</blockquote>
<p>1、注解的作用</p>
<ul>
<li>不是程序本身，可以对程序进行解释</li>
<li>可以被其他程序读取</li>
</ul>
<p>2、注解的格式</p>
<blockquote>
<p>@注解名</p>
</blockquote>
<p>3、注解的使用范围<br>package、class、method、field</p>
<p>4、内置注解</p>
<ul>
<li>@Override –&gt; 该注解只适用于修饰方法，表示该方法重写了父类(或接口)的方法</li>
<li>@Deprecated –&gt; 该注解可用于修饰方法、属性、类，表示不推荐使用这样的元素</li>
<li>@SuppressWarnings –&gt; 用来抑制编译时的警告信息</li>
</ul>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p>定义<strong>关键字</strong>：使用 <strong>@interface</strong> 定义注解</p>
<p><strong>属性</strong>：注解中的抽象方法</p>
<ul>
<li><p>由于注解是接口，所以注解内可以定义 抽象方法</p>
<p>在注解内，抽象方法又被称为属性</p>
</li>
<li><p>抽象方法（属性）的返回值类型仅可为以下几种：</p>
<ul>
<li>基本数据类型</li>
<li>String </li>
<li>枚举</li>
<li>注解</li>
<li>以上类型的数组</li>
</ul>
</li>
<li><p>定义了属性，在使用时需要对属性进行赋值</p>
<ul>
<li>如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值</li>
<li>如果<strong>只有一个</strong>属性需要赋值，并且属性的名称是<strong>value</strong>，则value可以省略，直接定义值即可</li>
<li>数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可以省略</li>
</ul>
</li>
</ul>
<p><strong>元注解：</strong></p>
<ul>
<li><p><strong>@Target</strong>：表示注解可以修饰的范围</p>
<ul>
<li>PACKAGE –&gt; 包</li>
<li>TYPE –&gt; 类、接口、枚举、注解</li>
<li>CONSTRUCTOR –&gt; 构造器</li>
<li>FIELD –&gt; 域</li>
<li>METHOD –&gt; 方法</li>
<li>LOCAL_VARIABLE –&gt; 局部变量</li>
<li>PRARMETER –&gt; 参数</li>
</ul>
</li>
<li><p><strong>@Retention</strong>：描述注解的生命周期</p>
<ul>
<li>SOURCE –&gt; 在源文件中有效</li>
<li>CLASS –&gt; 在class文件中有效</li>
<li>RUNTIME –&gt; 在运行时有效</li>
</ul>
</li>
<li><p><strong>@Documented</strong>：描述注解是否被抽取到 API 文档中</p>
</li>
<li><p><strong>@Inherited</strong>：描述注解是否被子类继承</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(value=&#123;ElementType.METHOD,ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用反射机制读取注解"><a href="#使用反射机制读取注解" class="headerlink" title="使用反射机制读取注解"></a>使用反射机制读取注解</h2><blockquote>
<p>只有将注解读取出来，注解才有实际的使用意义。</p>
</blockquote>
<h1 id="二、反射"><a href="#二、反射" class="headerlink" title="二、反射"></a>二、反射</h1><p><strong>概念：</strong>将类的组成部分封装为其他对象，这就是反射</p>
<p><strong>好处：</strong></p>
<ul>
<li>在程序运行过程中，可以动态的操作这些对象（成员属性、构造方法、成员方法等）</li>
<li>可以解耦，提高程序的可扩展性</li>
</ul>
<h3 id="获取-Class-对象的方法："><a href="#获取-Class-对象的方法：" class="headerlink" title="获取 Class 对象的方法："></a>获取 Class 对象的方法：</h3><p>1、通过 Class 的 forName() 方法获取</p>
<ul>
<li><code>Class clazz = Class.forName(&quot;包名.类名&quot;);</code></li>
</ul>
<p>2、通过类的 class 静态成员变量获取</p>
<ul>
<li><code>Class clazz = 类名.class;</code></li>
</ul>
<p>3、通过对象的 getClass() 方法获取</p>
<ul>
<li><code>Class clazz = 对象名.getClass();</code></li>
</ul>
<h3 id="通过-Class-对象，获取类的信息（类名，属性，构造器，方法等）"><a href="#通过-Class-对象，获取类的信息（类名，属性，构造器，方法等）" class="headerlink" title="通过 Class 对象，获取类的信息（类名，属性，构造器，方法等）"></a>通过 Class 对象，获取类的信息（类名，属性，构造器，方法等）</h3><p>1、<strong>类名</strong>相关</p>
<ul>
<li><code>public String getName()</code> –&gt; 获取 包名+类名</li>
<li><code>public String getSimpleName()</code> –&gt; 仅获取类名</li>
</ul>
<p>2、<strong>成员变量</strong>相关</p>
<ul>
<li><p><code>public Field getField(&quot;成员变量名&quot;)</code> –&gt; 指定名称，获取 public 成员变量</p>
</li>
<li><p><code>public Field[] getFields()</code> –&gt; 获取所有 public 成员变量</p>
</li>
</ul>
<ul>
<li><p><code>public Field getDeclaredField(&quot;成员变量名&quot;)</code> –&gt; 指定名称，获取成员变量</p>
</li>
<li><p><code>public Field[] getDeclaredFields()</code> –&gt; 获取所有成员变量</p>
</li>
</ul>
<p>3、<strong>构造方法</strong>相关</p>
<ul>
<li><code>public Constructor getConstructor(参数...)</code> –&gt; 指定参数，获取 public 构造方法</li>
<li><code>public Constructor[] getConstructors()</code> –&gt; 获取所有 public 构造方法</li>
</ul>
<ul>
<li><code>public Constructor getDeclaredConstructor(参数...)</code> –&gt; 指定参数，获取构造方法</li>
<li><code>public Constructor[] getDeclaredConstrustors()</code> –&gt; 获取所有构造方法</li>
</ul>
<p>4、<strong>成员方法</strong>相关</p>
<ul>
<li><code>getMethod(&quot;方法名&quot;,参数)</code> –&gt; 指定方法名和参数，获取 public 成员方法</li>
<li><code>getMethods()</code> –&gt; 获取所有 public 成员方法</li>
</ul>
<ul>
<li><code>getDeclaredMethod(&quot;方法名&quot;,参数)</code> –&gt; 指定方法名和参数，获取成员方法</li>
<li><code>getDeclaredMethods()</code> –&gt; 获取所有成员方法</li>
</ul>
<blockquote>
<p><strong>使用反射创建对象：</strong></p>
<p>1、通过 Class 对象创建(调用类的无参构造) –&gt; <code>clazz.newInstance()</code></p>
<p>2、通过 Constructor 对象创建(可调用无参，也可调用有参构造) –&gt; <code>constructor.newInstance(...)</code></p>
<p><strong>获取到方法后执行方法：</strong></p>
<p><code>method.invoke(对象名, 参数...)</code></p>
<p><strong>暴力反射：</strong></p>
<p><code>setAccessible(true)</code> –&gt; 可将（成员变量/构造方法/成员方法）设置为不需要做安全检查，直接可以访问。</p>
</blockquote>
<h3 id="测试反射API动态操作：构造器、方法、属性"><a href="#测试反射API动态操作：构造器、方法、属性" class="headerlink" title="测试反射API动态操作：构造器、方法、属性"></a>测试反射API动态操作：构造器、方法、属性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	String path = <span class="string">"test01.User"</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 通过 forName 方法创建 Class 对象</span></span><br><span class="line">		Class&lt;User&gt; clazz = (Class&lt;User&gt;) Class.forName(path);</span><br><span class="line">		<span class="comment">// 通过 Class对象 创建 User类的对象</span></span><br><span class="line">		User u1 = clazz.newInstance(); <span class="comment">// 其实是调用了User的无参构造器，所以JavaBean必须要有无参构造器</span></span><br><span class="line">		</span><br><span class="line">		Constructor&lt;User&gt; c = clazz.getDeclaredConstructor(<span class="keyword">int</span><span class="class">.<span class="keyword">class</span>,<span class="title">int</span>.<span class="title">class</span>,<span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">		User u2 = c.newInstance(<span class="number">1001</span>,<span class="number">22</span>,<span class="string">"小强"</span>); <span class="comment">// 调用有参构造器创建对象</span></span><br><span class="line">		System.out.println(u2.getUname());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 通过反射API调用普通方法</span></span><br><span class="line">		User u3 = clazz.newInstance();</span><br><span class="line">		Method m = clazz.getDeclaredMethod(<span class="string">"setUname"</span>,String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		m.invoke(u3, <span class="string">"小明"</span>); <span class="comment">// 激活该方法，传入对象及参数</span></span><br><span class="line">		System.out.println(u3.getUname());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 通过反射API操作属性</span></span><br><span class="line">		User u4 = clazz.newInstance();</span><br><span class="line">		Field f = clazz.getDeclaredField(<span class="string">"uname"</span>);</span><br><span class="line">		f.setAccessible(<span class="keyword">true</span>); <span class="comment">// 将属性设置为不需要做安全检查，直接可以访问。</span></span><br><span class="line">		f.set(u4, <span class="string">"小红"</span>); <span class="comment">// 通过反射直接写属性的值</span></span><br><span class="line">		</span><br><span class="line">		System.out.println(u4.getUname());</span><br><span class="line">		System.out.println(f.get(u4)); <span class="comment">// 通过反射直接读属性的值</span></span><br><span class="line">		</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反射效率问题"><a href="#反射效率问题" class="headerlink" title="反射效率问题"></a>反射效率问题</h3><p>反射是一把双刃剑，在<strong>提升了编程灵活性</strong>的同时<strong>降低了程序运行效率</strong></p>
<blockquote>
<p>通过 setAccessible(boolean flag) 来设置是否要进行访问安全检查<br>关闭访问安全检查可以比较大的提高程序运行的效率</p>
</blockquote>
<h2 id="三、junit-测试工具"><a href="#三、junit-测试工具" class="headerlink" title="三、junit 测试工具"></a>三、junit 测试工具</h2><p>测试分类：</p>
<ul>
<li>黑盒测试：不需要写代码，只关心输入输出值</li>
<li>白盒测试：需要写代码，关心程序的具体执行流程</li>
</ul>
<p>使用 junit 的方法：</p>
<ul>
<li>给需要测试的方法加上 @Test</li>
<li>导入 junit 依赖环境</li>
</ul>
<p>使用断言操作来处理结果：<br><code>Assert.assertEquals(期望的结果,运算的结果);</code></p>
<p>补充：</p>
<ul>
<li>@Before:<ul>
<li>修饰的方法会在测试方法之前被自动执行</li>
</ul>
</li>
<li>@After:<ul>
<li>修饰的方法会在测试方法执行之后自动被执行</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Java</tag>
        <tag>注解</tag>
        <tag>反射</tag>
        <tag>junit</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程</title>
    <url>/2019/03/18/Java/1.Java%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>网络编程基本概念</p>
<a id="more"></a>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="网络上不同层次的定位方式"><a href="#网络上不同层次的定位方式" class="headerlink" title="网络上不同层次的定位方式"></a>网络上不同层次的定位方式</h3><ul>
<li>网络上的每个节点（电脑/手机）–&gt; IP 定位</li>
<li>电脑上的每个软件 –&gt; 端口 定位</li>
<li>软件中的资源 –&gt; URL 定位</li>
</ul>
<h3 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h3><ul>
<li>TCP –&gt; 需要建立连接，效率较低，安全性高</li>
<li>UDP –&gt; 不需要建立连接，效率较高，安全性低</li>
</ul>
<h3 id="B-S-amp-C-S"><a href="#B-S-amp-C-S" class="headerlink" title="B/S &amp; C/S"></a>B/S &amp; C/S</h3><ul>
<li>B/S –&gt; 范围广，协议统一，传输速率慢</li>
<li>C/S –&gt; 范围小，协议自定，传输速率块</li>
</ul>
<h3 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h3><p>OSI（Open System Interconnect）：开放系统互连参考模型<br>OSI将网络分为7层：</p>
<ul>
<li>应用层</li>
<li>表示层</li>
<li>会话层</li>
<li>传输层</li>
<li>网络层</li>
<li>数据链路层</li>
<li>物理层</li>
</ul>
<h2 id="Java为IP、端口、URL提供的类"><a href="#Java为IP、端口、URL提供的类" class="headerlink" title="Java为IP、端口、URL提供的类"></a>Java为IP、端口、URL提供的类</h2><h3 id="IP-–-gt-InetAdderss"><a href="#IP-–-gt-InetAdderss" class="headerlink" title="IP –&gt; InetAdderss"></a>IP –&gt; InetAdderss</h3><p>InetAddress类没有构造器，用getLocalHost()/getByName(String host)等静态方法创建对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">	InetAddress addr = InetAddress.getLocalHost();</span><br><span class="line">	System.out.println(addr.getHostAddress());</span><br><span class="line">	System.out.println(addr.getHostName());</span><br><span class="line">	</span><br><span class="line">	System.out.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">	</span><br><span class="line">	InetAddress addr2 = InetAddress.getByName(<span class="string">"www.shsxt.com"</span>);</span><br><span class="line">	System.out.println(addr2.getHostAddress());</span><br><span class="line">	System.out.println(addr2.getHostName());</span><br><span class="line">	</span><br><span class="line">	System.out.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">	</span><br><span class="line">	InetAddress addr3 = InetAddress.getByName(<span class="string">"123.56.138.186"</span>);</span><br><span class="line">	System.out.println(addr3.getHostAddress());</span><br><span class="line">	System.out.println(addr3.getHostName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="端口-–-gt-InetSocketAddress"><a href="#端口-–-gt-InetSocketAddress" class="headerlink" title="端口 –&gt; InetSocketAddress"></a>端口 –&gt; InetSocketAddress</h3><p>端口范围（不同协议的端口可以冲突）：</p>
<ul>
<li>TCP：0 ~ 65535</li>
<li>UDP：0 ~ 65535<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InetSocketAddress socketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>,<span class="number">9000</span>);</span><br><span class="line">System.out.println(socketAddress.getAddress()); <span class="comment">// 返回地址</span></span><br><span class="line">System.out.println(socketAddress.getPort()); <span class="comment">// 返回端口</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="URL-–-gt-URL"><a href="#URL-–-gt-URL" class="headerlink" title="URL –&gt; URL"></a>URL –&gt; URL</h3><ul>
<li>URI(Universal Resource Identifier) –&gt; 统一资源标志符</li>
<li>URL(Universal Recource Locator) –&gt; 统一资源定位符</li>
<li>URN(Universal Recource Name) –&gt; 统一资源名称</li>
</ul>
<p>URL由4部分组成：<br>例：<a href="http://www.google.com:80/index.html" target="_blank" rel="noopener">http://www.google.com:80/index.html</a></p>
<ul>
<li>协议</li>
<li>存放资源的主机域名</li>
<li>端口号</li>
<li>资源文件名</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	URL url = <span class="keyword">new</span> URL(<span class="string">"https://m.baidu.com/?from=2001a"</span>);</span><br><span class="line">	System.out.println(url.getProtocol()); <span class="comment">// 获取协议</span></span><br><span class="line">	System.out.println(url.getHost()); <span class="comment">// 获取主机名称</span></span><br><span class="line">	System.out.println(url.getPort()); <span class="comment">// 获取端口</span></span><br><span class="line">	System.out.println(url.getFile()); <span class="comment">// 获取资源名称</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="UDP使用的基本步骤"><a href="#UDP使用的基本步骤" class="headerlink" title="UDP使用的基本步骤"></a>UDP使用的基本步骤</h1><h2 id="发送端"><a href="#发送端" class="headerlink" title="发送端"></a>发送端</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UDP使用基本步骤：发送端</span></span><br><span class="line"><span class="comment"> * 1、使用DatagramSocket 指定端口，创建发送端</span></span><br><span class="line"><span class="comment"> * 2、准备数据，转成字节数组</span></span><br><span class="line"><span class="comment"> * 3、将字节数组封装成DatagramPacket 包裹</span></span><br><span class="line"><span class="comment"> * 4、发送包裹send(DatagramPacket p)</span></span><br><span class="line"><span class="comment"> * 5、释放资源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pikachu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPSendTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"发送端启动中。。。。。。。"</span>);</span><br><span class="line">		<span class="comment">// 1、使用DatagramSocket 指定端口，创建发送端</span></span><br><span class="line">		DatagramSocket client = <span class="keyword">new</span> DatagramSocket(<span class="number">6666</span>);</span><br><span class="line">		<span class="comment">// 2、准备数据，转成字节数组</span></span><br><span class="line">		String s = <span class="string">"你好，朋友"</span>;</span><br><span class="line">		<span class="keyword">byte</span>[] datas = s.getBytes();</span><br><span class="line">		<span class="comment">// 3、将字节数组封装成DatagramPacket 包裹</span></span><br><span class="line">		DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(datas,<span class="number">0</span>,datas.length,<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">8888</span>));</span><br><span class="line">		<span class="comment">// 4、发送包裹send(DatagramPacket p)</span></span><br><span class="line">		client.send(packet);</span><br><span class="line">		<span class="comment">// 5、释放资源</span></span><br><span class="line">		client.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接收端"><a href="#接收端" class="headerlink" title="接收端"></a>接收端</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UDP使用基本步骤：接收端</span></span><br><span class="line"><span class="comment"> * 1、使用DatagramSocket 指定端口创建接收端</span></span><br><span class="line"><span class="comment"> * 2、准备容器，封装成DatagramPacket</span></span><br><span class="line"><span class="comment"> * 3、阻塞式接收receive(DatagramPacket p)</span></span><br><span class="line"><span class="comment"> * 4、分析数据：</span></span><br><span class="line"><span class="comment"> * 			getData()</span></span><br><span class="line"><span class="comment"> * 			getlength()</span></span><br><span class="line"><span class="comment"> * 5、释放资源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pikachu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPReceiveTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"接收方启动中。。。。。。。。。。"</span>);</span><br><span class="line">		<span class="comment">// 1、使用DatagramSocket 指定端口创建接收端</span></span><br><span class="line">		DatagramSocket sever = <span class="keyword">new</span> DatagramSocket(<span class="number">8888</span>);</span><br><span class="line">		<span class="comment">// 2、准备容器，封装成DatagramPacket</span></span><br><span class="line">		<span class="keyword">byte</span>[] datas = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">60</span>];</span><br><span class="line">		DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(datas,<span class="number">0</span>,datas.length);</span><br><span class="line">		<span class="comment">// 3、阻塞式接收receive</span></span><br><span class="line">		sever.receive(packet);</span><br><span class="line">		<span class="comment">// 4、分析数据：</span></span><br><span class="line">		<span class="comment">// 		getData</span></span><br><span class="line">		<span class="comment">// 		getlength</span></span><br><span class="line">		<span class="keyword">byte</span>[] b = packet.getData();</span><br><span class="line">		System.out.println(<span class="keyword">new</span> String(b,<span class="number">0</span>,b.length));</span><br><span class="line">		<span class="comment">// 5、释放资源</span></span><br><span class="line">		sever.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="TCP操作的基本步骤"><a href="#TCP操作的基本步骤" class="headerlink" title="TCP操作的基本步骤"></a>TCP操作的基本步骤</h1><h2 id="客户端："><a href="#客户端：" class="headerlink" title="客户端："></a>客户端：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCP编程：</span></span><br><span class="line"><span class="comment"> * 创建客户端Client</span></span><br><span class="line"><span class="comment"> * 1、建立连接：使用Socket创建客户端，指定服务器的IP和端口</span></span><br><span class="line"><span class="comment"> * 2、操作：输入输出流</span></span><br><span class="line"><span class="comment"> * 3、释放资源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pikachu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException, IOException </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"-----Client------"</span>);</span><br><span class="line">		<span class="comment">// 1、使用Socket创建客户端，指定IP和端口</span></span><br><span class="line">		Socket client = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>,<span class="number">8888</span>);</span><br><span class="line">		<span class="comment">// 2、操作：输入输出流</span></span><br><span class="line">		DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(client.getOutputStream());</span><br><span class="line">		String msc = <span class="string">"hello"</span>;</span><br><span class="line">		dos.writeUTF(msc);</span><br><span class="line">		dos.flush();</span><br><span class="line">		<span class="comment">// 3、释放资源	</span></span><br><span class="line">		dos.close();</span><br><span class="line">		client.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCP编程：</span></span><br><span class="line"><span class="comment"> * 创建服务器</span></span><br><span class="line"><span class="comment"> * 1、指定端口，使用SeverSocket创建服务器</span></span><br><span class="line"><span class="comment"> * 2、阻塞式等待连接 accept</span></span><br><span class="line"><span class="comment"> * 3、操作：输入输出流</span></span><br><span class="line"><span class="comment"> * 4、释放资源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pikachu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"-----Server------"</span>);</span><br><span class="line">		<span class="comment">// 1、指定端口，使用SeverSocket创建服务器</span></span><br><span class="line">		ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">		<span class="comment">// 2、阻塞式等待连接 accept</span></span><br><span class="line">		Socket client = server.accept();</span><br><span class="line">		System.out.println(<span class="string">"一个客户端建立了连接"</span>);</span><br><span class="line">		<span class="comment">// 3、操作：输入输出流</span></span><br><span class="line">		DataInputStream dis = <span class="keyword">new</span> DataInputStream(client.getInputStream());</span><br><span class="line">		String msc = dis.readUTF();</span><br><span class="line">		System.out.println(msc);</span><br><span class="line">		<span class="comment">// 4、释放资源</span></span><br><span class="line">		dis.close();</span><br><span class="line">		client.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="网络聊天室"><a href="#网络聊天室" class="headerlink" title="网络聊天室"></a>网络聊天室</h1><blockquote>
<p>一个可以实现群聊的网络聊天室</p>
</blockquote>
<h2 id="服务器-1"><a href="#服务器-1" class="headerlink" title="服务器"></a>服务器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现群聊</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pikachu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiChat</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 在服务器上创建容器</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> CopyOnWriteArrayList&lt;Channel&gt; all = <span class="keyword">new</span> CopyOnWriteArrayList&lt;Channel&gt;();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"-----Server------"</span>);</span><br><span class="line">		<span class="comment">// 1、指定端口，使用SeverSocket创建服务器</span></span><br><span class="line">		ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 2、阻塞式等待连接 accept</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			Socket client = server.accept();</span><br><span class="line">			System.out.println(<span class="string">"一个客户端建立了连接"</span>);</span><br><span class="line">			<span class="comment">// 将每一个客户端的连接放进容器</span></span><br><span class="line">			Channel c = <span class="keyword">new</span> Channel(client);</span><br><span class="line">			all.add(c);</span><br><span class="line">			<span class="keyword">new</span> Thread(c).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Channel</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> DataInputStream dis;</span><br><span class="line">		<span class="keyword">private</span> DataOutputStream dos;</span><br><span class="line">		<span class="keyword">private</span> Socket client;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">boolean</span> isRunning;</span><br><span class="line">		<span class="keyword">private</span> String name;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Channel</span><span class="params">(Socket client)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.client = client;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				dis = <span class="keyword">new</span> DataInputStream(client.getInputStream());</span><br><span class="line">				dos = <span class="keyword">new</span> DataOutputStream(client.getOutputStream());</span><br><span class="line">				<span class="keyword">this</span>.name = receive();</span><br><span class="line">				isRunning = <span class="keyword">true</span>;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">				System.out.println(<span class="string">"----1----"</span>);</span><br><span class="line">				release();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 接收消息</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			String msg = <span class="string">""</span>;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				msg = dis.readUTF();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				System.out.println(<span class="string">"----2----"</span>);</span><br><span class="line">				release();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> msg;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 发送消息</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				dos.writeUTF(msg);</span><br><span class="line">				dos.flush();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				System.out.println(<span class="string">"----3----"</span>);</span><br><span class="line">				release();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 将消息发给别人</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendOthers</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">for</span>(Channel other:all) &#123;</span><br><span class="line">				<span class="keyword">if</span>(other == <span class="keyword">this</span>) &#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				other.send(<span class="keyword">this</span>.name+<span class="string">"说:"</span>+msg);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 释放资源</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.isRunning = <span class="keyword">false</span>;</span><br><span class="line">			SxtUtils.close(dis,dos,client);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">while</span>(isRunning) &#123;</span><br><span class="line">				String msg = receive();</span><br><span class="line">				<span class="keyword">if</span>(!msg.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">					sendOthers(msg);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			release();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟网络群聊</span></span><br><span class="line"><span class="comment"> * 客户端</span></span><br><span class="line"><span class="comment"> * 实现多个客户消息的接收与发送</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pikachu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiClient</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException, IOException </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"-----Client------"</span>);</span><br><span class="line">		BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">		System.out.println(<span class="string">"请输入您的姓名："</span>);</span><br><span class="line">		String name = br.readLine();</span><br><span class="line">		<span class="comment">// 1、使用Socket创建客户端，指定IP和端口</span></span><br><span class="line">		Socket client = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>,<span class="number">8888</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> ClientSend(client,name)).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> ClientReceive(client)).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端发送"><a href="#客户端发送" class="headerlink" title="客户端发送"></a>客户端发送</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端的发送方法 封装</span></span><br><span class="line"><span class="comment"> * 加入多线程，实现读写同步进行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pikachu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientSend</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> BufferedReader reader;</span><br><span class="line">	<span class="keyword">private</span> DataOutputStream dos;</span><br><span class="line">	<span class="keyword">private</span> Socket client;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> isRunning;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ClientSend</span><span class="params">(Socket client,String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.client = client;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">			dos = <span class="keyword">new</span> DataOutputStream(client.getOutputStream());</span><br><span class="line">			<span class="keyword">this</span>.send(<span class="keyword">this</span>.name);</span><br><span class="line">			isRunning = <span class="keyword">true</span>;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">"====1===="</span>);</span><br><span class="line">			release();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 发送消息</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			dos.writeUTF(msg);</span><br><span class="line">			dos.flush();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">"====3===="</span>);</span><br><span class="line">			release();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 从控制台获取输入</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">getStrFromConsole</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> reader.readLine();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(isRunning) &#123;</span><br><span class="line">			String msg = <span class="keyword">this</span>.getStrFromConsole();</span><br><span class="line">			<span class="keyword">if</span>(!msg.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">				send(msg);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 释放资源</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.isRunning = <span class="keyword">false</span>;</span><br><span class="line">		SxtUtils.close(dos,client);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端接收"><a href="#客户端接收" class="headerlink" title="客户端接收"></a>客户端接收</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端的接收方法 封装</span></span><br><span class="line"><span class="comment"> * 加入多线程，实现读写同步进行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pikachu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientReceive</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> DataInputStream dis;</span><br><span class="line">	<span class="keyword">private</span> Socket client;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> isRunning;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ClientReceive</span><span class="params">(Socket client)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.client = client;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			dis = <span class="keyword">new</span> DataInputStream(client.getInputStream());</span><br><span class="line">			isRunning = <span class="keyword">true</span>;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">"====2===="</span>);</span><br><span class="line">			release();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String msg = <span class="string">""</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			msg = dis.readUTF();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">"====4===="</span>);</span><br><span class="line">			release();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> msg;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line">			String msg = receive();</span><br><span class="line">			<span class="keyword">if</span>(!msg.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">				System.out.println(msg);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.isRunning = <span class="keyword">false</span>;</span><br><span class="line">		SxtUtils.close(dis,client);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Closeable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工具类</span></span><br><span class="line"><span class="comment"> * 用于释放资源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pikachu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SxtUtils</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Closeable... targets)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(Closeable target:targets) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="keyword">null</span>!=target) &#123;</span><br><span class="line">					target.close();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/2019/03/16/Java/1.Java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>多线程在Java编程中无处不在，多应用于网络编程和服务器端应用开发</p>
<a id="more"></a>
<p><img src="/images/3.16.jpg" alt=""></p>
<hr>
<h1 id="Thread–多线程"><a href="#Thread–多线程" class="headerlink" title="Thread–多线程"></a>Thread–多线程</h1><h2 id="实现多线程的方法"><a href="#实现多线程的方法" class="headerlink" title="实现多线程的方法"></a>实现多线程的方法</h2><p>1.继承Thread类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.i = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 重写run方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建线程并启动</span></span><br><span class="line">	Test t = <span class="keyword">new</span> Test(<span class="number">666</span>);</span><br><span class="line">	t.start(); <span class="comment">// 启动线程</span></span><br></pre></td></tr></table></figure>
<p>2.实现Runnable接口</p>
<blockquote>
<p>优先使用接口实现多线程，可避免单继承带来的局限性</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.i = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 重写run方法(线程入口点)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// run方法没有返回类型，也不能抛出异常，有异常只能try..catch</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建线程并启动</span></span><br><span class="line">	Test t = <span class="keyword">new</span> Test(<span class="number">666</span>);</span><br><span class="line">	<span class="keyword">new</span> Thread(t).start(); <span class="comment">// 启动线程</span></span><br></pre></td></tr></table></figure>
<p>3.实现Callable接口<br>Callable接口比较高级，涉及到高并发的时候回比较常用。<br>实现Callable接口需要重写<strong>call()</strong>方法，该方法可以有返回值类型，也可以抛出异常</p>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>作用：避免匿名内部类定义过多<br>其实质属于函数式编程的概念</p>
<ul>
<li>lambda 表达式的推导</li>
</ul>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>1.新生状态 –&gt; NEW<br>new 对象，就进入新生状态</p>
<p>2.就绪状态 –&gt; RUNNABLE<br>以下四种情况会使线程进入就绪状态<br>    - start()<br>    - 阻塞状态解除<br>    - yield()<br>    - JVM干预</p>
<p>3.运行状态 –&gt; RUNNABLE<br>cpu调度到了，就进入运行状态</p>
<p>4.阻塞状态 –&gt; WAITING/TIMED_WAITING/BLOCKED<br>以下四种情况会使线程进入阻塞状态<br>    - sleep() –&gt; WAITING/TIMED_WAITING<br>    - join() –&gt;  WAITING/TIMED_WAITING<br>    - wait() –&gt; BLOCKED<br>    - read,write –&gt; BLOCKED</p>
<p>5.死亡状态 –&gt; TERMINATED<br>不推荐使用stop()和destory()来停止线程，因为这两个存在bug<br>可以使用添加boolean标志的方法停止线程，方便外部进行控制</p>
<h2 id="暂停sleep"><a href="#暂停sleep" class="headerlink" title="暂停sleep"></a>暂停sleep</h2><ul>
<li>sleep为静态方法，可以直接在线程中调用</li>
<li>sleep(毫秒数)指定当前线程阻塞的时间</li>
<li>sleep存在异常InterruptedException</li>
<li>sleep时间达到后线程进入就绪状态</li>
<li>sleep可以模拟网络延时、倒计时等</li>
<li>每一个对象都有一个锁，sleep不会释放锁（抱着对象睡觉）</li>
</ul>
<h2 id="礼让yield"><a href="#礼让yield" class="headerlink" title="礼让yield"></a>礼让yield</h2><ul>
<li>yield也是静态方法，可以在线程中直接调用</li>
<li>礼让线程，让当前正在执行的线程从<strong>运行状态</strong>转入<strong>就绪状态</strong></li>
<li>让cpu调度器重新调度<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YieldTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// lambda表达式</span></span><br><span class="line">		<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">				System.out.println(<span class="string">"lambda..."</span>+i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i%<span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">				Thread.yield(); <span class="comment">// 礼让，可能不成功</span></span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"main..."</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="插队join"><a href="#插队join" class="headerlink" title="插队join"></a>插队join</h2><blockquote>
<p>使用join后，需要等插队的线程执行完成后才能执行其他线程，<strong>其他线程阻塞</strong></p>
</blockquote>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><ul>
<li>优先级的取值范围在1-10之间</li>
<li>优先级有三个常量<ul>
<li>MAX_PRIORITY –&gt; 10</li>
<li>MIN_PRIORITY –&gt; 1</li>
<li>NORM_PRIORITY –&gt; 5</li>
</ul>
</li>
<li>在start()之前设置优先级</li>
<li>优先级高的不一定先执行，优先级只是代表执行的概率</li>
</ul>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><ul>
<li>所有的线程默认都是用户线程，守护线程需要手动设置</li>
<li>JVM停止不用考虑守护线程</li>
</ul>
<p>设置守护线程<br><code>t.setDaemon(true)</code></p>
<h2 id="线程的基本信息"><a href="#线程的基本信息" class="headerlink" title="线程的基本信息"></a>线程的基本信息</h2><ul>
<li>isAlive()</li>
<li>setName()</li>
<li>getName()</li>
<li>currentThread()</li>
</ul>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><h3 id="并发的三个条件"><a href="#并发的三个条件" class="headerlink" title="并发的三个条件"></a>并发的三个条件</h3><ul>
<li>同一个资源</li>
<li>多个线程</li>
<li>同时操作</li>
</ul>
<h3 id="线程同步-1"><a href="#线程同步-1" class="headerlink" title="线程同步"></a>线程同步</h3><p>1.概念：队列+锁=线程安全=线程同步</p>
<p>2.锁机制（synchronized）</p>
<ul>
<li><p>锁机制保证了线程的安全，但是带来了性能的问题</p>
</li>
<li><p>用法：<br>synchronized方法 –&gt;  同步方法<br>synchronized块 –&gt; 同步块</p>
<p>使用synchronized要注意：</p>
<pre><code>- 锁准对象，否则不能保证线程安全
- 锁准范围，如果将一个大的方法声明为synchronized，将会大大影响效率</code></pre><p>同步块：<strong>synchronized（obj）{ }</strong> ， obj称之为同步监视器<br>obj就是被锁的对象，就是要修改的那个对象<br>多用同步块，少用同步方法，因为同步块在保证线程安全的前提下，性能更优</p>
</li>
<li><p>死锁<br>过多的同步可能造成相互不释放资源，从而相互等待，一般发生于同步中持有多个对象的锁。<br>避免死锁：不要在同一个代码块中同时持有多个对象的锁</p>
</li>
</ul>
<h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><p>协作模型：生产者消费者模式<br>两种实现方法：</p>
<ul>
<li>管程法</li>
<li>信号灯法</li>
</ul>
<p><strong>管程法实现演示</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCooperation</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SynContainer container = <span class="keyword">new</span> SynContainer();</span><br><span class="line">		Productor productor = <span class="keyword">new</span> Productor(container);</span><br><span class="line">		Consumer consumer = <span class="keyword">new</span> Consumer(container);</span><br><span class="line">		productor.start();</span><br><span class="line">		consumer.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Productor</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	SynContainer container;	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Productor</span><span class="params">(SynContainer container)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.container = container;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 生产</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">105</span>;i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"生产 --&gt; 第"</span>+ i +<span class="string">"个馒头"</span>);</span><br><span class="line">			container.push(<span class="keyword">new</span> Steamedbun(i));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	SynContainer container;	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(SynContainer container)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.container = container;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 消费</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"消费 --&gt; 第"</span>+ container.pop().getId() +<span class="string">"个馒头"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓冲区</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynContainer</span></span>&#123;</span><br><span class="line">	Steamedbun[] buns = <span class="keyword">new</span> Steamedbun[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">//计数器</span></span><br><span class="line">	<span class="comment">// 储存 --&gt; 生产</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Steamedbun bun)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 何时生产 容器中有空余空间时</span></span><br><span class="line">		<span class="comment">// 没有空间，停止生产</span></span><br><span class="line">		<span class="keyword">if</span>(count == buns.length) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">this</span>.wait(); <span class="comment">// 线程阻塞，消费者通知生产时解除阻塞</span></span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 存在空间，可以生产</span></span><br><span class="line">		buns[count] = bun;</span><br><span class="line">		count++;</span><br><span class="line">		<span class="keyword">this</span>.notifyAll(); <span class="comment">// 唤醒消费者进行消费</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获取 --&gt; 消费</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Steamedbun <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 何时消费 判断容器中是否存在数据</span></span><br><span class="line">		<span class="comment">// 没有数据 --&gt; 等待</span></span><br><span class="line">		<span class="keyword">if</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">this</span>.wait(); <span class="comment">// 线程阻塞，生产者通知消费时解除阻塞</span></span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 存在数据 --&gt; 消费</span></span><br><span class="line">		count--; <span class="comment">// 从最后一个开始拿，拿了之后指向前一个，下一次放就从前面开始放了，覆盖了原来的</span></span><br><span class="line">		Steamedbun bun = buns[count];</span><br><span class="line">		<span class="keyword">this</span>.notifyAll(); <span class="comment">// 唤醒生产者进行生产</span></span><br><span class="line">		<span class="keyword">return</span> bun;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 馒头 --&gt; 资源</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Steamedbun</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Steamedbun</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>IO</title>
    <url>/2019/03/06/Java/1.Java%E5%9F%BA%E7%A1%80/IO/</url>
    <content><![CDATA[<p>Java.IO基本概念及File类</p>
<a id="more"></a>
<p><img src="/images/3.6.jpg" alt=""></p>
<hr>
<h2 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java.IO"></a>Java.IO</h2><h3 id="Java-IO包中最重要的就是5个类和三个接口"><a href="#Java-IO包中最重要的就是5个类和三个接口" class="headerlink" title="Java.IO包中最重要的就是5个类和三个接口"></a>Java.IO包中最重要的就是5个类和三个接口</h3><ul>
<li>File  文件类</li>
<li>InputStream  字节输入流</li>
<li>OutputStream  字节输出流</li>
<li>Reader  字符输入流</li>
<li>Writer  字符输出流</li>
<li>Closeable  关闭流接口</li>
<li>Flushable  刷新流接口</li>
<li>Serializable  序列化接口</li>
</ul>
<h3 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h3><p>按方向分：</p>
<ul>
<li>输入流</li>
<li>输出流</li>
</ul>
<p>按功能分：</p>
<ul>
<li>节点流：直接操作数据源，所有的IO操作必须经过节点流进行</li>
<li>处理流（包装流）：为了简化操作和提高性能</li>
</ul>
<p>按数据分：</p>
<ul>
<li>字节流</li>
<li>字符流（底层还是基于字节流操作，自动搜寻了指定的码表）</li>
</ul>
<h3 id="API的使用"><a href="#API的使用" class="headerlink" title="API的使用"></a>API的使用</h3><ul>
<li>先看继承体系</li>
<li>再看构造器（有/无）</li>
<li>最后看方法（方法名、接收参数、返回类型、调用者）</li>
</ul>
<h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><h4 id="构建File对象："><a href="#构建File对象：" class="headerlink" title="构建File对象："></a>构建File对象：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// File(String Path)</span></span><br><span class="line">File src = <span class="keyword">new</span> File(<span class="string">"C:/Users/pikachu/eclipse-workspace/sxt.Io/Java学习路线图.jpg"</span>);</span><br><span class="line"><span class="comment">// File(String parent, String child)</span></span><br><span class="line">File src = <span class="keyword">new</span> File(<span class="string">"C:/Users/pikachu/eclipse-workspace/sxt.Io"</span>,<span class="string">"Java学习路线图.jpg"</span>);</span><br><span class="line"><span class="comment">// File(File parent, String child)</span></span><br><span class="line">File src = <span class="keyword">new</span> File(<span class="keyword">new</span> File(<span class="string">"C:/Users/pikachu/eclipse-workspace/sxt.Io"</span>),<span class="string">"Java学习路线图.jpg"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="File类的常用方法："><a href="#File类的常用方法：" class="headerlink" title="File类的常用方法："></a>File类的常用方法：</h4><p>1.基本信息：</p>
<ul>
<li>getName -&gt;  获得文件名</li>
<li>getPath -&gt;    获得传入的路径</li>
<li>getAbsolutePath -&gt; 获得绝对路径</li>
<li>getParent -&gt; 获得父路径</li>
</ul>
<p>2.文件状态：</p>
<ul>
<li>exists -&gt; 是否存在</li>
<li>isFile -&gt; 是否是文件</li>
<li>isDirectory -&gt; 是否是文件夹<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断文件状态的标准代码</span></span><br><span class="line">File src = <span class="keyword">new</span> File(<span class="string">"xxx"</span>);</span><br><span class="line"><span class="keyword">if</span>(src == <span class="keyword">null</span> || !src.exists()) &#123;</span><br><span class="line">	System.out.println(<span class="string">"文件不存在"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(src.isFile()) &#123;</span><br><span class="line">	System.out.println(<span class="string">"文件操作"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">"目录操作"</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>3.文件长度：</p>
<ul>
<li>length() -&gt; 返回文件的长度（字节数），文件夹的length()返回0</li>
</ul>
<p>4.创建&amp;删除文件：</p>
<ul>
<li>createNewFile() -&gt; 不存在创建成功，已存在创建失败</li>
<li>delete()<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建文件</span></span><br><span class="line">File src = <span class="keyword">new</span> File(<span class="string">"C:/Users/pikachu/eclipse-workspace/sxt.Io/Java学习路线图02.jpg"</span>);</span><br><span class="line"><span class="keyword">boolean</span> flag = src.createNewFile(); <span class="comment">// 返回是否创建成功</span></span><br><span class="line"><span class="comment">// 删除文件</span></span><br><span class="line">flag = src.delete(); <span class="comment">// 返回是否删除成功</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>5.创建目录（文件夹）：</p>
<ul>
<li>mkdir() -&gt; 如果上级目录不存在，则会创建失败</li>
<li>mkdirs() -&gt; 如果上级目录不存在，则一同创建</li>
</ul>
<p>6.列出下级目录：</p>
<ul>
<li>list() -&gt; 列出下级文件名，返回一个数组</li>
<li>listFiles() -&gt; 列出下级文件对象，返回一个数组</li>
<li>listRoots() -&gt; 列出所有根目录，返回一个数组</li>
</ul>
<p>7.统计文件夹大小</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sxt.IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统计文件夹的大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pikachu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirCount</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span> Count;</span><br><span class="line">	<span class="keyword">private</span> String path;</span><br><span class="line">	<span class="keyword">private</span> File src;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DirCount</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.path = path;</span><br><span class="line">		<span class="keyword">this</span>.src = <span class="keyword">new</span> File(path);</span><br><span class="line">		count(<span class="keyword">this</span>.src);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 统计文件夹大小</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">(File src)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">null</span> != src &amp;&amp; src.exists()) &#123;</span><br><span class="line">			<span class="keyword">if</span>(src.isFile()) &#123;</span><br><span class="line">				Count += src.length();</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(src.isDirectory()) &#123;</span><br><span class="line">				<span class="keyword">for</span>(File s:src.listFiles()) &#123;</span><br><span class="line">					count(s);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// get方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Count;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 测试</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		DirCount dc = <span class="keyword">new</span> DirCount(<span class="string">"C:\\Users\\pikachu\\eclipse-workspace\\sxt.Io"</span>);</span><br><span class="line">		System.out.println(dc.getCount());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h2><ul>
<li>编码： 字符 -&gt; 字节</li>
<li>解码： 字节 -&gt; 字符</li>
</ul>
<h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><ul>
<li>UTF-8</li>
<li>GBK</li>
<li>Unicode</li>
<li>……</li>
</ul>
<h2 id="字符串进行编码"><a href="#字符串进行编码" class="headerlink" title="字符串进行编码"></a>字符串进行编码</h2><p>getBytes() 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">"哈哈你好"</span>;</span><br><span class="line"><span class="keyword">byte</span>[] b = s.getBytes(); <span class="comment">// 返回一个字节数组</span></span><br></pre></td></tr></table></figure>

<h2 id="字节进行解码"><a href="#字节进行解码" class="headerlink" title="字节进行解码"></a>字节进行解码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(b); <span class="comment">// 调用String类的构造器，传入一个字节数组</span></span><br></pre></td></tr></table></figure>

<h2 id="乱码的原因"><a href="#乱码的原因" class="headerlink" title="乱码的原因"></a>乱码的原因</h2><ul>
<li>字节数不够</li>
<li>字符集不统一</li>
</ul>
<h2 id="IO中的四大抽象基类"><a href="#IO中的四大抽象基类" class="headerlink" title="IO中的四大抽象基类"></a>IO中的四大抽象基类</h2><ul>
<li>InputStream –&gt; 字节输入流</li>
<li>OutputStream –&gt; 字节输出流</li>
<li>Reader –&gt; 字符输入流</li>
<li>Writer –&gt; 字符输出流</li>
</ul>
<h2 id="IO流操作的标准步骤"><a href="#IO流操作的标准步骤" class="headerlink" title="IO流操作的标准步骤"></a>IO流操作的标准步骤</h2><ol>
<li>创建源</li>
<li>选择流</li>
<li>操作</li>
<li>释放资源</li>
</ol>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInputStream01</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建源</span></span><br><span class="line">		File src = <span class="keyword">new</span> File(<span class="string">"C:/Users/pikachu/eclipse-workspace/sxt.Io/src/sxt.txt"</span>);</span><br><span class="line">		<span class="comment">// 选择流</span></span><br><span class="line">		InputStream is = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			is = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line">			<span class="keyword">int</span> temp;</span><br><span class="line">			<span class="comment">// 操作</span></span><br><span class="line">			<span class="keyword">while</span>((temp=is.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">				System.out.print((<span class="keyword">char</span>)temp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">// 释放资源</span></span><br><span class="line">			<span class="keyword">if</span>(is!=<span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					is.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">					<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="文件字节流"><a href="#文件字节流" class="headerlink" title="文件字节流"></a>文件字节流</h2><ul>
<li><p>FileInputStream </p>
<p>文件字节输入流，通过字节方式读取文件<br>全字符请考虑：FileReader</p>
</li>
<li><p>FileOutputStream</p>
<p>文件字节输出流，通过字节的方式写出或追加数据到文件<br>全字符请考虑：FileWriter</p>
</li>
</ul>
<h2 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h2><p>利用FileInputStream和FileOutputStream进行文件的拷贝</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 创建源</span></span><br><span class="line">	File src = <span class="keyword">new</span> File(<span class="string">"C:/Users/pikachu/eclipse-workspace/sxt.Io/Java学习路线图.jpg"</span>);</span><br><span class="line">	File dest = <span class="keyword">new</span> File(<span class="string">"dest2.jpg"</span>);</span><br><span class="line">	<span class="comment">// 选择流</span></span><br><span class="line">	InputStream is = <span class="keyword">null</span>;</span><br><span class="line">	OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		is = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line">		os = <span class="keyword">new</span> FileOutputStream(dest<span class="comment">/*,true*/</span>);</span><br><span class="line">		<span class="comment">// 操作</span></span><br><span class="line">		<span class="keyword">byte</span>[] datas = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>((len = is.read(datas))!= -<span class="number">1</span>) &#123;</span><br><span class="line">			os.write(datas, <span class="number">0</span>, len); <span class="comment">// 写入	</span></span><br><span class="line">		&#125;</span><br><span class="line">		os.flush(); <span class="comment">// 强制刷新</span></span><br><span class="line">	&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="comment">// 释放资源</span></span><br><span class="line">		<span class="keyword">if</span>(os!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				os.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(is!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				is.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>IO流其实就是一个管子，把字节或字符放到管子里面进行操作</p>
</blockquote>
<h2 id="文件字符流"><a href="#文件字符流" class="headerlink" title="文件字符流"></a>文件字符流</h2><blockquote>
<p>文件字符流可以消除不同字符集的编码差异</p>
</blockquote>
<ul>
<li>FileReader</li>
<li>FileWriter<br>FileWriter中有一个需要注意的方法：<br><code>append() // 返回值类型为Writer，可以以‘流模式’来添加</code></li>
</ul>
<p>文件字符流操作的是<strong>字符数组</strong><br>文件字节流操作的是<strong>字节数组</strong></p>
<h2 id="字节数组流"><a href="#字节数组流" class="headerlink" title="字节数组流"></a>字节数组流</h2><ul>
<li>ByteArrayInputStream</li>
<li>ByteArrayOutputStream</li>
</ul>
<blockquote>
<p>字节数组流操作的是内存中的字节数组，不与OS打交道，故可由gc自动回收，不用关闭<br>任何东西都可以转成字节数组，可以方便后期进行网络传输等操作</p>
</blockquote>
]]></content>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>异常</title>
    <url>/2019/03/03/Java/1.Java%E5%9F%BA%E7%A1%80/%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<p>异常</p>
<a id="more"></a>

<h2 id="一-异常"><a href="#一-异常" class="headerlink" title="一 异常"></a>一 异常</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="comment">// 可能存在异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">	<span class="comment">// 无论是否存在异常都要执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>时间相关类</title>
    <url>/2019/03/02/Java/1.Java%E5%9F%BA%E7%A1%80/%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3%E7%B1%BB/</url>
    <content><![CDATA[<p>Date、DateFormat &amp; Calendar、GregorianCalendar</p>
<a id="more"></a>

<p><img src="/images/3.2.jpg" alt=""></p>
<h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p>Date 是表示时间的类，其中的好多方法现在已经废弃不用了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date d = <span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(d); <span class="comment">// 获取计算机的当前时间</span></span><br><span class="line"></span><br><span class="line">System.out.println(d.getTime()) <span class="comment">// 获取当前时间的毫秒数</span></span><br></pre></td></tr></table></figure>

<h2 id="DateFormat"><a href="#DateFormat" class="headerlink" title="DateFormat"></a>DateFormat</h2><p>DateFormat 是用于时间格式化的抽象类,<strong>SimpleDateFormat</strong> 为其实现类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将时间按照指定格式转换为字符串</span></span><br><span class="line">DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd hh:mm:ss"</span>);</span><br><span class="line">String s = df.format(<span class="keyword">new</span> Date()); <span class="comment">// 将当前时间传入</span></span><br><span class="line">System.out.println(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串按照指定格式转换为时间</span></span><br><span class="line">DateFormat df2 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd hh:mm:ss"</span>);</span><br><span class="line">Date d = df2.parse(<span class="string">"2019-3-2 15:30:26"</span>);</span><br><span class="line">System.out.println(d);</span><br></pre></td></tr></table></figure>

<h2 id="Calendar、GregorianCalendar"><a href="#Calendar、GregorianCalendar" class="headerlink" title="Calendar、GregorianCalendar"></a>Calendar、GregorianCalendar</h2><p>Calendar 是表示日期的抽象类，GregorianCalendar 为其实现类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get方法</span></span><br><span class="line">Calendar c1 = <span class="keyword">new</span> GregorianCalendar(<span class="number">2019</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">19</span>,<span class="number">55</span>);</span><br><span class="line"><span class="keyword">int</span> year = c1.get(Calendar.YEAR);</span><br><span class="line"><span class="keyword">int</span> month = c1.get(Calendar.MONTH);</span><br><span class="line">System.out.println(year);</span><br><span class="line">System.out.println(month);</span><br><span class="line">	</span><br><span class="line"><span class="comment">// set方法</span></span><br><span class="line">Calendar c2 = <span class="keyword">new</span> GregorianCalendar();</span><br><span class="line">c2.set(Calendar.YEAR, <span class="number">2222</span>);</span><br><span class="line">System.out.println(c2);</span><br><span class="line">c2.add(Calendar.DAY_OF_MONTH,<span class="number">20</span> );</span><br><span class="line">System.out.println(c2);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Java</tag>
        <tag>时间类</tag>
      </tags>
  </entry>
  <entry>
    <title>Integer &amp; StringBuilder</title>
    <url>/2019/03/01/Java/1.Java%E5%9F%BA%E7%A1%80/Integer&amp;StringBuilder/</url>
    <content><![CDATA[<p>Integer &amp; StringBuilder</p>
<a id="more"></a>

<p><img src="D:%5Cdevelop%5Cblog%5Csource%5Cimages%5CInteger&StringBuilder%5C3.1.jpg" alt="3.1"></p>
<h2 id="一、Integer"><a href="#一、Integer" class="headerlink" title="一、Integer"></a>一、Integer</h2><p>Integer为int的包装类，可创建对象</p>
<ul>
<li>Integer 与 int 类型的相互转换</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// int to Integer</span></span><br><span class="line">Integer a = <span class="number">1</span>; <span class="comment">// 自动装箱</span></span><br><span class="line">Integer b = <span class="keyword">new</span> Integer(<span class="number">2</span>);</span><br><span class="line">Integer c = Integer.valueOf(<span class="number">3</span>); <span class="comment">// 最基础方法，官方推荐</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Integer to int</span></span><br><span class="line"><span class="keyword">int</span> d = a; <span class="comment">// 自动拆箱</span></span><br><span class="line"><span class="keyword">int</span> e = b.intValue();</span><br></pre></td></tr></table></figure>


<ul>
<li>String 与 Integer之间的相互转换</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String to Integer</span></span><br><span class="line">Integer a = <span class="keyword">new</span> Integer(<span class="string">"123"</span>);</span><br><span class="line">Integer b = Integer.valueOf(<span class="string">"456"</span>);</span><br><span class="line">Integer c = Integer.parseInt(<span class="string">"789"</span>); <span class="comment">// 最基础方法</span></span><br></pre></td></tr></table></figure>

<p><code>String s = a.toString();  // Integer to String</code></p>
<blockquote>
<p>创建Integer对象的时候要注意缓存区的问题。[-128,127]</p>
</blockquote>
<h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><p>StringBuilder是一个存放String对象的数组，<strong>可自动扩容</strong><br>StringBuffer类似于StringBuilder,但是后者效率更高，故更常用</p>
<p>StringBuilder常用方法:<br>StringBuilder sb = new StringBuilder();</p>
<ul>
<li>sb.append(“aa”);</li>
<li>sb.setCharAt(1,’bb’);</li>
<li>sb.insert(2,’cc’);</li>
<li>sb.delete(1,6); // 删除下标为1-5的元素</li>
<li>sb.deleteCharAt(3); // 删除指定位置元素</li>
<li>sb.reverse();  // 逆序</li>
<li>sb.length();</li>
<li>sb.indexOf(“dd”); // 返回指定元素索引</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Java</tag>
        <tag>包装类</tag>
        <tag>Integer</tag>
        <tag>StringBuilder</tag>
      </tags>
  </entry>
  <entry>
    <title>数组</title>
    <url>/2019/02/28/Java/1.Java%E5%9F%BA%E7%A1%80/%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>数组</p>
<a id="more"></a>

<p><img src="/images/2.28.jpg" alt=""></p>
<h2 id="1、数组的定义"><a href="#1、数组的定义" class="headerlink" title="1、数组的定义"></a>1、数组的定义</h2><h2 id="2、数组的内存状态"><a href="#2、数组的内存状态" class="headerlink" title="2、数组的内存状态"></a>2、数组的内存状态</h2><h2 id="3、数组的初始化方式"><a href="#3、数组的初始化方式" class="headerlink" title="3、数组的初始化方式"></a>3、数组的初始化方式</h2><ul>
<li>默认初始化<br><code>int[] arr1 = new int[3];</code></li>
<li>静态初始化<br><code>int[] arr2 = {1,2,3};</code></li>
<li>动态初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr3 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">arr3[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">arr3[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">arr3[<span class="number">2</span>] = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h2 id="4、数组的遍历"><a href="#4、数组的遍历" class="headerlink" title="4、数组的遍历"></a>4、数组的遍历</h2><ul>
<li>利用for循环遍历</li>
<li>利用for-each循环遍历</li>
</ul>
<h2 id="5、数组的拷贝"><a href="#5、数组的拷贝" class="headerlink" title="5、数组的拷贝"></a>5、数组的拷贝</h2><p>数组拷贝的核心代码：<br><code>System.arraycopy(src, srcPos, dest, destPos, length);</code></p>
<ul>
<li>以下三种操作本质上都是使用数组的拷贝<ul>
<li>数组中元素的删除</li>
<li>数组扩容</li>
<li>数组中插入元素</li>
</ul>
</li>
</ul>
<h2 id="6、Arrays工具类"><a href="#6、Arrays工具类" class="headerlink" title="6、Arrays工具类"></a>6、Arrays工具类</h2><p>Arrays工具类中常用的几种方法</p>
<p><code>Arrays.toString();</code><br><code>Arrays.sort();</code><br><code>Arrays.binarySearch(a/*数组*/, int key);</code></p>
<h2 id="7、多维数组"><a href="#7、多维数组" class="headerlink" title="7、多维数组"></a>7、多维数组</h2><h2 id="8、冒泡排序"><a href="#8、冒泡排序" class="headerlink" title="8、冒泡排序"></a>8、冒泡排序</h2><h2 id="9、二分法查找"><a href="#9、二分法查找" class="headerlink" title="9、二分法查找"></a>9、二分法查找</h2>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Java</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>request库的5个爬虫小框架</title>
    <url>/2018/08/12/Python/Python_old/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/Requests%E5%BA%935%E4%B8%AA%E7%88%AC%E8%99%AB%E5%B0%8F%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<ol>
<li><p>京东商品页面爬取</p>
</li>
<li><p>亚马逊商品页面爬取</p>
</li>
<li><p>百度搜索关键词提交</p>
</li>
<li><p>网络图片的爬取</p>
</li>
<li><p>IP地址归属地自动查询</p>
</li>
</ol>
<a id="more"></a>

<ul>
<li>1 京东商品页面爬取</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">"https://item.jd.com/7629588.html"</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    r = requests.get(url)</span><br><span class="line">    r.raise_for_status()</span><br><span class="line">    r.encoding = r.apparent_encoding</span><br><span class="line">    print(r.text[:<span class="number">1000</span>])</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">"爬取失败"</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>2 亚马逊商品页面爬取</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">"https://www.amazon.cn/dp/B07896QS5D"</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    kv = &#123;<span class="string">'user-agent'</span>:<span class="string">'Mozilla/5.0'</span>&#125;</span><br><span class="line">    r = requests.get(url,headers=kv)</span><br><span class="line">    r.raise_for_status()</span><br><span class="line">    r.encoding = r.apparent_encoding</span><br><span class="line">    print(r.text[<span class="number">1000</span>:<span class="number">2000</span>])</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">"爬取失败"</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>3 百度搜索关键词提交</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">keyword = <span class="string">"Python"</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    kv = &#123;<span class="string">'wd'</span>:keybord&#125;</span><br><span class="line">    r = requests.get(<span class="string">"http://www.baidu.com/s"</span>,params = kv)</span><br><span class="line">    print(r.request.url)</span><br><span class="line">    r.raise_for_status()</span><br><span class="line">    print(len(r.text))</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">"爬取失败"</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>4 网络图片的爬取</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">url = <span class="string">"http://image.nationalgeographic.com.cn/2017/0928/20170928105418550.jpg"</span></span><br><span class="line">root = <span class="string">"D://"</span></span><br><span class="line">path = root + url.split(<span class="string">'/'</span>)[<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(root):</span><br><span class="line">        os.mkdir(root)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">        r = requests.get(url)</span><br><span class="line">        <span class="keyword">with</span> open(path,<span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(r.content)</span><br><span class="line">            f.close()</span><br><span class="line">            print(<span class="string">"文件保存成功"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"文件已存在"</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">"爬取失败"</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>5 IP地址归属地自动查询</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">"http://m.ip138.com/ip.asp?ip="</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    r = requests.get(url + <span class="string">'202.204.80.112'</span>)</span><br><span class="line">    r.raise_for_ststus()</span><br><span class="line">    r.encoding = r.apparent_encoding</span><br><span class="line">    print(r.text[<span class="number">-500</span>:])</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">"爬去失败"</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>request库</title>
    <url>/2018/08/10/Python/Python_old/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/Requests%E5%BA%93/</url>
    <content><![CDATA[<p>requests库为专业的爬虫第三方库</p>
<a id="more"></a>

<h2 id="requests库主要有7个方法："><a href="#requests库主要有7个方法：" class="headerlink" title="requests库主要有7个方法："></a>requests库主要有7个方法：</h2><pre><code>requests.request()    构造一个请求，支撑以下各方法的基础方法
requests.get()    获取HTML网页的主要方法，对应于HTTP的GET
requests.head()    获取HTML网页头信息的方法，对应于HTTP的HEAD
requests.post()    向HTML网页提交POST请求的方法，对应于HTTP的POST
requests.put()    向HTML网页提交PUT请求的方法，对应于HTTP的PUT
requests.patch()    向HTML网页提交局部修改请求，对应于HTTP的PATCH
requests.delete()    向HTML网页提交删除请求，对应于HTTP的DELETE</code></pre><h2 id="r-requests-get-url"><a href="#r-requests-get-url" class="headerlink" title="r = requests.get(url)"></a>r = requests.get(url)</h2><p>Requests库的两个重要对象：Response 和 Request<br>Response对象包含服务器返回的所有信息，也包含请求的Request信息</p>
<p>Response对象的属性：</p>
<pre><code>r.status_code        HTTP请求的返回状态，200表示连接成功，404或其他表示失败
r.text               HTTP响应内容的字符串形式，即URL对应的页面内容
r.encoding           从HTTP header中猜测响应内容编码方式
r.apparent_encoding  从内容中分析出响应内容编码方式（备选编码方式）
r.content            HTTP响应内容的二进制形式</code></pre><h2 id="Requests库的异常"><a href="#Requests库的异常" class="headerlink" title="Requests库的异常"></a>Requests库的异常</h2><pre><code>requests.ConnectionError   网络连接错误异常
requests.HTTPError         HTTP错误异常
requests.URLRequired       URL缺失异常
requests.TooManyRedirects  超过最大重定向次数，产生重定向异常
requests.ConnectTimeout    连接远程服务器超时异常
requests.Timeout           请求URL超时，产生超时异常</code></pre><h2 id="爬取网页的通用代码框架"><a href="#爬取网页的通用代码框架" class="headerlink" title="爬取网页的通用代码框架"></a>爬取网页的通用代码框架</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    r = requests.get(url)</span><br><span class="line">    r.raise_for_status()</span><br><span class="line">    r.encoding = r.apparent_encoding</span><br><span class="line">    print(r.text)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">"爬取失败"</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Python标准库</title>
    <url>/2018/08/08/Python/Python_old/Python%E6%A0%87%E5%87%86%E5%BA%93/</url>
    <content><![CDATA[<p>time库&amp;random库</p>
<a id="more"></a>

<h2 id="time库"><a href="#time库" class="headerlink" title="time库"></a>time库</h2><h3 id="time库包括3类函数："><a href="#time库包括3类函数：" class="headerlink" title="time库包括3类函数："></a>time库包括3类函数：</h3><ul>
<li>时间获取：<code>time()</code>, <code>ctime()</code>, <code>gmtime()</code></li>
<li>时间格式化：<code>strftime()</code>, <code>strptime()</code></li>
<li>程序计时：  <code>perf_counter()</code>, <code>sleep()</code></li>
</ul>
<h4 id="1-时间获取："><a href="#1-时间获取：" class="headerlink" title="1.时间获取："></a>1.时间获取：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">time.time()    <span class="comment"># 获取当前时间戳，即计算机内部时间值，返回浮点数</span></span><br><span class="line"><span class="comment"># 1600487832.4588485</span></span><br><span class="line"></span><br><span class="line">time.ctime()    <span class="comment"># 获取当前时间, 并以易读方式表示，返回字符串</span></span><br><span class="line"><span class="comment"># 'Sat Sep 19 11:57:39 2020'</span></span><br><span class="line"></span><br><span class="line">time.gmtime()    <span class="comment"># 获取当前时间，表示为计算机程序可处理的时间格式</span></span><br><span class="line"><span class="comment"># time.struct_time(tm_year=2020, tm_mon=9, tm_mday=19, tm_hour=3, tm_min=57, tm_sec=55, tm_wday=5, tm_yday=263, tm_isdst=0)</span></span><br></pre></td></tr></table></figure>

<h4 id="2-时间格式化："><a href="#2-时间格式化：" class="headerlink" title="2.时间格式化："></a>2.时间格式化：</h4><p><code>strftime(tpl,ts)</code></p>
<ul>
<li><code>tpl</code>是格式化模板字符串，用来定义输出效果</li>
<li><code>ts</code>是计算机内部时间类型变量,用 <code>gmtime()</code> / <code>localtime()</code>获取</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">t = time.gmtime()  <span class="comment"># gmtime()表示0时区标准时间</span></span><br><span class="line">time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>,t)</span><br><span class="line"><span class="comment"># '2020-09-19 04:00:12'</span></span><br><span class="line"></span><br><span class="line">t_local = time.localtime()  <span class="comment"># localtime()表示本地时间</span></span><br><span class="line">time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>,t_local)</span><br><span class="line"><span class="comment"># '2020-09-19 12:01:25'</span></span><br></pre></td></tr></table></figure>


<p>格式化控制符：    </p>
<table>
<thead>
<tr>
<th align="left">%Y</th>
<th align="left">%m</th>
<th align="left">%B</th>
<th align="left">%b</th>
<th align="left">%A</th>
<th align="left">%a</th>
</tr>
</thead>
<tbody><tr>
<td align="left">年份</td>
<td align="left">月份</td>
<td align="left">月份名称</td>
<td align="left">月份名称缩写</td>
<td align="left">星期</td>
<td align="left">星期缩写</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">%d</th>
<th align="left">%H</th>
<th align="left">%h</th>
<th align="left">%p</th>
<th align="left">%M</th>
<th align="left">%S</th>
</tr>
</thead>
<tbody><tr>
<td align="left">日期</td>
<td align="left">24小时制</td>
<td align="left">12小时制</td>
<td align="left">上下午</td>
<td align="left">分钟</td>
<td align="left">秒</td>
</tr>
</tbody></table>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">strptime(str,tpl)</span><br></pre></td></tr></table></figure>
<p>str是字符串形式的时间值，<br>tpl是格式化模板字符串，用来定义输出效果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">timestr = <span class="string">'2018-07-29 16:21:22'</span></span><br><span class="line">time.strptime(timestr,<span class="string">"%Y-%m-%d %H:%M:%S"</span>)</span><br></pre></td></tr></table></figure>

<h4 id="3-程序计时应用："><a href="#3-程序计时应用：" class="headerlink" title="3.程序计时应用："></a>3.程序计时应用：</h4><p>测量时间: perf_counter()    返回一个CPU级别的精确时间计数值，单位为秒</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">start = time.perf_counter()</span><br><span class="line">end = time.perf_counter()</span><br><span class="line">end-start</span><br></pre></td></tr></table></figure>

<p>产生时间: sleep(s)    s为拟休眠时间，单位为秒，可为浮点数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wait</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">6.66</span>)</span><br><span class="line">wait()  <span class="comment">#  程序将暂停6.66秒</span></span><br></pre></td></tr></table></figure>

<h2 id="random库"><a href="#random库" class="headerlink" title="random库"></a>random库</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基本随机数函数</span></span><br><span class="line">random.seed()  <span class="comment">#初始化给定的随机数种子(种子相同, 产生的随机数序列就相同), 默认为当前系统时间</span></span><br><span class="line">random.random()  <span class="comment">#生成一个[0,1)之间的随机小数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 扩展随机数函数</span></span><br><span class="line">random.randint(a,b)  <span class="comment">#生成一个[a,b]之间的整数</span></span><br><span class="line">random.uniform(a,b)  <span class="comment">#生成一个[a,b]之间的小数</span></span><br><span class="line">random.getrandbits(k)  <span class="comment">#生成一个k比特长的随机整数</span></span><br><span class="line">random.randrange(m,n[,k])  <span class="comment">#生成一个[m,n)之间以k为步长的随机整数</span></span><br><span class="line">random.choice(seq)  <span class="comment">#从序列seq中随机选择一个元素</span></span><br><span class="line">random.shuffle(seq)  <span class="comment">#将序列seq中元素随机排列，返回打乱后的序列</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>time库</tag>
        <tag>random库</tag>
      </tags>
  </entry>
  <entry>
    <title>Python程序实例</title>
    <url>/2018/08/06/Python/Python_old/Python%E7%A8%8B%E5%BA%8F%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<p>7个python程序设计的小例子</p>
<a id="more"></a>

<h2 id="实例1：Python温度转换实例代码"><a href="#实例1：Python温度转换实例代码" class="headerlink" title="实例1：Python温度转换实例代码"></a>实例1：Python温度转换实例代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#TenpConvert.py</span></span><br><span class="line">TempStr = input(<span class="string">"请输入带有符号的温度值："</span>)</span><br><span class="line"><span class="keyword">if</span> TempStr[<span class="number">-1</span>] <span class="keyword">in</span> [<span class="string">'F'</span>,<span class="string">'f'</span>]:</span><br><span class="line">	C = (eval(TempStr[<span class="number">0</span>:<span class="number">-1</span>])<span class="number">-32</span>)/<span class="number">1.8</span></span><br><span class="line">	print(<span class="string">"转换后的温度是&#123;:.2f&#125;C"</span>.format(C))</span><br><span class="line"><span class="keyword">elif</span> TempStr[<span class="number">-1</span>] <span class="keyword">in</span> [<span class="string">'C'</span>,<span class="string">'c'</span>]:</span><br><span class="line">	F = <span class="number">1.8</span>*eval(TempStr[<span class="number">0</span>:<span class="number">-1</span>])+<span class="number">32</span></span><br><span class="line">	print(<span class="string">"转换后的温度是&#123;:.2f&#125;F"</span>.format(F))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	print(<span class="string">"输入格式错误"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="实例2：Python蟒蛇绘制"><a href="#实例2：Python蟒蛇绘制" class="headerlink" title="实例2：Python蟒蛇绘制"></a>实例2：Python蟒蛇绘制</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#PythonDraw.py</span></span><br><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line">turtle.setup(<span class="number">650</span>,<span class="number">350</span>,<span class="number">200</span>,<span class="number">200</span>)</span><br><span class="line">turtle.penup()</span><br><span class="line">turtle.fd(<span class="number">-250</span>)</span><br><span class="line">turtle.pendown()</span><br><span class="line">turtle.pensize(<span class="number">25</span>)</span><br><span class="line">turtle.pencolor(<span class="string">"purple"</span>)</span><br><span class="line">turtle.seth(<span class="number">-40</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    turtle.circle(<span class="number">40</span>,<span class="number">80</span>)</span><br><span class="line">    turtle.circle(<span class="number">-40</span>,<span class="number">80</span>)</span><br><span class="line">turtle.circle(<span class="number">40</span>,<span class="number">80</span>/<span class="number">2</span>)</span><br><span class="line">turtle.fd(<span class="number">40</span>)</span><br><span class="line">turtle.circle(<span class="number">16</span>,<span class="number">180</span>)</span><br><span class="line">turtle.fd(<span class="number">40</span> * <span class="number">2</span>/<span class="number">3</span>)</span><br><span class="line">turtle.done()</span><br></pre></td></tr></table></figure>

<h2 id="实例3：天天天向上的力量"><a href="#实例3：天天天向上的力量" class="headerlink" title="实例3：天天天向上的力量"></a>实例3：天天天向上的力量</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#DayDayUpQ1.py    每天进步千分之一</span></span><br><span class="line">dayup = pow(<span class="number">1.001</span>,<span class="number">365</span>)</span><br><span class="line">daydown = (pow(<span class="number">0.999</span>,<span class="number">365</span>)</span><br><span class="line">print(<span class="string">"向上:&#123;:.2f&#125;,向下:&#123;:.2f&#125;"</span>.format(dayup,daydown))</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#DayDayUpQ2    每天进步千分之五</span></span><br><span class="line">dayfactor = <span class="number">0.005</span>    <span class="comment">#使用变量的好处：一次修改即可</span></span><br><span class="line">dayup = pow(<span class="number">1</span>+dayfactor,<span class="number">365</span>)</span><br><span class="line">daydown = pow(<span class="number">1</span>-dayfactor,<span class="number">365</span>)</span><br><span class="line">print(<span class="string">"向上:&#123;:.2f&#125;,向下:&#123;:.2f&#125;"</span>.format(dayup,daydown)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#DayDayUpQ3    工作日的力量</span></span><br><span class="line">dayup = <span class="number">1.0</span></span><br><span class="line">dayfactory = <span class="number">0.01</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">365</span>):</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">7</span> <span class="keyword">in</span> [<span class="number">6</span>,<span class="number">0</span>]:</span><br><span class="line">        dayup = dayup*(<span class="number">1</span>-dayfactor)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        dayup = dayup*(<span class="number">1</span>+dayfactor)</span><br><span class="line">print(<span class="string">"工作日的力量:&#123;:.2f&#125;"</span>.format(dayup))</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#DayDayUpQ4    工作日要多努力才能与每天努力1%一样</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DayUp</span><span class="params">(df)</span>:</span></span><br><span class="line">    dayup = <span class="number">1.0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">365</span>):</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">7</span> <span class="keyword">in</span> [<span class="number">6</span>,<span class="number">0</span>]:</span><br><span class="line">            dayup = dayup*(<span class="number">1</span><span class="number">-0.01</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dayup = dayup*(<span class="number">1</span>+df)</span><br><span class="line">    <span class="keyword">return</span> dayup</span><br><span class="line">dayfactor = <span class="number">0.01</span></span><br><span class="line"><span class="keyword">while</span> DayUp(dayfactory) &lt; <span class="number">37.78</span>:</span><br><span class="line">    dayfactor += <span class="number">0.001</span></span><br><span class="line">print(<span class="string">"工作日的努力参数是:&#123;:.3f&#125;"</span>.format(dayfactor))</span><br></pre></td></tr></table></figure>

<h2 id="实例4：文本进度条"><a href="#实例4：文本进度条" class="headerlink" title="实例4：文本进度条"></a>实例4：文本进度条</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">scale = <span class="number">50</span></span><br><span class="line">print(<span class="string">"执行开始"</span>.center(scale//<span class="number">2</span>,<span class="string">"-"</span>))</span><br><span class="line">start = time.perf_counter()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(scale+<span class="number">1</span>):</span><br><span class="line">    a = <span class="string">"*"</span> * i</span><br><span class="line">    b = <span class="string">"."</span> * (scale - i)</span><br><span class="line">    c = (i/scale) * <span class="number">100</span></span><br><span class="line">    dur = time.perf_counter() - start</span><br><span class="line">    print(<span class="string">"\r&#123;:^3.0f&#125;%[&#123;&#125;-&gt;&#123;&#125;]&#123;:.2f&#125;s"</span>.format(c,a,b,dur),end = <span class="string">""</span>)</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">print(<span class="string">"/n"</span>+<span class="string">"执行开始"</span>.center(scale//<span class="number">2</span>,<span class="string">"-"</span>))</span><br></pre></td></tr></table></figure>

<h2 id="实例5：身体质量指数BMI"><a href="#实例5：身体质量指数BMI" class="headerlink" title="实例5：身体质量指数BMI"></a>实例5：身体质量指数BMI</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#BMI    #分支结构是程序的重要框架</span></span><br><span class="line">height,weight = eval(input(<span class="string">"请输入身高（米）和体重（公斤）[逗号隔开]:"</span>))</span><br><span class="line">bmi = weight / pow(height,<span class="number">2</span>)</span><br><span class="line">print(<span class="string">"BMI值为:&#123;:.2f&#125;"</span>.format(bmi))</span><br><span class="line">who,nat = <span class="string">""</span>,<span class="string">""</span></span><br><span class="line"><span class="keyword">if</span> bmi &lt; <span class="number">18.5</span>:</span><br><span class="line">    who, nat = <span class="string">"偏瘦"</span>,<span class="string">"偏瘦"</span></span><br><span class="line"><span class="keyword">elif</span> <span class="number">18.5</span> &lt;= bmi &lt;= <span class="number">24</span>:</span><br><span class="line">    who, nat = <span class="string">"正常"</span>,<span class="string">"正常"</span></span><br><span class="line"><span class="keyword">elif</span> <span class="number">24</span> &lt;= bmi &lt;= <span class="number">25</span>:    <span class="comment"># 多分支条件的覆盖是一个非常重要的问题</span></span><br><span class="line">    who, nat = <span class="string">"正常"</span>,<span class="string">"偏胖"</span></span><br><span class="line"><span class="keyword">elif</span> <span class="number">25</span> &lt;= bmi &lt;= <span class="number">28</span>:</span><br><span class="line">    who, nat = <span class="string">"偏胖"</span>,<span class="string">"偏胖"</span></span><br><span class="line"><span class="keyword">elif</span> <span class="number">28</span> &lt;= bmi &lt;= <span class="number">30</span>:</span><br><span class="line">    who, nat = <span class="string">"偏胖"</span>,<span class="string">"肥胖"</span></span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    who,nat = <span class="string">"肥胖"</span>,<span class="string">"肥胖"</span></span><br><span class="line">print(<span class="string">"BMI指标为：国际'&#123;&#125;',国内'&#123;&#125;'"</span>.format(who,nat))</span><br></pre></td></tr></table></figure>


<h2 id="七段数码管的绘制"><a href="#七段数码管的绘制" class="headerlink" title="七段数码管的绘制"></a>七段数码管的绘制</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#seven</span></span><br><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drawdrg</span><span class="params">()</span>:</span></span><br><span class="line">    turtle.penup()</span><br><span class="line">    turtle.fd(<span class="number">5</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drawline</span><span class="params">(draw)</span>:</span></span><br><span class="line">    drawdrg()</span><br><span class="line">    turtle.pendown() <span class="keyword">if</span> draw <span class="keyword">else</span> turtle.penup()</span><br><span class="line">    turtle.fd(<span class="number">40</span>)</span><br><span class="line">    drawdrg()</span><br><span class="line">    turtle.right(<span class="number">90</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drawdigit</span><span class="params">(digit)</span>:</span></span><br><span class="line">    drawline(<span class="literal">True</span>) <span class="keyword">if</span> digit <span class="keyword">in</span> [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>] <span class="keyword">else</span> drawline(<span class="literal">False</span>)</span><br><span class="line">    drawline(<span class="literal">True</span>) <span class="keyword">if</span> digit <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>] <span class="keyword">else</span> drawline(<span class="literal">False</span>)</span><br><span class="line">    drawline(<span class="literal">True</span>) <span class="keyword">if</span> digit <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>] <span class="keyword">else</span> drawline(<span class="literal">False</span>)</span><br><span class="line">    drawline(<span class="literal">True</span>) <span class="keyword">if</span> digit <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,] <span class="keyword">else</span> drawline(<span class="literal">False</span>)</span><br><span class="line">    turtle.left(<span class="number">90</span>)</span><br><span class="line">    drawline(<span class="literal">True</span>) <span class="keyword">if</span> digit <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>] <span class="keyword">else</span> drawline(<span class="literal">False</span>)</span><br><span class="line">    drawline(<span class="literal">True</span>) <span class="keyword">if</span> digit <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>] <span class="keyword">else</span> drawline(<span class="literal">False</span>)</span><br><span class="line">    drawline(<span class="literal">True</span>) <span class="keyword">if</span> digit <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>] <span class="keyword">else</span> drawline(<span class="literal">False</span>)</span><br><span class="line">    turtle.left(<span class="number">180</span>)</span><br><span class="line">    turtle.penup()</span><br><span class="line">    turtle.fd(<span class="number">40</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drawdata</span><span class="params">(data)</span>:</span></span><br><span class="line">    turtle.pencolor(<span class="string">'red'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">        <span class="keyword">if</span> i == <span class="string">'-'</span>:</span><br><span class="line">            turtle.write(<span class="string">"年"</span>,font=(<span class="string">"Arial"</span>,<span class="number">18</span>,<span class="string">"normal"</span>))</span><br><span class="line">            turtle.pencolor(<span class="string">"green"</span>)</span><br><span class="line">            turtle.fd(<span class="number">40</span>)</span><br><span class="line">        <span class="keyword">elif</span> i == <span class="string">'+'</span>:</span><br><span class="line">            turtle.write(<span class="string">"月"</span>,font=(<span class="string">"Arial"</span>,<span class="number">18</span>,<span class="string">"normal"</span>))</span><br><span class="line">            turtle.pencolor(<span class="string">"blue"</span>)</span><br><span class="line">            turtle.fd(<span class="number">40</span>)</span><br><span class="line">        <span class="keyword">elif</span> i == <span class="string">'='</span>:</span><br><span class="line">            turtle.write(<span class="string">"日"</span>,font=(<span class="string">"Arial"</span>,<span class="number">18</span>,<span class="string">"normal"</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            drawdigit(eval(i))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    turtle.setup(<span class="number">800</span>,<span class="number">500</span>,<span class="number">200</span>,<span class="number">200</span>)</span><br><span class="line">    turtle.penup()</span><br><span class="line">    turtle.fd(<span class="number">-300</span>)</span><br><span class="line">    turtle.pendown()</span><br><span class="line">    turtle.pensize(<span class="number">5</span>)</span><br><span class="line">    drawdata(time.strftime(<span class="string">'%Y-%m+%d='</span>,time.gmtime()))</span><br><span class="line">    turtle.hideturtle()</span><br><span class="line">    turtle.done()</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>


<h2 id="Hamlet词频统计"><a href="#Hamlet词频统计" class="headerlink" title="Hamlet词频统计"></a>Hamlet词频统计</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#calHamLet</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getText</span><span class="params">()</span>:</span></span><br><span class="line">    txt = open(<span class="string">"C:/Users/pikachu/AppData/Local/Programs/Python/Python36-32/hamlet.txt"</span>).read()</span><br><span class="line">    txt = txt.lower()</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> <span class="string">'!"#$%&amp;()*+,-./:;&lt;=&gt;?@[\\]^_‘&#123;|&#125;~'</span>:</span><br><span class="line">        txt.replace(ch,<span class="string">" "</span>)</span><br><span class="line">    <span class="keyword">return</span> txt</span><br><span class="line"></span><br><span class="line">hamlettxt = getText()</span><br><span class="line">words = hamlettxt.split()</span><br><span class="line">counts = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    counts[word] = counts.get(word,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">items = list(counts.items())</span><br><span class="line">items.sort(key = <span class="keyword">lambda</span> x:x[<span class="number">1</span>],reverse = <span class="literal">True</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>):</span><br><span class="line">    word,count = items[i]</span><br><span class="line">    print(<span class="string">"&#123;0:&lt;10&#125;&#123;1:&gt;5&#125;"</span>.format(word,count))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础语法</title>
    <url>/2018/08/02/Python/Python_old/Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>中国大学MOOC:  &lt;Python语言程序设计&gt;课程笔记</p>
<a id="more"></a>



<blockquote>
<h3 id="编译与解释"><a href="#编译与解释" class="headerlink" title="编译与解释"></a>编译与解释</h3><p>源代码：采用某种编程语言编写的计算机程序<br>目标代码：计算机可直接执行，人类不可读</p>
<p>编译：将源代码<strong>一次性</strong>转换成目标代码的过程<br>编译需要<strong>编译器（compiler）</strong>,是一次性翻译，之后不再需要源代码（类似英文翻译）<br>解释：将源代码<strong>逐条</strong>转换成目标代码同时逐条运行的过程<br>解释需要<strong>解释器（interpreter）</strong>，每次程序运行时随翻译随执行（类似同声传译）</p>
<p>根据执行方式不同，编程语言分成两种：</p>
<ol>
<li>静态语言: C, C++, Java (编译)<br>特点: 执行时不需要源代码，优化更充分，程序运行速度更快。</li>
<li>脚本语言: Python, JavaScript, PHP (解释)<br>特点: 执行时需要源代码，维护更灵活。</li>
</ol>
</blockquote>
<blockquote>
<h3 id="Python的解释器"><a href="#Python的解释器" class="headerlink" title="Python的解释器"></a>Python的解释器</h3><ul>
<li>python –&gt; 官方解释器</li>
<li>CPython –&gt; C语言实现的官方解释器</li>
<li>Jython –&gt; 可以运行在Java平台的解释器</li>
<li>IronPython – 可以运行在 .NET 和 Mono平台</li>
<li>PyPy – Python实现的Python解释器，支持JIT即时编译</li>
</ul>
</blockquote>
<blockquote>
<h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><p>Python语言采用严格的“缩进”来表明程序的格式框架。缩进表达了所属关系。<br>缩进可以使用空格或者tab来表示, 但是在一个程序中两者不能混用<br><strong>建议使用4个空格</strong></p>
</blockquote>
<blockquote>
<h3 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h3><p>python共有33个保留字</p>
<table>
<thead>
<tr>
<th>一</th>
<th>二</th>
<th>三</th>
<th>四</th>
</tr>
</thead>
<tbody><tr>
<td>True</td>
<td>def</td>
<td>if</td>
<td>raise</td>
</tr>
<tr>
<td>False</td>
<td>del</td>
<td>import</td>
<td>return</td>
</tr>
<tr>
<td>None</td>
<td>elif</td>
<td>in</td>
<td>try</td>
</tr>
<tr>
<td>and</td>
<td>else</td>
<td>is</td>
<td>while</td>
</tr>
<tr>
<td>as</td>
<td>except</td>
<td>lambda</td>
<td>with</td>
</tr>
<tr>
<td>assert</td>
<td>finally</td>
<td>nonlocal</td>
<td>yield</td>
</tr>
<tr>
<td>break</td>
<td>for</td>
<td>not</td>
<td></td>
</tr>
<tr>
<td>calss</td>
<td>from</td>
<td>or</td>
<td></td>
</tr>
<tr>
<td>continue</td>
<td>global</td>
<td>pass</td>
<td></td>
</tr>
</tbody></table>
</blockquote>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h3><ol>
<li><p><strong>整数类型</strong></p>
<p>取值范围 : [-∞, ∞]</p>
<p>4种进制表示形式 ：</p>
<ul>
<li><p>二进制 : 0b / 0B (引导符号)</p>
</li>
<li><p>八进制 : 0o / 0O</p>
</li>
<li><p>十进制</p>
</li>
<li><p>十六进制 : 0x / 0X</p>
</li>
</ul>
</li>
<li><p><strong>浮点数类型</strong></p>
<p>浮点数取值范围和精度都存在限制，但是常规计算中可以忽略<br>浮点数运算存在不确定尾数，不是bug<br><code>9.5e2</code> : 浮点数的科学计数法，表示 $9.5*10^2$</p>
</li>
<li><p><strong>复数类型</strong></p>
<p><code>z = a + bj</code><br><code>z.real</code> 获得实部<br><code>z.imag</code>  获得虚部</p>
</li>
</ol>
<h3 id="数字类型的操作"><a href="#数字类型的操作" class="headerlink" title="数字类型的操作"></a>数字类型的操作</h3><ol>
<li><p><strong>数值运算操作符</strong></p>
<ul>
<li><p>基本操作符</p>
<p><code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>//</code>(整数除)、<code>%</code>(取余)、<code>**</code>(幂)、</p>
</li>
<li><p>增强赋值操作符</p>
<p><code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>//=</code>、<code>%=</code>、<code>**=</code></p>
</li>
</ul>
</li>
<li><p><strong>内置数值运算函数</strong></p>
<ul>
<li><p><code>abs(x)</code>  绝对值</p>
</li>
<li><p><code>divmod(x,y)</code>  商余，(x//y，x%y)，同时输出商和余数(输出元组)</p>
</li>
<li><p><code>pow(x,y[,z])</code>  幂余，z为取余</p>
</li>
<li><p><code>round(x[,d])</code>  四舍五入, 保留d位小数, 省略d时返回四舍五入的整数值</p>
</li>
<li><p><code>max(x,y...)</code>  返回最大值</p>
</li>
<li><p><code>min(x,y...)</code>  返回最小值</p>
</li>
</ul>
</li>
<li><p><strong>内置数字类型转换函数</strong></p>
<ul>
<li><p><code>int(x)</code>  将x转换为整数, x可以是<strong>浮点数</strong>(直接舍弃小数)或<strong>字符串</strong></p>
</li>
<li><p><code>float(x)</code>  将x转换为浮点数, x可以是<strong>整数</strong>或<strong>字符串</strong></p>
</li>
</ul>
</li>
</ol>
<h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p><strong>表示形式:</strong> </p>
<ul>
<li><code>&#39;字符串&#39;</code></li>
<li><code>&quot;字符串&quot;</code></li>
<li><code>&#39;&#39;&#39;字符串&#39;&#39;&#39;</code> </li>
<li><code>&quot;&quot;&quot;字符串&quot;&quot;&quot;</code></li>
</ul>
<blockquote>
<p>  python中并没有多行注释的语法, 当三个单引号的字符串不赋给任何变量时, 就被当成是多行注释.</p>
</blockquote>
<p><strong>在字符串中表示单引号或双引号:</strong></p>
<ul>
<li><code>&quot;这里有个单引号(&#39;)&quot;</code> </li>
<li><code>&#39;这里有个双引号(&quot;)&#39;</code></li>
<li><code>&quot;&quot;&quot;这里同时有单引号(&#39;)和双引号(&quot;)&quot;&quot;&quot;</code></li>
</ul>
<p><strong>字符串的索引:</strong> </p>
<ul>
<li>正向递增序号: 从左至右，从0开始</li>
<li>反向递减序号: 从右至左，从-1开始</li>
</ul>
<p><strong>字符串切片:</strong> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">'pikachu'</span></span><br><span class="line">s[<span class="number">0</span>]      <span class="comment"># 'p'</span></span><br><span class="line">s[<span class="number">0</span>:<span class="number">2</span>]    <span class="comment"># 'pi'</span></span><br><span class="line">s[<span class="number">2</span>:]     <span class="comment"># 'kachu'</span></span><br><span class="line">s[:<span class="number">-1</span>]    <span class="comment"># 'pikach'</span></span><br><span class="line">s[<span class="number">0</span>:<span class="number">-1</span>:<span class="number">2</span>] <span class="comment"># 'pkc'</span></span><br><span class="line">s[::<span class="number">-1</span>]   <span class="comment"># 'uhcakip' (字符串逆序输出)</span></span><br></pre></td></tr></table></figure>

<p><strong>字符串操作符:</strong></p>
<ul>
<li><code>s1 + s2</code> : 连接两个字符串</li>
<li><code>s1 * 3</code> : 重复s1 三次</li>
<li><code>s1 in s2</code> : 判断s1是否为s2的子串, 返回<code>True / False</code></li>
</ul>
<blockquote>
<p>  转义符 <code>\</code> : 表达特定字符的本意<br>  <code>&quot;这里有个双引号(\&quot;)&quot;</code> –&gt;  <code>&quot;这里有个双引号(&quot;)&quot;</code></p>
</blockquote>
<p><strong>内置字符串处理函数：</strong></p>
<ul>
<li><p><code>len(x)</code>    # 返回字符串x的长度</p>
</li>
<li><p><code>str(x)</code>    # 将任何类型的x转换成字符串的形式。  和 <code>eval()</code>是一对对应的函数</p>
</li>
<li><p><code>hex(x)</code>    # 返回<strong>整数</strong>x的十六进制小写形式字符串</p>
</li>
<li><p><code>oct(x)</code>    # 返回<strong>整数</strong>x的八进制小写形式字符串</p>
</li>
<li><p><code>chr(u)</code>    # u为Unicode编码，返回其对应的字符</p>
</li>
<li><p><code>ord(x)</code>    # x为字符，返回其对应的Unicode编码</p>
</li>
</ul>
<p><strong>字符串处理方法：</strong></p>
<ul>
<li><code>str.lower()</code>    # 将字符串中的英文字母全变成小写</li>
<li><code>str.upper()</code>    # 将字符串中的英文字母全变成大写</li>
<li><code>str.split(sep=None)</code>    # 返回一个列表，由str根据sep被分割的部分组成<ul>
<li><code>&#39;A,B,C&#39;.split(&#39;,&#39;)</code>    输出结果为<code>[&#39;A&#39;,&#39;B&#39;,&#39;C&#39;]</code></li>
</ul>
</li>
<li><code>str.join(iterable)</code>    # 返回一个新字符串, 由iterable中的变量每个元素组成, 元素用str间隔<ul>
<li><code>&#39;,&#39;.join([a, b, c, d, e])</code>    输出为<code>&#39;a,b,c,d,e&#39;</code></li>
</ul>
</li>
<li><code>str.count(sub)</code>    # 返回子串sub在str中出现的次数</li>
<li><code>str.replace(old,new)</code>    # 返回字符串str副本，将所有old子串替换成new</li>
<li><code>str.center(width[,fillchar])</code>    # 返回width长度的字符串, 字符串str居中显示，fillchar为str两边的填充字符<ul>
<li><code>&#39;Pikachu&#39;.center(21,&#39;*&#39;)</code>    输出为<code>&#39;*******Piakchu*******&#39;</code></li>
</ul>
</li>
<li><code>str.strip(chars)</code>    # 从str左右两侧去掉chars中所列出的字符<ul>
<li><code>&#39; hello &#39;.strip(&#39; &#39;)</code> 输出为  <code>&#39;hello&#39;</code></li>
</ul>
</li>
</ul>
<p><strong>字符串类型格式化：</strong></p>
<p>字符串格式化采用 <code>.format()</code> 的方法    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"&#123;&#125;:计算机&#123;&#125;的CPU占用率为&#123;&#125;%"</span>.format(<span class="string">"李明"</span>,<span class="string">"C"</span>,<span class="string">"50"</span>)</span><br><span class="line"><span class="comment"># 上面语句输出为: "李明:计算机C的CPU占用率为50%"</span></span><br></pre></td></tr></table></figure>

<p>{} 称为槽。<br>槽内部对格式化的配置方式：{&lt;参数序号&gt;:&lt;格式控制标记&gt;}</p>
<table>
<thead>
<tr>
<th align="center">：</th>
<th align="center">&lt;填充&gt;</th>
<th align="center">&lt;对齐&gt;</th>
<th align="center">&lt;宽度&gt;</th>
<th align="center">&lt; , &gt;</th>
<th align="center">&lt;.精度&gt;</th>
<th align="center">&lt;类型&gt;</th>
</tr>
</thead>
<tbody><tr>
<td align="center">引导符号</td>
<td align="center">用于填充单个字符</td>
<td align="center">&lt;左对齐，&gt;右对齐，^居中</td>
<td align="center">槽设定的输出宽度</td>
<td align="center">数字的千位分隔符</td>
<td align="center">浮点数小数精度或字符串最大输出长度</td>
<td align="center">整数类型b,c,d,o,x,X  浮点数类型 e,E,f,%</td>
</tr>
</tbody></table>
<p>举个栗子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"&#123;0:=^20&#125;"</span>.format(<span class="string">"Python"</span>)    <span class="comment"># 输出为： '=======Python======='</span></span><br><span class="line"></span><br><span class="line"><span class="string">"&#123;0:,.2f&#125;"</span>.format(<span class="number">123456.789</span>)    <span class="comment"># 输出为:  '123,456.79'</span></span><br></pre></td></tr></table></figure>



<h2 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h2><p>分支结构分为: </p>
<ul>
<li>单分支结构</li>
<li>二分支结构</li>
<li>多分支结构</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单分支结构</span></span><br><span class="line"><span class="keyword">if</span> 条件:</span><br><span class="line">    语句块</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二分支结构</span></span><br><span class="line"><span class="keyword">if</span> 条件:</span><br><span class="line">    语句块<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    语句块<span class="number">2</span></span><br><span class="line"></span><br><span class="line">&lt;表达式<span class="number">1</span>&gt; <span class="keyword">if</span> &lt;条件&gt; <span class="keyword">else</span> &lt;表达式<span class="number">2</span>&gt;  <span class="comment">#二分支结构的紧凑形式</span></span><br><span class="line">guess = eval(input())</span><br><span class="line">print(<span class="string">"猜&#123;&#125;了"</span>.format(<span class="string">"对"</span> <span class="keyword">if</span> guess == <span class="number">99</span> <span class="keyword">else</span> <span class="string">"错"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多分支结构</span></span><br><span class="line"><span class="keyword">if</span> &lt;条件&gt;:    <span class="comment">#使用多分支结构时，要注意多条件之间的包含关系</span></span><br><span class="line">    &lt;语句块<span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">elif</span> &lt;条件&gt;:</span><br><span class="line">    &lt;语句块<span class="number">2</span>&gt;</span><br><span class="line">……</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;语句块N&gt;</span><br></pre></td></tr></table></figure>

<h3 id="条件判断及条件组合"><a href="#条件判断及条件组合" class="headerlink" title="条件判断及条件组合"></a>条件判断及条件组合</h3><p>条件判断</p>
<table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&lt;</td>
<td align="center">小于</td>
</tr>
<tr>
<td align="center">&lt;=</td>
<td align="center">小于等于</td>
</tr>
<tr>
<td align="center">&gt;=</td>
<td align="center">大于等于</td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="center">大于</td>
</tr>
<tr>
<td align="center">==</td>
<td align="center">等于</td>
</tr>
<tr>
<td align="center">!=</td>
<td align="center">不等于</td>
</tr>
</tbody></table>
<p>条件组合<br><code>and(&amp;)</code>, <code>or(|)</code>, <code>not</code></p>
<h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><p>遍历循环</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;循环变量&gt; <span class="keyword">in</span> &lt;遍历结构&gt;:  <span class="comment">#从遍历结构中逐一提取元素，放到循环变量中</span></span><br><span class="line">    &lt;语句块&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(N): <span class="comment">#计数循环N次</span></span><br><span class="line">    &lt;语句块&gt;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(M,N[,K]): <span class="comment">#计数循环特定次[,K为步长]</span></span><br><span class="line">    &lt;语句块&gt;</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> s: <span class="comment">#s为字符串，遍历字符串每个字符</span></span><br><span class="line">    &lt;语句块&gt;</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> ls: <span class="comment">#ls时列表，遍历列表的每个元素</span></span><br><span class="line">    &lt;语句块&gt;</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> fi: <span class="comment">#fi是一个文件标识符（一篇文章），遍历其每行</span></span><br><span class="line">    &lt;语句块&gt;</span><br></pre></td></tr></table></figure>

<p>无限循环</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> &lt;条件&gt;:</span><br><span class="line">    &lt;语句块&gt;</span><br></pre></td></tr></table></figure>

<p>循环控制保留字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">break</span>  <span class="comment">#跳出当前循环</span></span><br><span class="line"><span class="keyword">continue</span>  <span class="comment">#结束当次循环</span></span><br></pre></td></tr></table></figure>

<p>循环的拓展</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;循环变量&gt; <span class="keyword">in</span> &lt;遍历结构&gt;:</span><br><span class="line">    &lt;语句块<span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">else</span>:       <span class="comment">#当循环正常完成后，执行else语句块</span></span><br><span class="line">    &lt;语句块<span class="number">2</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> &lt;条件&gt;:</span><br><span class="line">    &lt;语句块<span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">else</span>:       <span class="comment">#如果循环被break跳出，不执行else语句块</span></span><br><span class="line">    &lt;语句块<span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure>



<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>形式1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    &lt;语句块<span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    &lt;语句块<span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure>
<p>形式2</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    &lt;语句块<span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">except</span>&lt;异常类型&gt;:    <span class="comment">#标注异常类型后，仅响应该异常</span></span><br><span class="line">    &lt;语句块<span class="number">2</span>&gt;       <span class="comment">#异常类型名字等同于变量</span></span><br></pre></td></tr></table></figure>
<p>异常处理的高级使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    &lt;语句块<span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    &lt;语句块<span class="number">2</span>&gt;</span><br><span class="line"><span class="keyword">else</span>:       <span class="comment">#else对应的语句块3在不发生异常时执行</span></span><br><span class="line">    &lt;语句块<span class="number">3</span>&gt;</span><br><span class="line"><span class="keyword">finally</span>:    <span class="comment">#finally对应的语句块4一定执行</span></span><br><span class="line">    &lt;语句块<span class="number">4</span>&gt;</span><br></pre></td></tr></table></figure>



<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数的作用：降低编程难度 和 代码复用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> &lt;函数名&gt;<span class="params">(&lt;参数<span class="params">(<span class="number">0</span>个或多个)</span>&gt;)</span>:</span></span><br><span class="line">    &lt;函数体&gt;</span><br><span class="line">    <span class="keyword">return</span> &lt;返回值&gt;    <span class="comment">#return可以有可以没有</span></span><br></pre></td></tr></table></figure>

<h3 id="函数参数类型"><a href="#函数参数类型" class="headerlink" title="函数参数类型"></a>函数参数类型</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可选参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> &lt;函数名&gt;<span class="params">(&lt;非可选参数&gt;，&lt;可选参数&gt;)</span>:</span> <span class="comment">#定义时需给可选参数一个默认值</span></span><br><span class="line">    &lt;函数体&gt;</span><br><span class="line">    <span class="keyword">return</span> &lt;返回值&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可变参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> &lt;函数名&gt;<span class="params">(&lt;参数&gt;,*b)</span>:</span></span><br><span class="line">    &lt;函数体&gt;</span><br><span class="line">    <span class="keyword">return</span> &lt;返回值&gt;</span><br></pre></td></tr></table></figure>
<p>函数调用时，参数传递的方式有<strong>位置传递</strong>和<strong>名称传递</strong></p>
<h3 id="局部变量的全局变量："><a href="#局部变量的全局变量：" class="headerlink" title="局部变量的全局变量："></a>局部变量的全局变量：</h3><p>1.局部变量：函数中的变量<br>2.全局变量：函数外的变量<br>3.局部变量和全局变量可能重名但不同<br>4.函数运算结束后，局部变量被释放<br>5.可以使用global保留字在函数内部使用全局变量<br>6.如果局部变量为组合数据类型且未被真实创建时，等同于全局变量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ls = [<span class="string">'F'</span>,<span class="string">'f'</span>]  <span class="comment">#通过使用[]真实创建了一个全局变量列表ls</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a)</span>:</span></span><br><span class="line">    ls.append(a)  <span class="comment">#此处ls为列表类型，未被真实创建，等同于全局变量</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">func(<span class="string">'C'</span>)</span><br><span class="line">print(ls)  <span class="comment">#结果为['F','f','C']</span></span><br></pre></td></tr></table></figure>

<h3 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h3><p>lambda函数是一种匿名函数，即没有名字的函数<br>使用<code>lambda</code>保留字定义，返回值是函数名<br>lambda用于定义简单的，可以在一行内表示的函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;函数名&gt; = <span class="keyword">lambda</span> &lt;参数&gt;:&lt;表达式&gt;</span><br><span class="line">f = <span class="keyword">lambda</span> x,y : x+y</span><br><span class="line">f(<span class="number">10</span>,<span class="number">15</span>)  <span class="comment">#结果为 25</span></span><br></pre></td></tr></table></figure>


<blockquote>
<p>  代码复用: <strong>函数</strong> 和 <strong>对象</strong> 是代码复用的两种主要形式</p>
<ul>
<li><p>函数：在代码层面建立了初步抽象</p>
</li>
<li><p>对象：在函数之上再次组织进行抽象</p>
<p>模块化设计：通过函数或对象封装将程序划分为模块及模块间的表达<br>模块内部<strong>紧耦合</strong>，模块之间<strong>松耦合</strong></p>
</li>
</ul>
</blockquote>
<h3 id="函数递归"><a href="#函数递归" class="headerlink" title="函数递归"></a>函数递归</h3><p>定义：函数定义中调用函数自身的方式<br>函数递归的两个特征：</p>
<ul>
<li>递归基例</li>
<li>递归链条</li>
</ul>
<p>函数递归的实现：函数 + 分支语句</p>
<h2 id="组合数据类型"><a href="#组合数据类型" class="headerlink" title="组合数据类型"></a>组合数据类型</h2><h2 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h2><p>集合类型的特点：</p>
<ul>
<li>集合是多个元素的无序组合</li>
<li>集合中没有相同的元素</li>
<li>集合类型是由不可变数据类型组成的</li>
</ul>
<p>集合用{}表示，元素中间用,分隔<br>集合用{}建立，也可用set()建立集合<br>建立空集合只能用set()</p>
<pre><code>A = {&quot;python&quot;,123,(&quot;python&quot;,123)}
*{123,&apos;python,(&quot;python&quot;,123)}*
B = set(&quot;pypy123&quot;)
*{&apos;1&apos;,&apos;P&apos;,&apos;2&apos;,&apos;3&apos;,&apos;y&apos;}*</code></pre><h3 id="集合操作符"><a href="#集合操作符" class="headerlink" title="集合操作符"></a>集合操作符</h3><p>(并)S|T : 返回一个新集合，包括在集合S和T中的所有元素<br>(差)S-T : 返回一个新集合，包括在集合S但不在T中的元素<br>(交)S&amp;T : 返回一个新集合，包括同时在集合S和T中的元素<br>(补)S^T : 返回一个新集合，包括集合S和T中的非相同元素</p>
<p>4个增强操作符：<br>S|=T : 更新集合S，包括在集合S和T中的所有元素<br>S-=T : 更新集合S，包括在集合S但不在T中的元素<br>S&amp;=T : 更新集合S，包括同时在集合S和T中的元素<br>S^=T : 更新集合S，包括集合S和T中的非相同元素</p>
<h3 id="集合处理方法"><a href="#集合处理方法" class="headerlink" title="集合处理方法"></a>集合处理方法</h3><p>S.add(x)  如果x不在集合中，将x添加到S中<br>S.discard(x)  移除S中元素x，如果x不在集合S中，不报错<br>S.remove(x)  移除S中元素x，如果x不在集合S中，则产生KeyError异常<br>S.clear()  移除S中所有元素<br>S.pop()  随机返回S中的一个元素，更新S，如果S为空产生KeyError异常</p>
<p>S.copy()  返回集合S的一个副本<br>len(S)  返回集合S的元素个数<br>x in S  判断x是否在集合S中，返回True或False<br>x not in S  判断x是否在集合S中，返回True或False<br>set(x)  将其他数据变量x转变为集合类型</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">A = &#123;<span class="string">"ha"</span>,<span class="string">"ha"</span>,<span class="number">666</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> A    <span class="comment">#一般情况下遍历集合用for  in  就可以</span></span><br><span class="line">    print(i,end=<span class="string">""</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(A.pop(),end=<span class="string">""</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h3 id="集合类型应用场景"><a href="#集合类型应用场景" class="headerlink" title="集合类型应用场景"></a>集合类型应用场景</h3><p>1.包含关系比较<br>2.<strong><em>数 据 去 重</em></strong>(集合类型最重要的应用)</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">ls = [<span class="string">'p'</span>,<span class="string">'p'</span>,<span class="string">'y'</span>,<span class="number">123</span>]</span><br><span class="line">S = set(ls)  <span class="comment">#将列表类型转换成集合类型</span></span><br><span class="line"></span><br><span class="line">lt = list(S)  <span class="comment">#将集合转换为列表</span></span><br></pre></td></tr></table></figure>








<h1 id="文件及数据格式化"><a href="#文件及数据格式化" class="headerlink" title="文件及数据格式化"></a>文件及数据格式化</h1><h2 id="文件的类型"><a href="#文件的类型" class="headerlink" title="文件的类型"></a>文件的类型</h2><p>文本文件和二进制文件（文件的两种展示方式）<br>文本文件是由特定编码组成的文件，如.txt、.py文件<br>二进制文件直接由0和1组成，如.avi、.png文件等</p>
<h2 id="文件的打开关闭"><a href="#文件的打开关闭" class="headerlink" title="文件的打开关闭"></a>文件的打开关闭</h2><p>1、文件的打开</p>
<p><code>变量名 = open(文件名, 打开模式)</code></p>
<p>2、文件的打开模式</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>‘r’</td>
<td>只读模式，默认值，若文件不存在，返回FileNotFoundError</td>
</tr>
<tr>
<td>‘w’</td>
<td>覆盖写模式，文件不存在则创建，存在则完全覆盖</td>
</tr>
<tr>
<td>‘x’</td>
<td>创建写模式，文件不存在则创建，存在则返回FileExistsError</td>
</tr>
<tr>
<td>‘a’</td>
<td>追加写模式，文件不存在则创建，存在则在文件最后追加内容</td>
</tr>
<tr>
<td>‘t’</td>
<td>文本文件模式，默认值</td>
</tr>
<tr>
<td>‘b’</td>
<td>二进制文件模式</td>
</tr>
<tr>
<td>‘+’</td>
<td>与r/w/x/a连用，在原功能基础上增加读写功能</td>
</tr>
</tbody></table>
<p>3、文件的关闭</p>
<p><code>变量名.close()</code></p>
<p>4、文件的读取</p>
<p><code>变量名.read(size)</code>    读入全部内容，如果给出参数，读入前size长度<br><code>变量名.rendline(size)</code>   读入一行内容，如果给出参数，读入该行前size长度<br><code>变量名.readlines(hint)</code>   读入所有行，以每行为元素形成列表，如果给出参数，读入前hint行</p>
<hr>
<p>a.wtite(s)    向文件写入一个字符串或字节流<br>a.writelines(lines)    将一个元素全为字符串的列表写入文件<br>a.seek(offset)    改变当前文件操作指针的位置，0 - 文件开头； 1 - 当前位置； 2 - 文件结尾</p>
<p>5、一维数据</p>
<p>一维数据的表示：列表类型（有序）、集合类型（无序）<br>一维数据的存储：空格分隔，逗号分隔，或者特殊字符分隔<br>    使用任何一种符号进行分隔都有缺点，就是无法控制文本中不出现与分隔符相同的字符<br>一维数据的处理：<br>从空格分隔的文件中读入数据：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">txt = open(fname).read()</span><br><span class="line">ls = txt.split()</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<p>从特殊符号分隔的文件中读入数据：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">txt = open(fname).read()</span><br><span class="line">ls = txt.split(<span class="string">"$"</span>)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<p>采用空格分隔方式将数据写入：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">ls = [<span class="string">'中国'</span>，<span class="string">'美国'</span>,<span class="string">'日本'</span>]</span><br><span class="line">f = open(fname,<span class="string">'w'</span>)</span><br><span class="line">f.write(<span class="string">' '</span>.join(ls))</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<p>采用特殊符号分隔方式将数据写入：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">ls = [<span class="string">'中国'</span>，<span class="string">'美国'</span>,<span class="string">'日本'</span>]</span><br><span class="line">f = open(fname,<span class="string">'w'</span>)</span><br><span class="line">f.write(<span class="string">'$'</span>.join(ls))</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法</title>
    <url>/2018/08/01/%E5%85%B6%E5%AE%83%E7%AC%94%E8%AE%B0/Markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>用markdown写笔记, 简直爽歪歪</p>
<a id="more"></a>

<h1 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h1><pre><code># 这是一级标题
## 这是二级标题
### 这是三级标题
#### 这是四级标题
##### 这是五级标题
###### 这是六级标题

标题最多六级</code></pre><h1 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h1><pre><code>1.倾斜
    * 这样倾斜 *
2.加粗
    ** 这是加粗 **
3.倾斜加粗
    *** 这是倾斜加粗 ***
4.删除线
    ~~ 这是删除线 ~~</code></pre><h1 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h1><pre><code>&gt; 这是引用的内容
&gt;&gt; 这个也是引用的内容

引用可以嵌套</code></pre><h1 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h1><pre><code>三个或者三个以上的 - 或者 * 都可以
---
这个东西就是分割线
----
这个东西也是分割线</code></pre><h1 id="五、代码"><a href="#五、代码" class="headerlink" title="五、代码"></a>五、代码</h1><pre><code>单行代码  ` 代码内容 `</code></pre><hr>
<pre><code>多行代码

    这是三个 `

        代码内容

    这也是三个 `</code></pre><p>下面我就试一下单行代码和多行代码</p>
<pre><code>1.单行代码 </code></pre><p><code>print(&quot;Hello World&quot;)</code></p>
<pre><code>2.多行代码</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input(&quot;请输入我爱你:&quot;)</span><br><span class="line">print(&quot;I Love You&quot;)</span><br></pre></td></tr></table></figure>
<pre><code>2.多行代码(加高亮)</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">input(<span class="string">"请输入我爱你:"</span>)</span><br><span class="line">print(<span class="string">"I Love You"</span>)</span><br></pre></td></tr></table></figure>

<hr>
<pre><code>另外还有关于
    列表
    表格
    图片
    超链接
    流程图
等内容，现在用到的不多，以后再做记录。</code></pre>]]></content>
      <categories>
        <category>其他技术</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
